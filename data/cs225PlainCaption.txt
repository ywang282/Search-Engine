good ok I have some questions I can ask while we are waiting for the system to start. Alright. I don't have mic either, coz we are waiting for the system to start. Okay, I have a question for you. So it has been my standard protocol for the last several years to print out handouts that are copies of my lecture slides for you I wanna know if I bring these paper handouts to you, how many of you will actually, just rise your hand, just give me a rough estimate how many of you will actually annotate them with a pen, if I bring these handouts? Maybe, maybe the better question is how many of you do not see yourself actually applying a pen to a piece of paper to take notes. rise your hand if you think you're just gonna do things via pdf.  Ok,  I will continue to print them out. I saw, I did see a few hands doing this. you guys didn't see any hands but I saw a few those. so it's ok to do this. we are not alright you are gonna put it into so there's one first last thing of teaching the first last thing of teaching is never never never try new technologies the first day of class. we are breaking rules around here. that looks like a that looks like a different input. that looks like maybe one of the HDMI that looks like a document camera or something. a hidden document camera center, laptop HDMI to the center and apply, do you have to apply it then? ok laptop HDMI go, and then should just work but it looks like, there is like I think it seems I am projecting. ok it's going oh no ok I am reconnecting. Don't touch anything. I am reconnecting. do we know each other? like middle school maybe? what's your last name? oh... ok so my thing is connected i believe I gotta work ok give me BGA so now it just disconnected ok you can connect. alright   Alright. Let's start. 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Yes, we're working out kinks, but guess what? It is 190% better this semester than it was last semester in this room at this time. Umm, there are some hidden problems you don't even know about. For example, guess what color that ink is? Red. It is red ink. So we'll figure all this out. And we're not wireless so I cannot play frisbee with my laptop, that's the dream we'll be working toward that. Umm, and it's a whole new ecosystem for me so patience is good. Alright so any good parties start off with introductions. So I'm Cinda, I'm not doing this alone this semester. Well I never ever do it alone but this time I actually have a co-teacher, he's actually new to campus sort of, his name is Mattox Beckman. I'm going to introduce him right now, and it turns out that Mattox and I should have been friends decades ago because our time working on our PhD coincided almost exactly on this campus but we only knew of each other by reputation, we didn't actually know each other. He's the new lecturer in this department, and he's going to bring a lot of new energy and ideas. The next introductions I want to do are not for details but purely for magnitude. I want you to see the sheer magnitude of the course staff we have available to you. So I invited all of course staff to come introduce themselves at the start of the hour and about a fourth of them showed up. So, here's my challenge to you. Do better at class attendance than course staff did at coming to introduce themselves. This is fun when almost all the seats are full. Alright so anyway, I want them to tell you who they are very quickly, because I want you to hear the variety of places they come from and years that they are in school. So tell me your name, your year in school and your major. Hi, I'm Bol, I'm a first year grad student, I did my undergrad in civil but now I'm starting CS. Wow, that's exciting, nice to meet you too. I'm also meeting some of these people for the first time. Hi, I'm George, I'm a second year in CS. George, I knew you when you were this tall. Hi, I'm Laura, I'm a senior in CS. Hi, I'm Andrew, I'm a sophomore in CS. Hi, I'm Mosa, I'm a junior in computer engineering. That means this building is his home. We're visitors here. Some of the rest of us are visitors here. I'm Shi-shen, I'm a junior in CS. I'm Flora, I'm a junior in CS. How long have you been a computer scientist, Flora? A computer scientist, since high school but... A computer science major? A computer science major since last Thursday. And we're very happy about it. We got her!. Hi, I'm Adya, I'm a junior in CS. Hi, I'm Justin, I'm a junior in CE. Oh, another one. (laughter) I'm Chase, first year grad and CS. I'm Rohan and I'm a junior in CS. I'm Terry, I'm an english PhD and now just won't be teaching you. I'll be helping Beckman. He's actually going to read all your emails before I do. So, when you compose something to me, you're going to send it some place Terry sees first, so if you're mean to me, he's going to change all the wording. Because that's what he does. And you know, you can be as mean as - no way. That's wrong. Hi guys, I'm Asma, second year PhD in CS. I TA'd 125 last semester. I can see some of my students here so, really exciting! Hi guys, I'm Chaitanya, second year grad student in CS. Again, I TA'd with Asma, and I can see couple of people here. We get all the good ones, eventually! I'm Roy, I'm a first year grad in CS. Where you an undergrad here? Yes, okay. So, one thing we really like - did everybody get to introduce themselves? - one thing I really like is that our undergrads tend to stay for grad school. Chase was an undergrad here too. So they know the course, they know what's going on. Okay, so that's us. You guys can do whatever - oh, I have a task already. Could you pass somebody - volunteer to pass out handouts? The printer died halfway thru so, maybe divvy those up and kinda do them by rows. First official task. Okay, but we're not done with introductions because there is that awkward moment where you know us but we don't know you. So, first of all, I'm always curious about majors. So raise your hand if you're  a CS major. Okay, so everybody see that? So what we're doing here is building histograms over the room. You can tell density of things by looking around the room, we do this all the time. Raise your hand if you're a Comp E. Look at that, about half and half! About half and half for this semester. How about EE?
Oh, a third a third, a third.  Ok. Raise your hand if your major is none of the above. Ok. A fourth, a fourth, a fourth. Raise your hand if it is not the above and you would like to be a cs minor or you're intending to be a cs minor. Ok. Alright. So somebody who is uh..one of the not of the aboves volunteer to have a little conversation with me. So raise your hand if you are willing to have a public conversation with me about your major.  Anybody willing to do that? Ok. Ohh...we're in this huge room. Oh,  Tim you are gonna save me. Thank you. Ok.  So, what's your major? Economics. Ok. So how are you using computer science and economics? What's your intention? I have no idea. Ok. That's perfectly fair. Now. What I really..so that was all superficial right? That's what you'd..exactly. What dorm do you live in kind of stuff. But here is the meaningful thing. Ok. Tim, did it hurt you to speak into my microphone to all these people?  Oh no. Not all all, right? Ok! So my challenge for each one of you is to do that sometime during this semester, to have a little bit of dialogue with me or with whoever who happens to be teaching cuz it's a little bit weird to talk in this room for the first time for most people. But is there somebody else over here who is willing to have a conversation? Okay. What's your major?  I am a jazz studies. Is it music?  Yea. Ok. Are you? So are you a performer? Well it could be dance? Come on.. it could be dance? Are you performer? Uh..I guess I am, but I cannot dance. Ok. And did this experience hurt? No, it did not. I mean, a little bit. But.. It hurt a little bit? Alright. So we are not going to spend any more time getting you used to the feel of the room, but I would really really like for you to make it a personal goal to be brave enough to like.. raise your hand, offer an answer, its..its..we need it. Alright. So. Moving beyond that. Ok. So what I want to know are, is your year in school approximately.  Ok. So if you are a freshmen or sophomore, raise your hand. Ok.  I'm thinking two-thirds. We'll give that a guess. If you are a junior or senior, raise your hand.  Yea, ok. About a third. And what if you're..how about a grad student? Anybody a grad student?  here..a few grad students. Ok. Alright. Let's see. Anybody else have a question? I have a puzzle for you. Somebody think of a question that you believe will divide the room in half. Divide the room.. Hang on.. Divide the room in half. Yes? You have a question you think will divide the room in half? Ok. I should have traveling mics. Yes? Are you male? Oh..that is wishful thinking on your part. On my part too.. I can riff on inclusivity and diversity for a really long time. And probably throughout the semester, some issues will come up. You know I think it doesn't divide the room in half. Should we try it? Yea..Ok. So raise your hand if you identify as male? This is putting people on the spot, huh..sorry. You don't have to answer this one. Raise your hand if you happen to identify as female. Yea ok. Let's fix this. Ok? Let's work together to fix it. It's no one person's issue. Computing is cool and it's a shame when it's only few people doing it. Ok. Another question that divides the room in half. Yea? Can you yell? Just yell, so I don't have to run. I'm getting tired. In the what? the what? the thursday lab discussion.. Thursday? Thursday lab discussion? People with lab discussions on Thursdays? This is a good one because...ok. Fine. Friday lab discussions? And yea that pretty much divides it in half? Wednesday night lab discussions? How cute. They're doing this. They're doing this thing. Ok. There are few. Ok. How about this? Cubs or Cardinals?  Cubs? Cardinals? I haven't been to the zoo lately? I don't know what you're talking about?  Ok.  Among people in central Illinois, the issue of Cubs and Cardinals divides neighborhoods. Ok. Baseball to Baseball thing.  Umm.. Ok. Do you know that we are effectively at the geographic center of Indianapolis, St. Louis, and Chicago? Which make means that everybody in town should be a Packers fan instead of a Bears, Colts, or Rams fan, but you know unfortunately those are few and far between. Ok. Um..Anything anybody else wants to tell me  about you guys Oh I know one.  Late night versus early morning? Hi, Sylvia. Late night versus early morning? Ok. I consider myself a night owl.
I love the early mornings Okay Alright, nice, we will have o, we will have office hours early in the morning. You can tell how they will be populated versus the evening one. Its wise to rise with the birds, carninals haha. Okay. Alright, we need to get rolling cause I actually intend to talk about c++ today rather than just riffing on the joy of college. So, we should work. Anybody wanna tell me anything else? Okay So, all you need to know. Okay this is gonna be the thing. Will be. Here I haven't actually our site to the official site yet. But, all of the logistic details of the course will be at the course website. Including all information on this stuff. We haven't connected the pieces together, but that should be your first stop for questions that you have about course infrastructure. And that's pretty much all I am gonna say about it. I am not gonna talk about the details of grading at this point. I am not gonna talk about the details of MPs, Machine Problems. The only thing I am going to tell you is that lab sections meet this week. So, when you registered for this course, you registered for lab section. This first week I request that you please go to the one for which you are registered. In subsequent semester, or in subsequent weeks, you may be able to flip around if you need to. But for this first week, while we are getting a grip on who's actually in the class. Please go to the one to which you are registered for. Okay, any questions about that? Okay. So, everyday, so you can almost think of this moment as the first moment of lecture Everyday, we will start the lecture with the series of announcements. Those announcements will tell you uh oh don't know what I did. Where did the magic guy go. I didn't do anything. Ian save me. Okay. So, these announcements will tell you what is going on with the course in terms of due dates. I.. I don't know Yeah Okay I'm gonna keep going Oh good see. Okay So the announcements today are we are gonna give you your first assignment later this afternoon. Also your first programming assignment later this afternoon So you want me to hurry up, so we get c++ Classes are cancelled on Monday because of Labor day. And that's this Monday right? the Next monday Is that right? the first Monday? Oh brother. That's actually this noon nifty font. This is this new nifty font that makes 7s look like 1s Thats all. Okay So we have class on Monday. Okay, fine we are good. I think we are good We'll see. I'll figure this out. I need a calendar in front of my face. Mattox you helping me here? Labor day is
Yes No it isn't. Because this is the magic of that fun You gotta gonna flip a coin. And decide which one it is everytime Here is what we are gonna do for our debug you brain As long as I try, not everything in the lecture is clear.  So what we are going to do is after every lecture out there for now  will probably do it right out side this room until it is too crowded find a conference room We are going to hold follow up or debugs your brain or debug your lecture exprience right out side that room for now  right after this lecture will mostly be Mattix doing that I will do the one after the next lecture that's gonna a little bit of flux say when you get out of class there will be resources available and those constitute our open office hours even if you don't come to class    who will do that you have access to us in that lobby kind of meat day on Monday Wedesdat Friday Ok go to section this week they talk about the they  specifically talk about the protocol  the infrastructure of this course and the way you check out do and checking for your homework assignment so so that session make the rest of the semester a lot smoother have another announcement  for which I do not yet have a room  but on Wednesday will have a room  if you are not comfortable using Linux or Unix system in general  then we have a tutorial  available to you from 8/27 or 8/28 you sure Monday...oh it's August Linux tutorials 7-9pm that's being run by the ACM we just don't have a room yet so far before we even announce  the Facebook event actually have 245 tanbes We are looking for a big room Alright oh look it looks red sorry When do that happen let's make it look blue Alright any question about announcements  we don't know what room it is yet We will be all announced it on Wendnesday We don't have a room yet, it might be here We don't know Alright so what's this course about I have some metaphors  for you there is the stadium that's our stadium raise your hand if you have not yet been to a ILLINI football game you have a another goal for you this semester because the pageant tree is kind of cool  Umm go to a ILLINI football game it's kind of fun it's like a phenomenon  I will be going on October thirteenth because I grew up in Nebraska go big red sorry alright so I count you to go because it is just fun Now here is my question what you have is this stedium and I wanna know Where is Tom Bogue what are your idea for finding Tom Bogue there is the stadium  is filled with tens of thousands of People How I am gonna find my friend Tom Bogue who is a course staff for since who wasn't here I am actually looking for him
Where's Tom? He's kind of unlikely to be in the stadium.  Darnit. Where's Tom Bogue? How are you going to find him in the stadium? How are you going to find him? You can raise your hand, and I'll talk to you. Yes, what's your idea to speak very loudly. Get on the loudspeaker. And ask him to meet you where you are right? Share your location with your iPhone right? Say come here right now. Okay, so get on the loudspeaker, so this is a technology that allows for simultaneous broadcast to everybody in the stadium.  Well guess what, what happens if the loudspeaker is broken? How are you going to find Tom Bogue? Can you yell loud enough from over there so I can hear you. Oh, call him or text him on his phone right? Yo Tom, meet me at the... Alright, so there's technology there that makes that possible, what's that? What is the detail that makes that possible? His cell number, that's right. So you have a unique identifier you can use to find him directly, not unlike a hash table I'd say. Alright, now guess what, Tom doesn't have a phone. How are you going to find Tom Bogue? Oh, so you're going to trust that Tom has not scalped for his ticket, and that the official ticket sales office, has connected Tom to a particular seat yes? Yes, that's one way of maybe doing it.  So there's some potential for fault in the system there. In an ideal world, that should work perfectly, good idea. Of course, you'd need to have access to that proprietary data, but you know, we're optimistic here. Okay, anything else? So we don't have access to the proprietary data, and Tom scalped his tickets. Yeah?  I could go look for him. That would be my favorite thing. Okay so let's pretend you guys are the stadium and I'm going to look for him. Are you Tom Bogue? No, oh okay. Are you Tom Bogue? Are you Tom Bogue? You guys should stop me. Are you Tom Bogue? Are you Tom Bogue? You guys should collectively stop this. Yeah, yeah okay. Why? Why? Why stop it? It's inefficient. That's right. You're sitting there going, She's an idiot." Right? That's dangerous to do, but okay. Yeah, because look, the amount of time it was going to take to go all the way through this room, and find out that Tom wasn't here, was proportional to the amount of time it took me to talk to each one of you. That's no good. Especially if we have a complete conversation right? So what else could we do in that scenario? Yeah? Yeah, yeah, yeah, that's like broadcasting right? Yeah? I could, oh, oh that's kind of cool, that broadens the bandwith of things. He said to ask individual people if they had seen him. So I could ask, that person right there if they'd seen him, and they would go, oh I didn't seem him.  I could ask that person over there, and so instead of talking to every last person, I could maybe talk to every ten perhaps? Okay, fine. Yeah? Okay, very good, okay. Look at this. So, are you Tom Bogue? Okay, so what I would really appreciate is if you would everybody around you if they are Tom Bogue, and repeat this process with them. Okay? Alright, so do you have a mental image of what would happen if we did that? What does it resemble? Don't tell me a tree, we're in a football stadium. It resembles.., you can get this, see this is why you guys need to go to a football game. It resembles a wave, that's right, we could do this.  That's right, okay. So that kind of connects the story back and forth. And it turns out, it's not quite right, but it's close, it turns out that effectively we could examine the whole room in approximately the amount of time it would take me to talk to just a few people. You can imagine it spreading diagonally here. Now, the actual way that it would spread, well that's what we're gonna talk about later in the semester. Actually quantifying the difference between the two algorithms or techniques for investigating the data, that's what this course is about. In fact, we're going to have arguments about which approach would be better. I might not trust that somebody else can ask the question. I might need to rely on this me asking every last person, that would be being a control freak. Alright, so in any case we're  going to have those arguments and discussions. That's what this course is about. Any questions about it? Or comments? Alright, beat that one to death. Here's yet another metaphor. Here's yet another metaphor for what this class is about. And yet another question that helps me get to know you. Raise your hand if your closet looks more like the upper left. 
Raise your hand if your closet looks more like the lower right. I assert that there's actually a lot of correlation between night owls and upper left. and morning person and lower right but we won't investigate that. That's a question for another time. Alright, let's do it again. Upper left? Lower right? Ok. Raise your hand if you didn't raise your hand in the last minute. Why? Why didn't your choose between them? It's about half and half. Ah, ok so there's a grey area between the two and that probably where most people are. How about it I asked you which one you'd like it to be? Not the left. Ok. Alright. Did that hurt? And you weren't ready for that at all. We didn't talk about that ahead of time. I don't even know your name. Alright. Ok so the metaphor here, in case you're missing it, is that not only can we be clever with the mechanism we use to search our data. We can be clever with the mechanism we use to arrange our data in the first place. Now the real question is if you're looking for your purple long sleeve button down. Would you rather look for it in this closet or in this closet? Yeah, obviously. Alright, all you do is go the the button downs and it's right there. Right? Where this one you do your back linear search. Alright so, our algorithms and our arrangement of data in memory are two things. And it's the whole course. Any questions or comments? Ok what's it like? Eh, you can read that later. It's a puzzle solving course. My goal every day is to have you go Oh, that's cool" once. Just once during the day. That's what I want from you. I want you to go Oh, cool!" just one time. And that's the thinking part of it. Where you're thinking broadenings. Has that happened yet today? Eh, ok. I don't want to know. Alright. Where did you come from? So I think that many of you can raise your hand if your introductory course, your prerequisite course is 125.  That corresponds a lot to the CS majors a probably minors. Raise your hand--ah this is so hard. I cannot remember what the prerequisite course is for ECE. Which one is it? Did that hurt? To talk to me? Ok. Alright. And what's your name? Matt, ok. Thank you. Alright. So it is 220. Good alright. That's the prerequisite course. Now the amazing thing is that you guys in 220. You people in 220 learn everything you need to know about C. And that means things like pointers and memory and being responsible with your memory. And if you came from CS 125 it means that you know everything that there is to know about objects. Well guess what, in this course we seek to unify. And so we're going to use C++. And the dated version for a very deliberate reason. We're gunna use C++ and the cool thing about it is that there is a little something in for everybody. C++ has pointers, that is we control our memory at a lower level. But it's also object oriented. 
Now, if you know everything there is to know about pointers, I'd still suggest that you use that as a springboard to learn, perhaps a little bit new, how C++ deals with memory a little differently, at least syntactically, from C. So you will still not want to disengage, you will still want to be disengaged with the idiosyncratic differences between C and C++.  And now, in the previous sentences replace pointers with objects and the same is true for those of you who came from 125.  Even if you already know about objects, you will find new idiosyncratic things in C++ that you should learn about. So, these two things even though parts of them are familiar, as a whole they will be slightly different.  My take will be, my emphasis will be to differentiate C++ from your previous experiences.  So I'm going to assume that you know for loops, variable assignment, function calling, I really am going to assume that you have had the introductory course, cruise right on past that basic stuff (conditionals, what) cruise right on past that basic stuff and into the ways that it differs, and the ways that it will serve us in learning about data structures.  Any questions?  Alright.  Let's work.  So, the first c++ - and I have 15 minutes - can we find - 13 minutes - we're going to get a ton of stuff done. Because you already know a lot of what I'm about to tell you.  You already know it.  You already know that when you declare and define a variable in your prerequisite language that it has the following characteristics.  You might not have thought about it explicitly before.  But I'm pretty sure it won't surprise you when I tell you every variable has a name, and a value, and in our languages of choice, it has a type, and they have memory locations.  That is the value of this variable is stored someplace.  Okay?  Any of that surprise you?  Alright.  So, uh, like these other languages C++ has some primitive types.  These are things that you can look up.  We make a declaration in c++- for completeness you can look them up.  We make a declaration in c++ in a way that won't surprise you.  If I want a boolean I'm gonna call it a bool.  Cat.  Like this.  Okay?  So I declare the variable - what's the variable name?  Cat.  What's it's type?  Boolean.  What's its value?  This is tricky.  What's its value?  Okay.  Anytime you ask what's its value and there isn't an automatic known everybody answers the same thing we're all sure we're all on the same page, then what you have to think is it is garbage.  It absolutely has no value.  Now, it's true, that some c++ compilers will stick in, you know, a default value for you.  But, we're never going to rely on that.  We're always going to assume it is garbage until we give it, until we explicitly give it the value that we want it to have. so, oftentimes, these primitive types will be accompanied by an assignment statement much like this.  So that statement is equivalent char rating; rating = 'E';.  We can do them both in one go.  Any question about it?  Okay, fine.
so bad it's, uhh. So bad... It's good. Okay, The key thing to notice there is sometimes if you don't include your decimal to reinforce the fact that you're not dealing with integers, the compiler will yell at you. So, you know, that is the shortcutting a ton of ridiculous debugging time right there.  All right, any questions about that? No. Here is what I think. I think you should be sleeping. Kuhh, we had known about variable declaration for at least a semester now.  So, here is where things get a little bit more interesting.  It turns out that the set of primitive types of things we can use to declare variables is not enough.  In many many almost all circumstances, in fact, we want to define our own types to use as the bases for declaring variables. Okay? In C that was structs; in JAVA it was classes and in C++ it is classes. Alright, so here's what we gonna talk about next. User defined types in C++, those are classes. Okay? And I will show you the syntax for defining a class in just a minute because I wanna start with how do you use a class once it is defined and available to you. Well, you use it. This is different. This is different than in JAVA. You use it just like you do a primitive type and, in fact, a software engineering principle says that when you write a class, you create a type that can be used just as if it is a primitive type. It is sort of one of the standards for completeness. Okay? Alright, so if it's just like a primtive type and if my class name is sphere, then I declare a variable of type sphere" using this statement. Any question about it?  So now I have a sphere.  We don't yet know what a sphere is. We gonna define the class later on. For now, I just want you to see how to declare one.  Okay, so, a class is a group of two things... It is a group of a variables and functions. Now, these two words, which I will refer to as variables and functions, in other languages may have different ways being refer to. So, we may have fields, here sometimes instead of variables. We might call them member variables and I will always do that actually, almost always do that if I rememering that they are called member variables. Uh,  and functions, functions are always refered to as... methods, very good. And for those of you who came from C, the classes is not very different from a struct except for this part. Okay? a class is not very different from a struct except for this part. Any questions? And I will show you how to use that part very soon. Not quite yet, I don't think One of the things that ran wrong this morning was that the printer was broken and so, I don't have my class notes. So we are a kind of winging it. you've probably noticed. Alright, so here we go. Let's define a class. Okay? Now, here is the skeleton, here is the skeleton. Uh, we simply define class sphere" [use] opening and close brackets to declare a block of code and what is different from what you've seen before is that we do have to include a semicolon in this case after the class definition. And the reason for that is because there is a field right there that we don't use. Okay? But it exists in the language definition and so we have to end that statement. There's like this ghost"  statement here. Okay? So, another common mistake to make is to forget that semicolon because it feels redundant. Feels like I put a closed bracket there and it must think I'm done with my class definition but you are not. Okay, so, well, uh, here we go.
The members are the collection of both variables and functions. And in the class definition itself, we declare our intent to define. Now, what that means is that we won't actually see any function definitions inside the class definition. So this is already different from Java, because in Java your class definitions are that long sometimes, right? In C++ not so much because we just make a list of the things we intend to define, rather than explicitly defining all of them. So now, in this class definition, we allow for our little control freakiness stuff to come out. There are two regions inside the class definitions that we use to control access to the members. And those regions are specified by a public keyword and a private keyword. Public keyword and a private keyword. And public is anything you want the user of the class to see. Now who's the user of the class, it's whoever did this, it's whoever made the declaration. Private, though, is what you want to control. Two purposes to private. One, you want to control access because you don't want a calling function, you want to control the calling function changes your data associated with the thing.  That's one reason. And two, actually, I can think of another reason, two, you don't want to expose to the calling function the way you have implemented something. And three, you want some special place that you can put your utility code that nobody can mess with, that nobody needs to see. So these are usually the following things: the data of associated with the class object, and those are the variables that I referred to on the other page. But also, functionality that only the class itself needs. And we won't worry about that for a while. Okay, so I made a big stink out of the fact that the class definition includes only declarations for all of the members. And then the question is, well where does the actual implementation go, where does the code go? And the answer is, in a separate file. We actually implement all the functions in a separate place. That allows us to kinda keep the value of our implementations, to not show the world how clever we are, because we're going to bank on it. We're going to make bank on it. So, often times, we would define a class like this. We will put the declarations in a file called sphere.h and we will refer to it as the header file. And we'll actually put the member function definitions in another file called sphere.cpp. And I'll show you later how to compile those together. Actually the lab might show you how to compile them together. Alright, next time we will start exactly right here. That is, wait, stop, freeze. Everybody freeze. Freeze. You're just not doing it, are you?  We're going to start with the design component of the class definition. We're going to start talking about: What is a sphere? What kinds of things should it be able to do? What data do we need to keep about it? At the very start of next time. Alright, bye.
hello there! hi hi hi
Hello? There we go. Ok I had to turn it on. So, RP is Reflections|Projections. It's like a conference where we have speakers come in and there's a job fair. And there's also something called Mechmania which is a coding competition from friday to sunday. And every year they make up an entirely new game that you kinda work your way through. Every year we have a Mockmania before the event where people try out the game and make sure there aren't any bugs Trying to get it ready for the actual thing. So if you're interested in being in Mockmania you should come and be a part of that. You can sign up at acm.uiuc.edu/mockmania And if you come there might be prizes if you find some really good bugs. And there might be food. There probably will be food. Yeah, Mechmania is the actual event and the Mockmania is just the trial. We'll probably have it in the next week or so. Ok. My turn. I didn't have bug free slides last time and probably the most critical piece of information I have for you is just plain flat out wrong. I believe with 99% certainty that that is actually the course website. So everything you need should be there. I am aware that the lecture slides are not yet uploaded, they will be. That's like highest on my priority list to do after I get back to my office. It's a process. If you have general questions, even if they are one-to-one questions between you and course staff, please post to Piazza with those questions. You can post privately. Right now all of our email boxes are way too full. And I think I have about a 50% hit rate on actually seeing all of the email that's coming to me. If you post to Piazza you have at least 40 sets of staff eyes on your message. I was asked a question right before class. Gosh I've already forgotten what it was. I suggested to be posted to Piazza so this is the perfect example. Does anybody have any questions? What is your question? If we're currently taking CS 173 will we get the math from that in time for use in this course? Ok, so I think that the consern came out of Homework zero. And sort of assess how much time we should spend on Homework zero. We've pretty much settled into the fact that 173 teaches you stuff in time for you to use it in this class.  There's like one day where it's kinda switched. One day when we're talking about induction it's kinda switched. But in the end it ends up being ok. So taking CS173 concurrently with this class is not bad. Now how much time should you spend on Homework zero if you're concurrently taking 173? I think Homework zero, at least parts of it, are kind of fun. And so use Google. Try to do it. Don't spend all week on it. If you kind of give your best effort and it doesn't flow but you are currently enrolled in 173 then you're ok. If you give your best effort and it doesn't flow, and you are not in 173 then you may consider adjusting your schedule for this semester. Does that make sense? Does that cover all the issues? Yes ok. Alright so more details for that discussion could happen on Piazza. I think lots of people are interested in that issue.
Due date ... right there and proficiency  exam sign up instructions so if you have had a data structures class and you did well in it and you don't want to be in this room, you're welcome to take the proficiency exam, and I'll tell you that the pass rate is pretty low Umm... and that uh, in fact very few people even take the CS225 proficiency exam. Some people take it and still enroll. Some people pass it and still enroll in the class, so I don't know what the deal is. The information for signing up if you think you'd like to take is that I certainly don't intend to discourage anyone from taking it. You are all welcome to take the exam. Alright. Any other questions, any questions about the announcements? Okay, so I left you hanging in the middle of last lecture; completely hanging.  In fact, we had started to define our first class.  In our first class We were defining class sphere. The reason why we wanted to define a new class is because we wanted to declare things of type sphere, and low and behold, sphere is not a primitive type in C++. So my objective and my goal is, mmm, I'm not going to be fluent with this tablet yet, and I apologize, but I'm working on it. My goal is to be able to make a declaration of type sphere of a variable whos variable whose name is beach ball. For example, okay? Now the question is how do we make that happen? The answer is to define a class whose name is sphere. The details of defining a class are like this You understand that there is this public access system, but you don't necessarily know what that means And a private area in the class definition You don't know yet what that implies, and that's okay. Then you go to the drawing board and you think, okay, what kind of functionality do you want from a sphere and how do you represent a sphere. That is, what data do we need to umm keep about a sphere. So when we talk about the representation. What we're really talking about is what data will characterize anything of class sphere. So ... raise your hand if you have an idea of data that will characterize a sphere. Yeah? Whether it is round or not. Guess what? We're going to implement it so that it is round Okay? Sphere will be round Okay? That is just... we'll make that happen Yes, so if I tell you something is a sphere and I give you its radius You know what that sphere is, right? There is only one sphere that has that radius... well, sorta We're going to use ... uhhh ... radius ... oh wait Could I use diameter instead? Yes, could I use surface area instead? That would be crazy, but yeah, because you'd have to take square root. How about volume? Could I use volume instead of radius to characterize my sphere? Is there only one sphere with volume ... whatever? Now, again, we are in a design discussion. Why wouldn't I use those? Why wouldn't I use those other things? Yeah? Yeah, they induce time to evaluate, right? Like if the only thing I care about about a sphere is its volume, then I might use its volume But probably, for a general purpose sphere, I can most quickly get to what I want by keeping its radius, and doing simple arithmetic Simple arithmetic in every direction to get the data, or the information that I want from it. So I'm not going to keep... you're going to have to forgive all the slide switching. That is my fist on the ... thing. I'm going to keep the radius. Okay? That's going to be my representative.  Now, the reason why we keep the radius instead of the volume, say, is taking cube roots is expensive computationally. Okay? So that's the piece of it...that is... that's the piece of it that's hard. That's why we decide on radius Whereas cubing something ... not expensive at all. Who knew? You thought they were uhhh you thought they were inverses of each other. You didn't care. We care. Okay, so now we know how to represent this beach ball. We're just going to keep its radius. Do we need any other kind of representation?  Yes? Yeah, its location You are absolutely right. We would probably want to keep where this sphere is to but the real truth is what we're designing is a stupid sphere. We're only going to represent it via its radius. We're not going to try to keep track of where it is, but we could. We're just gonna keep things extremely simple So what I'm going to say here is plus more... probably.
So, alright. We are going to keep sphere and denote it by its radius. What do we want to do with the spheres? So, once I have beach ball here, what do I need to be able to do with it? yeah? I might want to get the diameter from it. That's right. I might want to get information about it. I might want to get information about sphere. Anything else? I might want to do? yeah? I might want to change it. That's right. I might want to change information about it. I might want to change the radius. ugh, change it. OK? And, the last one is kinda implicit, and I already done it. We might want to create a new one. If you are coming from Java, this basically constitutes a collection of geters and seters right? We need to get information and change information. In C++, we do that ourselves explicitly. We don't just get ask for them. So, we are going to write the code to do it. Now, before we write the code to actually implement it, these things, we declare them. Now, here is the story, for the representation in practice, we are always going to put the declaration of the member variable, that's what those are, in the private section, cause we want to controll the access. Talk about that more in a second. So, in the private section of our class defination, I am going to write double theRadius. And now, I am going to use my functionality list, as essentially a checklist for the declarations of the functions I am going to implement. To declare the class defination. So, one two and three there are my checklist, and I am going to go through there, and start to declaring functions, achieve that functionality. OK? alright. So, the first thing I want to do is get information. If I am getting information from the thing, then I better have a return type. Better have a way to accepting the information. Ugh, what I am going to do is, oh, sorry, erasing, hmm. oh, no.. What I am going to do is, to have a function, with return type is double, whose name is get, probably one of these for radius,  diameter, volume and surface area. But the one I am going to use for an example is get diameter. There are no parameters to that function, and the declaration, ends with semicolon. And I will show you how to use that function that has no parameters in just a sec. Now, we are done with get information. Now, what does it look like when we want to chage one of these things? Well, we don't expect a return type, we might have a boolean in there to see weather we have been successful. The name of it might be setRadius(), and this time, we do want a parameter. We are going to pass setRadius, a double, whose name is newRadius. Hey, again, it is a declaration, and it ends with a semicolon. It is just a statement of my intend to imple ment.  A statement of intend to implement. Ok, and now finally, we are going to talk later in the day, about creating new objects.  I am going to show the declaration of the functions will be deployed, so as to create objects, you are going to tell me what's weird about them. One of them that I am going to use, is simply this. and another one I am going to use to create new objects  is simply this
I don't know what i called it I don't know what letter that is. I think it's supposed to be a T bubububububu trahhh there Okay what surprises you about the function declaration right now already two thing i should think should surprise you yes? It's this same they have the same name they are not the same function and i can tell because they have the different parameter list so you should yes if two funcitons have the same name but different parameter list, they are different functions. It's almost like you should look at that function sign and use it as part of the characterization of a function so good point same same different parameterization anything else surprise you by those two function declaration? yes? no return type that's right and the reason for that is because these are functions called contructors that the system deploys for you. you dont deploy them so you do not expect the return type. you are not writing code that's going to handle the return type so no function no return type in these function declarations theres one more thing that's a little bit weird about this. Yes? Exactly, it has exactly the same name as the class right? here's the same and there's the same and moreover woah yeah right there woah woah woah hmmm no... this is new haha he no problem moreover right here ohhh when we use the class when we use the class there is the same name again so this is all consisted with our idea of user defined type  okay any question about this? alright so now at this point at this point we have we have shown what a sphere implementation is going to look like we have not yet made it happen right? there is no assignment statement that actually changes he radius here so this can not be it and it isn't it But, i wanna point out that right now  if this is all we know about a sphere in fact it is. In fact all we know that we can already do stuff to sphere right? I can take my bball my beachball and I can do this so for those of you who have not worked with ooj language before this will feel new i'm going to invoke my member function on my object of type sphere simply by using a dot and a function name let's see I'm going to set radius  to whatever you like how big are beachballs they are like 11 inches in diameters something like 11inches in radius that would be nice sized one right? I would be a such a better teacher if right now if at this moment a beachball started its rounds in the room shoot you know if the big darn it next semester will be better I tell you maybe next hour where's madix I was you walking where is matt is there beach ball? oh you have a beach ball in your office? shoooot remind me  what ahhahahahaha that would have to change up everything okay sorry for the distraction
has shown us, that we have a function called setRadius that takes a parameter that's a double. Okay? Any question about that? And now I can do things like, I can do things like cout". cout<<bball.getDiameter()" No parameters. And I'm gonna send an endl". Now, new stuff! This is new!;)  Right here. This is like in C, printout. This is C++'s mechanism for allowing you to send output to standard out or send data to standard out. Okay?  And, there are some other little things you have to do. You have to tell. You have to state your intention to do so in your code, but we'll talk about that in more data later. So, you're gonna see this. All it means is hey print this stuff for me". So what would happen if I invoke this command, compile the code and ran it? What would the results be here? This would result in --- twenty - two, gotcha! Yes you would get 22. Okay? If we implemented this. Okay! Now the kicker is here is what I can't do. Hold on just a second I wanna answer your question, but I wanna see if I can answer it without via esp okay?  Alright. Here's what I wanna know if I can do. Can I do this? Can I do that? Wow, really? Okay. So speculate to yourself a little bit. No, I can't do it.  Why?  Yes! This is what private means. Anything in this private sections is not accessible via the object itself. So this thing is not allowed. Because the radius is private Alright I have a little piece of vocabulary to give you and that is the following. This code in the blue box is called client code. Anything that uses a class definition is referred to as a client. It doesn't mean that you could expect payment or anything. It just means, users". So this is sphere class client code. And so now I can say the sentence: private members are inaccessible to client code. Private members are inaccessible to client code. Clients cannot use anything declared in the private session. Similarly the reason I can use these two is because they're public. We've laid them out there, right? Like this is permission. This is not friends, or family, or U of I. This is everybody. Everybody can use this. Okay. Use these functions. Any questions about this? Yes? Yes, exactly. We're gonna talk about that in just a second. So his question was can we access the radius via functions?". Of course we can cause we have a function that allows us. setRadius", right? So we have to go through setRadius to change the radius. Alright. Yes You don't need a constructor to create the object. The system will provide one for you, but it's a really really stupid one. So you probably want to create your own. Okay? Alright. Anything else? Okay. Here we go. Alright. So I've sort of replicated what I did before, because I was lying to you of course. The code on the previous page actually won't do anything because we have not created the implementation of each of those member functions So that's what we're gonna do on this page. And so I replicated the code from the previous page here so I can talk about how we actually make those functions work.  But, even at this point, something should surprise you. So when you look at what I've replicated here, two things should surprise you about this code. What are they? What do you see here that shocks you? Shocks I mean. Yes?
Okay, so the comment is, I believe, you'll have to correct me if I am wrong, that that name matches this name. And that is absolutely germane. It's probably the most important point because what I am really doing here is creating the code that will make that declaration on the left work. Okay, it's creating the code that will say what happens when that function is invoked. Okay fine, I am not too surprised about that. Anything else here? Yes, okay look at, this wasn't here. You can look back - I didn't do that when I declared this here. So that's different, I'm gonna talk about it in a minute. Okay, what else looks weird here? What else looks unfamiliar? What the heck is the double colon about? Okay, that's called a scope resolution operator. And here's what that says. That says that this setRadius is the setRadius declared in the sphere class. It's not the one declared in the circle class. It's not the one declared in the arm class. You get it? Doesn't your arm have a radius? Yes, okay. Like if you have a broken arm, you set the radius, right? Fine. Tough crowd. Okay fine, so this setRadius is the one associated with the sphere class. So if you saw something here that was attached via the scope resolution operator to another class, it's not the one you are interested in. Okay. I am not going to talk about const yet, I'll talk about it in a minute. Suffice to say that the scope resolution operator attaches, or associates, a function to a class. Alright, so let's set the radius. What code do you think we would have to do if somebody tells you here's a new radius". How would I set the radius to be that value? That's it, that's the code! It can be, it can be. It can be but they are not inside the same code block. By convention, not because we have to, but by convention, we stick these implementations into a different file. Remind me to talk about that again before I advance the slide. Alright. Yes? Yeah, I might want to because what this allows right now is I can say bball.setRadius(-4.7). Right? And so this is our chance, our opportunity to do some error handling here. So maybe I might want to say If newRad is greater than zero do this, otherwise theRadius - what should be a default radius? Yeah? Yeah maybe one Or just leave it. Don't make a change, but then you'd want to tell somebody you are doing that. In any case, this is not exactly how you handle errors. Alright, so I want to make a comment here. In this class, we are not going to talk a lot about exception handling. Okay? We have too much to do, and so, we are not a software engineering class, so. C++ has mechanisms for exception handling. You can Google them.  You'll be better at Googling them after you go through these first four weeks of the course. So, wait, let us handle exceptions in kind of a novice way for now and if you have questions about it later, we can discuss it. Okay
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
I can't hear, you have to yell. Oh yeah, look at this, look at this. I just said 5 minutes ago, don't touch that, you cannot change the radius.  And yeah, here we are doing it, here is gonna allows it.  The fact that this says here allows me access This is a sphere class member function I have access and I need access to these private members OK? That's what we were doing here Yes? No, you cannot do this in a client code You don't want to do this in the client code This is all part of the sphere class definition OK, let's do getDiameter() I am gonna do this one for you because there is absolutely nothing about this code that will surprise you You can raise me if you want return 2 times the radius OK? Alright, Any question about that implementation? Yes? Yea, you don't in C++ yeah You never have to be object itself if you are coming from java  The object there talking about is implicit. There is a this if it's a pointer to the current object But we are not talking about pointers yet OK, one last thing What the heck is that const OK, so, noticed that, getDiameter() has no reason at all to change the radius Putting a const in that place is a promise that it will not change that radius So const placed at the end of the function signature is a promise that the private members will not be changed by the function And the reason that's good is now I can hand you the getDiameter() signature and I can ask you to implement.  And if you try to be in the furious. I am gonna change her radius to 52 every time. You can't. The complier will not allowed you to do that So it promises if I am asking for information nothing will be changed about the value of the object Alright, any questions about it, good? Did we cover everything there? Why do I wanna make , excuse me? OK, so the question is why would you wanna do that The short answer is you want to ask the compiler to help you to control access every time you can't.  Because the compiler put the code together before the client every uses it before every excecuted Before your code is ever executed. So every time you can bring control at compile time you want to do this Now, you do not want get diameter to change the diameter, that would be a bug. So we are trying to increase our integrity of our code enforced by the compiler, just to make it easier to maintain. To eliminate the potential bugs. 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
What would you like to have happen when we declare a sphere? Yeah? I dont have to. So the suggestion was a great one This is a moment where I get ot go oh, we love C++ He said you have to allocate memory and I'm gonna go, its youre lucky day! Was that you? That said that? Its your lucky day! You do not have to explicitly allocate youre own memory. You can just declare one ok. Its fine, its there for you on the stack. Yes? Yes! It should have a default radius. Thats right Lets set up the default radius I'm giong to assert that a good one is the unit radius. Ok? Is that alright with you? Ok Alright, fine. Uhh, there is alternative syntax for this in C++ and the reason I'm telling you this is becuse you will see it. People use it. It isn't quite as clear, its's a little bit weird becuase it really teaches you something new about the language. Alright, here is an alternative syntax for declaring a default sphere. or a no argument sphere. I'm either gonna do the first one or this one. I'm going to use what's called the initialization line to declare  the value of my member variable And thenm this is  an empty code block. Nothing to see here. Move one. It does not have semicolon Its not a class definition. It as a implementation and thats the code block. The only place you have to have the semicolon is here or at the end of a line. That's a good point. Yeah? Yesh, no. Its like a parameter. Ok? So this is correct syntax What is there to observe about this syatax. There is a colon. It's the name of the private member as if it is a function. as if it is a function kind of and then you sort of pass the value that you want to that variable. OK? There is a really good question. Yes. There you go, that's it. That's exactly what I wanted you to ask. Ok. Have I been doing this class a long time or what? What if you have more than one member variable that you want yo initialize. And the answer is the folliwong. if this thing also has a color associated with it, you delimit them by a comma. which is also unusual in our context I dont know what r is Oh, and there is no semicolon. dont let me put a semicolon there, there is nothing there Ok. So I show you this contruct. For two reasons One is because you will see other people use it and two is because when we talk about inheritance in C++ this actiually becomes important there are cases where we explicity call member functions of super classes. Alright, any qustions about this? Yes?
Are we or could we explicitly call? Okay so any time anybody ever asks a question in c++ that starts with 'can we', the answer if it fits the specification of the language is yes. But the more important question is because you can do crazy things with c++, you can hack to your heart's content. But the more appropriate question is should we? And so I'm gonna rephrase your question as 'should we explicitly call the constructor' and my answer is in most cases no. We should not explicitly call the constructor we have define it for the system to use we're going to let it use it, okay?  Yes Okay so I'm gonna get there for just a second.  So that him asking that question is really saying alright move on and I will do so. So let's move on. Because we have this other constructor and I've just been kind of obfuscating it right, moving past it. Here's what it allows you to do. And you can tell me at the end if I don't really answer your question, okay? Umm here is what it allows you to do. It allows you to declare a I don't know what aball is, apple ball? I don't know how big are they, 4.7 something? It allows you to upon declaration give a value to the radius and the only reason that this constructor exist is because we declared it because we said it should. Now what does the code look like here? It looks like theRadius equals r. And we could say if r is grater than 0 do that, else theRadius equals 1.0, say. Okay? Alright any questions about that? Yes Very good question. The question is can we use the initializer list for this constructor the answer is yes and that syntax looks exactly looks like you would expect. That syntax, I'm gonna put it in a different color ink because it's alternative code, OHHHH, would look like theRadius and have an r in it. Okay you can refer to the parameters in that initialization list. Why wouldn't you wanna do that? You cant error correct it. That's right. You still have a question? Yeah okay. Errrrrr I don't know the answer to that. I think not. I haven't see it. Is it time to go is that why you're restless. It's not I have two minutes left! Okay so here's what I'm gonna say in those last two minutes. If you don't declare any of these, declare or define any of these constructors, the system will give you one. Okay? So that is point one about constructors. If you do not provide a constructor, the system will give you a no argument constructor so you can't do this little trick of instantiating the variable without defining yourself. A no arg, okay? Now if you give one, if you give one constructor, the system will give you none. So if we just defined that constructor then and not any other ones we would not be allowed to that declaration, okay? So ahhhhhhhh, if you define any constructor, the system gives none. Okay? And then the last important about constructor I've already made and that is to reinforce the idea that the constructor is a function that you write for the system to use. And you should think very carefully about why you're explicitly invoking it if you are ever tempted to do so. So the ctor is written for the system to use upon declaration. You should not call it.  It is not called by client code. Okay that's it how far did I get in the slides? Look at that. Oh um.  Okay and that's it how far do I get in the slide. Oh look at that. Whooo, er. [interesting noises]
Let's work. Let's work. Now you can hear me. Let's work. Did you groan when I said let's work? Ah, all right, my watch says 11 o'clock.Ok, so ah, let us see, so ,good friendships are built on shared experiences, yes? Good friendship on build on shared experiences, so, I wanted to step out this slides a little bit and create a shared experience for all of us. Now, i m a little nervous about it because i m the person with microphone. Um and so, and so um, i want, you guys are welcome to bring your own microphones if you like. Then we can , wait. That 's a distraction we do. HI,  i m sorry. Ok ,so i am yes im controlling the keyboard and yes i have the microphone clearly not controlling this screen at this point, Um but, i WOULD like input from you on how this go. Now, this experience is simply called review of what we've known so far, ok? the review of what we've known so far, Cauchy title huh? It's gonna be a 89 of rotten tomatoes, all right, so, here I am, here I am at my command prompt,  on my macbook, ok? So. I 've done nothing especially in stole your (simmity)? or while ago.  It s not even really my macbook. im kind of borrowing it from somebody else.And moreover it is like 3 years and a half years old.  So, there is really nothing special about the particular setup this going on here i dont even think i ve been installed the developer tools, now. The situation that we are in right now in this terminal winde could be replicated easily on any engineering work station machine. Either by ssh, that is  remote access to those machines or by sitting in the lab directly. Now the reason im not doing that is i actually prefer not be dependent on the network ,on the wireless network. And so , i'm doing it just locally on my machine so as to diminish the probability that something goes horribly wrong. Ok, so, uh i  am in my uh, fall 15 working directory i found that out and typing present working direcoty and im gonna list this contents of this, all right, the file that were going to be working on is demo.cpp would you like to see it ? are you dying to know what's in demo.cpp. All right, there it is, ohhhhhh. It is intended i have said it is going to be c++ files by it's extension. Ok, and clang likes that it didn't like it when i had txt. Uh, all right, so fine, im going to try i've said this is in c++ file , let's see if clang likes it. ok,um, to escape from this is the unique thing that will be convinient. To excape from the current processes into the calling process. I did control+z and i'm going to bring it back that one that editing back to the four ground with fg, for four ground. So, ill be swapping back and forth with key strokes that my fingers learn decades ago. So, if it looks a little, um im not fast. OK? so , if it looks like, what the hack did she do there? Number 1, feel free to ask. Number 2, assume that it is  something simple All right, now ,  i have demo.cpp. It's being edited in the background but i've saved it, it has no content. And im going to ask our c++ compiler to make it into executable code for us. OK? we are gonna ask the c++ compiler to compile it. Oh, oh, doesn't like it .
Hmmm. What do you think it doesn't like? What doesn't it like? Yeah? [student answers] Yeah, it doesn't have anything to do with the architecture it turns out. It turns out it doesn't have anything to do with the architecture, even though the error message says all of this stuff that I don't even know about my own machine. Ok What doesn't it like, yeah? That I have no curly braces at all and in fact, it doesn't like that I have no main function. So the C++ compiler wants something to compile and the thing it wants to compile is a function whose name is main. Ok, so let's fix that. I'm gonna type 'fg' here. It brings my previous process into the foreground again. And I'm going to go ahead and define a function whose name is main. Ok. And that's it. Now, uhh, is it gonna be happy? Well, cross your fingers, so clang requires an incantation before you invoke it. You have to cross your fingers, nod your head three times, and [gasp] yay, nothing yelled at us. Ok, alright, now how do we execute things? So clang took that C++ file, hold on, just, it was a rhetorical question that time. Usually I want an answer, but is it a question? Alright, hold on just a sec So the question I'm answering is... how... what has... what just happened there? clang took this C++ code, compiled it into, uhh, an exectuable, something that we could execute and, by default, it put it into a file called Now, the reason we saw that previously was because I had already been playing inside this umm inside this directory, otherwise that a.out would not have been there prior to this compilation. So, a.out was just created, or in this case updated, for us by the compiler. Any question about that? And then I'm promising you that it is an executable. Now, if it's an executable,  I should be able to execute it, right? [typing as well] a.out Hmm, darn it. Ok, everybody trips on this. Here's the thing. The system needs to know explicitly which a.out you're talking about. In fact, it didn't even bother to look in the current subdirectory because I haven't set... I have the paths setup to look in a whole bunch of other places. Ok, so, umm, and there are lots of a.out's so I have to tell the system which, explictly, which a.out to execute. Which one is the one in the current working directory? Ok, so this dot is shorthand.  It's merely a string substitution for, for the [current directory] Yay, I didn't have to type all that, I can just use dots. Ok, './a.out' specifies do this one. Oh. You know, it's always good when something doesn't yell at you, but nothing happened. Are you surprised by that? No, there's nothing surprising by that, right? Our main is empty.  There's no... we didn't instrument any kind of status update or anything like that. So ok, so let's go make this more interesting. Let's put something into main. Uhh, I'm going to assume that you can kind of get caught up and play around with primitive types, so what I'm going to do is try to declare... is to declare an apple. Ok, you like it? No. Will the compiler like it? Do you want proof of... raise your hand if you want proof that the compiler will not like this? Alright, fine. Control-z uhhhhhhh where's my clang. Uh-oh, it says exactly what you would expect. And clang is a little kinder than g++ was  and so it tells us 'unknown type name'. Alright, fine, we'll go fix it. It's called programming by trial and error. So that it's no longer true that it has no content. I'm gonna keep my, uh, 
Okay, now will the compiler like it? Will the compiler like it? Raise your hand if you think yes. Raise your hand if you think no Okay somebody who says no tell me why Why won't the compiler like it? A semicolon ( ; ) that's right! Very good. Hopefully I left the cursor in the right spot. You will get caught by that bug! Somebody will get caught by that bug and post to Piazza. Okay? It's not unusual. So I'm going to save it, and then go compile it. Bang C. Bang C here just says, take my history, look at my history of commands and do the last one that's started with a C." Okay - Do the last one that started with a C." And so, That invokes clang++ demo.cpp Okay? Compiler liked it. There were no errors. *Gasp* We can declare a sphere that is vacuous. It has no data associated with it. It has no functions associated with it. It was perfectly fine. Okay? Any question about it? At all? Uhh what happens when we go... that! Nothing! All we did was declare something we don't expect to be able to see. Now, it is true that things did happen in memory and that's going to be the substance of the lecture slides today, but for now we're still in the experiential mode. Okay so now, let's go make a sphere class that does some things All right, I didn't think about this part too much But I do want to go ahead and uhh... umm. Tell me the name of that function? Constructor, that's right. You look at it and you go, It's a sphere, duh." But this one has a special, more general name called a constructor and I can tell that it is so because it has the same name as the class name. Um the only other function that I'm going to take the time to instantiate or declare here is... uhh getDiameter. And it will return a double, it needs nothing and if you recall, we specifiied that it had to have a const. And then we uhh represented our sphere using theRadius. All right so I think that this should be okay, umm... So let's compile... okay? You ready to compile? All right. Uh, first before we compile... maybe I'll do this first. What happens when you have no constructor? Well, yeah we'll leave it like that for now. UUuumm... C okay? Syntactically, we're in good shape. Am I surprised by that? Are you surprised by that? Why are you surprised? How about this? How about this? Umm what if I now say, umm double b = apple.getDiameter(); I was a little surprised by that, could you tell? I had to do a little debugging here Now, now I'm in danger zone kay? This is a true shared experience um because friendships are especially good when you have shared experiences, which are kind of tense And you have to like, you know, deal with a, deal with an unknown and uh that's this moment soo Raise your hand if you think the compiler's going to yell at me. Okay, raise your hand if you don't think the compiler will yell at me because after all  I haven't really changed things very much Okay, I'm not sure. Um, I hope it yells at me. Okay? uhhh... Ohh Yeess look, yay okay! Do you see what happened here? The compiler said, hey you tried to use getDiameter, you tried to use getDiameter and there is no getDiameter! It made for me no getDiameter so the lesson here is that you can declare a function without implementing it as long as, somebody volunteer to finish that sentence... As long as?  Yes? Right Right you don't use it. Pretty much period. pretty much you never call it The way to finish that sentence in a meaningful way is  in client code " because that's another little piece of vocabulary. The code that uses this object is client code. For the moment, the only client that we have here is main, okay. Any questions about that? Are you good? It's Okay? All right Uhh let's go So that says boy we better implement getDiameter Let's do that very quickly Uhh I need to connect getDiameter to the sphere class. It needs to be specified as const and I've already forgotten my return type there. Okay... *typing return 2.0 * theRadius; under getDiameter*
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
And then I'm gonna do this thing too. And I'll explain it a little bit more because I want to look at what happens. Okay, any questions about any of this code? Oh probably. Where? Oh, in my implementation. You're my compiler, yay! Thank you. What's your real name? I don't think you go by clang, right? It would be a good name though right? Well, who are you? Kevin, nice to meet you. Okay, alright. Yeah, so make a correction you run the risk of like public. And now we're friends because we have a shared experience. Okay, alright. Any question about any of this code? Yes. [no audio] Isn't that the question on the board? Let's go back to our discussion on constructors. Let's sort of think ahead in time here. Go back to our discussion on constructors. If we don't give a constructor, the system provides us one. But, we didn't control how the object was constructed. I actually don't know standing here what clang will do. It's a compiler specific thing. I think its virtual c++ does always really nice things which means that people who program that in their first language tend not to program very defensively. It's like training wheels for your life, right? So, not to disparage it but it's nice to have a controlled environment And so, I'm sitting here. I haven't messed with this particular compiler. I don't know which version of clang it is. And so, I'm gonna go check just with you to see what clang does upon that initialization that I have had no control overflow Let's go see. !c Okay, it liked it. We had no syntax errors. No type errors. a.out Oh, and it gave us zero so it happened to have initialized that particular double to be zero. I don't know what would happen if we try to do math on it. Alright, but I don't want zero to be the default value. So, any question about that? So clang kind of played nice there but you cannot count on it doing so. Yes? Yes, it's supposed to be. It's supposed to be. So the virtual machines we give you for this class that is part of the download for the laptop lab should contain the same environment that the engineering workstation machines use so clang should be there. I don't think we upgraded to 3.6 so I think it's 3.5 but maybe 4. I don't remember.  For which? For main? So here's what happens. So if you don't specify a return value, one is inferred unless you try to use it. For example, if I didn't try to assign from getDiameter, I think this is true, it wouldn't have mattered if I put it there. In any case, those kinds of errors are compiler errors so the compiler will say, Yo, you forgot your return type and I needed it". So that's an easy one. I fixed all my bugs now, right? So, that's a case where and I don't necessarily know, I count on the compiler to tell me what it needs. Okay, let's see. So, let's implement a constructor. Where can I define the constructor? Where can I implement the constructor? Where can I implement it? Could I implement it down here? Let's try it.
connecting it to the sphere class. and I am going to set the radius  equal to 1.0 and thats it right? and I better get rid of my comment because I have declared my intent to define inside the class definition Alright, let's do this! Liked it! [pause] and it worked! [pause] Ok How about Alright, so any question about that? So, anytime the declaration has been made the definition can occur. Ok. Actually its much more about also where you call it. So the here,let me get it back. [pause] Ok. So...this happened after that was processed. So when the main is executed it goes an looks for type definition sphere. [pause] [pause] It has it and so its says ok I got a sphere class and then all those things are declared It wont reach out to get them until it needs them but, that this interface up here is a promise that these things will be implemented somewhere. and that somewhere can pretty much be anywhere! Ok so also long as the declaration exists. When. Im sorry. As long as the class definition exists, when the declaration is made Then the implementation can be in lots of different places. But you know what, I do not like it down there. Thats not what readers of my code expect. So, I am going to put it back up here. In a more reasonable place.  Ok. Alright any questions about all that so far. Yes. [pause] It, no bang bang is the pervious line that I wrote, bang c does the previous one that starts with a C. Ok yes anything else? yes! [pause] demo.cpp .. O I will show you. So you know what demo.cpp looks like right? So the compiler is a piece of software that takes this as input and produces... this as output Um..cat a.out. Are you ready? [screaming] [pause] [confused and angry at code] So this is the interpretation of the context of that code. content of the code in a way that it can be shown to the screen Ok. That code is executable code which means that which means that my operating system knows how to deal with it. Ok the operating system knows how to deal with it. My eyes and my head and pretty much nothing about me knows how to deal with it in this form. But my operating system does, and it likes it! Ok, does that make sense? So the complier is the software that converts from my language that I like which is C++ into a language that my operating system can understand. Clear Does it make sense Ok [pause] Could I name?O yes i can. is it dash O. To name is something else? Is it dash O to name it something else? OK! Alright, you do not like the a.out. O fine. So I can do this so pound C, replicates my previous command that started with a C and then I can add dash out demo. just demo. I will just leave it demo uh oh! O clear O. O. duh bang C
yeah. I'm doing this for no real reason. I shouldn't but I am doing it just to show off. that's working out real well you know what? so this is a teachable moment. so showing off, showing off almost always ends that way. and I'm gonna go ahead and make a general statement that as I was, I was kind of embarrassed by showing off, right, I did something wrong arose out of my showing off. so as computer scientists, I think we kind of like to show off. we can work magic the lot of the rest of the world can't work, right? The problem is, that when we kind of show off among each other, we put up barriers to participation, and barriers to participation creates barriers to progress. Now, the reason that that's so important is that progress is our currency. Right? We are the technologists, we are the people that are pushing forward on what the world looks like, and the instruments that are available to the world. So, this is an issue of equity. What I'm talking about here is I'm jumping on the opportunity to talk about issues of equity. if we're showing off, which sort of implies that we are not listening to people who might go Wait, wait, wait, wait, wait!" then we're cutting off voices that might have a lot to contribute. So, that's just my exhortation to everybody in the room. That we do not show off, and that we be careful to listen and include everybody in our community. I really like our community, they have a cool community. Okay, so I was showing off, and it didn't work a little teeny tiny thing, my ego is not hurt by the fact it didn't work. But now we have something working. So this mean ban cla, the last time I started a command was cla, append -o demo, so this is just string substitution when I can't return right here, this command is what was instantiated and the compiler like it. There were no complaints between here and here and now, these are the files that exist in my current working directory. Any question about that? Alright, and now I should be able to go demo and why it doesn't know which demo I might be talking about, so I tell it. Alright, are you learning anything? My apologies if followup this is... you know. One more thing, I have been talking, when I look here, when I look at the list here, I've got everything in one big .cpp file Now suppose that my neighbor wants to implement something that uses a Sphere. I can go, Oh Virginia! I have a Sphere that I can give to you!", but right now, my sphere is wrapped up in that cpp code. It would be much more convenient if I can hand to her just the Sphere class. That we're creating this object and they might be useful for other code clients. So we want to de-couple the class from the client code. So let's see, my apologies, there may be faster way of doing this. But what I'm going to do is, copy demo.cpp into what I'm going to call sphere.h for now. And then, I'm going to vi demo.cpp And get rid of the sphere class definition and implementation here, and instead, I'm going to tell the system that I need it.
OK, so, effectively what happens very early in the process in that compilation process is that, the compiler sees that this pound include and it goes: OK, you want me to include in this file sphere.h, I will do that for you. OK, now, what should sphere.h looks like, oh let's go look. Uhh, vi sphere.h. And it should contain only the class definition. And in this case we are gonna leave the implementation in there for just a minute. OK? You good? Alright, so now, I can still just compile this thing...I think... Yeah? The part of the compiler that's saw the code saw exactly the same code that I saw before. OK? The pre-processer took the file and put it in here. Alright, and yet I had decouple the two. Any question about it? Yeah? Uh-huh? (Student asking question). So, things are not happening top-to-bottom , exactly, they are happening inside out from main. OK? So, Um... when sphere is seen, when the sphere is seen as a type, the system goes and check: OK, do I have a class definition.". And the class definition is Uh... is only complete. You can only use the thing in the class definition when all of the Uh...when all the implementation are seen, but they are all written into the memory at the same time. So it's already there even if we happen to put it beneath in a linear order. Does that make sense? Does that...so the file is written at the same time. OK? It's just, and there is no linear dependency top-to-bottom. It's when sphere type is used, the class definition that will be there. OK? And it's when getdiameter(), for example, is used, the getdiameter() implementation that will be there. OK? Same for the constructor, just the system always provides you a constructor if it doesn't yet see it. OK? Alright, yes? (Student asking question). Yeah, but don't. I did that just to make the point. It works if you do that but you can't do what I just did here. Right? I separate it out, the class from the client. So then...yeah. Yes, right. OK, oh the class decoration. Yes, that's right. Yeah, you're right. OK, Uh, let's see, Umm...where are we here? Oh, we are not quite done. Oh my gosh! I have some new staff for you. Umm, but we are not quite done, because, sphere.h is intended to be, it's intended to be just a communicate, effectively communication device. It's intended to be just a picture of what the class looks like, not an exposing of the implementation details. So I'm gonna do the same thing again, I'm going to copy, Umm...sphere.h into sphere.cpp. Think this will work, and I'm going to edit sphere.h, oh, abort for ground, OK. Get rid of the implementations. There are couple of different things I can do here, Hmm... Get rid of the...get rid of this. I'm gonna do this kind of hacky for the moment, I'm gonna do this in kind of hacky way for the moment. The non-hacky way is what Umm...your makefiles give you, OK? Then inside the...yeah, I think I will do it really bad. Actually, Hmm...
Hmm... okay.  Typically when you have a implementation file, you're going to include the header file so that the those declarations can be seen. Okay? And now, in order to get the code that I want in place I'm going to put cpp here. *Groans* Cuz I don't wanna deal... ...I don't wanna deal with it Okay. Any question about that? The reason I called this a hack is because the following. Remember my friend Virginia? She just wants the sphere class. The cool thing is that I can compile the sphere separately, and give her  that compiled version together with the header file. And she can use it. Your makefiles will make that happen, okay? But it's a two-step process and I don't wanna do a make file here.  You're supposed to do that in lab, okay? So
Linux. Linux workshop at DCL 1320 tonight at 7pm. Did anybody go last night? The room screw up was totally my fault. It was not the organizers fault. There is no room screw up for tonight. Did you learn things last night. That is all we wanted to know. Okay, so here is what I think you should be good with. You should be good with the idea of class definitions, class function implementation with the scope resolution operator, constructors and when they are used, and client code, and what it means to use a user defined type and class. Especially after spending all day today on it. But there is some vocabulary that we have not yet seen. One way of characterizing object-oriented programming languages is by 3 words you might have heard before but never thought about deeply. Those 3 words are inheritance, encapsulation and polymorphism .... Okay, this is interview prep. They are going to try and trip you up. they are going to see if you have seen this moment. How are object oriented programming languages typically characterized? Now what you will know is that there a lot of different ways of characterizing object oriented programming languages. But what they are looking for is those 3 words. And if you can reel off inheritance, encapsulation and polymorphism, they will go 'Oh wow, this person knows what they are talking about.' But, in case they dig a little more deeply into your understanding of C++. Despite the fact that this is not a C++ class, I want to tell you specifically how we describe the ways in which C++ supports the idea of encapsulation. Now what is encapsulation besides an E-word? It is a separation of the interface of the class from its implementation. Now there are 2 ways that C++ does this. One is that the private region of the class definition protects the data associated with the object.  And so you as the designer, because you believe in this idea, this is what you do in C++. Secondly, this is purely by convention, you already saw today that you don't have to do this, but by convention we separate the .cpp file, the function implementation, from the header file. We separate the function implementations.
Any questions about that? Okay that's just vocabulary. So the same two things. Listen just a minute and do another sort of high level view. So, these circles represent code for a class definition, consider a single class at this point, we've already said that we separate into a header file and implementation file. So the example is sphere.cpp and sphere.h and the vocabulary we use for that .h is interface because I can give you a .h file and you know how to use the class, you don't need the .cpp to get everything you need from the .h file. Now what are all these little blue bubbles? That one is my neighbor Virginia. Here is the main that I happen to use. Maddox came to my office, said hey you got a sphere I can use? I said sure, here's the idea. HEre's what encapsulation gets for you. It allows you to make it so that all these clients can do their business looking only at the interface and it can build a wall , demands that a wall is build between the clients and the implementation. The client can see everything they need to know about the interface and don't need to worry about the implementation. Any questions? It streamlines the communication about these classes at exactly the right level of abstraction. The substance of today is actually memory. If you came from CS125, most of what we've done is pretty much familiar. But it's probably very new if you came from the CE engineering prereq. If you came from the ECE department, you have a pretty good handle on memory. We do talk about this stuff and should be comfortable for CS majors and ECE majors but DO NOT click out because there will be a few things about the wa C++ refers to memory that will surprise you even if you have seen it. So there are some things here that are importa If the memory that you choose when you buy a new machine you decide how much RAM you're gonna pay for. The memory at the system's disposal when it's executing your code and processes it and producing results. All of the software sits as it executes mostly sorta. It can be a constraint on the performance of your machine if there isn't enough of it. 
Into a .cpp file. Okay? Alright, any questions about that? Alright, that's just vocabulary. Okay, so I wanna do this  Those same two things are here Lets spend just a minute and do another sort of high level view. It's okay. We are fine. We are gonna be fine for this semester. Wouldn't do another high level view. So, these circles represent called for a class definition. So consider a single class. The example that you have is this sphere class at this point. We've already said that we seperate into a header file. and an implementation file. Okay, so the example is sphere.cpp and sphere.h And the vocabulary we use for that h is interface. because I can give you a .h file and you know how to use the class. You don't need the .cpp. You can get everything you need just from the .h file. Now, what are all these blue bubbles. Well I'll tell you. You know that one is my neighbor Virginia. Here's the main that I happen to use. Mattox came to my office the other day and said. Hey Cindy you got a sphere that I can use and I said sure. Here is the idea Here is what encapsulation tells you. What encapsulation gets for you. It allows you to make it so that all these clients can do their business looking only at the interface  and it can build a wall, build a wall, it demands that a wall is built rather between those clients and the implementations. So, the client code can see everything they need to know about the interface. and they do not need to worry about the implementation. Any question about that? That's really nice because that streamlines the communications. Could say communication about these classes that exactly the right level of abstraction. Okay That's not what we are talking about today. The substance of today is actually memory. Alright, so if you came from, if you came from cs125, most of what we have done is except for the fact that it's c++, pretty much familiar. but it's probably very new if you came from the computer engineering prereq class 220, if you came from 220. a.k.a KL, a.k.a 190, a.k.a AHH But, vice versa, if you came from the ECE department. You have a pretty good handle on memory. Wait which way is it I don't know what I said before. Okay, we just talked about the stuff that should be kind of comfortable for CS majors we're about to talk about the stuff that should be pretty comfortable for ECE majors.  But, do not click out. Because there will be a few things about the way C++ refers to memory that will surprise you even if you have C in your backpocket. Okay? So, there are some things here that are important Okay, so we are gonna talk about memory Here's the memory we are talking about It's the memory that you choose when you buy a new machine When you decide how much RAM you are gonna pay for. That's the memory we are talking about The memory at the system's disposal when it's executing your code. When it's bringing data in, process from the derived, processing that data and producing results. It's where all of the software sits, as it executes, mostly, sort of. And, it's, you know, it can be a constraint on the performance of your machine if its excuse me if there isn't enough of it. So what is this?
Its a map. I forgot what it was. I think it is somewhere in Silicon Valley. Doesn't it look amazingly like a chip. I was like wow. Yeah. So heres the thing. Theres a really nice metaphor between you know, your basic neighborhood and memory. That is particular parts of memory are designed to be used for particular things.  Now, theres you know the. Lets see the schoolyard. Every community has a school yard. Ever map has a school yard. Right? Here it is here. You can tell because it looks like a school yard or a prison. And similarly memory has memory has places where everybody throws the data and maniuplates it. Its very regimented like a school or prison. How many times can I use that joke? Thats my question. And will it roll off quite so well next hour. Like I do not know. Okay, so just like a neighborhood has particular locations memory does too. And just like a neighborhood has places you cannot or should not go so does memory. The parallel in our world is the seg fault. The seg fault occurs when you go into a corner of your neighborhood where you do not belong. Where you access memory that does not belong to you. Okay enough with the metaphor. You're telling me I'm down. I see I have two minutes. Pen is in my hand. Okay. Oh you're turning over your slides. No. Alright, so we already dicussed the fact I'm starting on next slide. I am going to do this in minute and a half. Okay. We already discussed the fact that when I say something like int x equal five. In memory the following thing happens. A location is chosen for you. Its name is not. The name of that memory, the address of that memory. Again the metaphor address or map. The addresss of that memory. I do not care about. I don't care whether the system is using letters or numbers. Thats not the level the of abstraction we care about in this class. Now 233 probably different. We do not care. The name of my variable here is x. I happen to have instantiated it with a value that is five and its type is an integer, which tells the system just how much memory it needs. Now here's the cool thing. This thing that happens automatically when I say int x equal five. This thing that happens automatically. Think about what had to happen. Memory was looked for. The variable names were set up. The value was you know the bits were flipped so that the value is represented, etc. That was all taken care of for me by whats called stack memory. The system took care of it and it put my variable in stack memory. It set it up for me. No problem. I did not have to ask it do so. Effectively I was asking it to do so just by making the declaration. So this stack memory is system administered. And the nice part about that is when I am done with that variable, the system will also say, oh look she is done and will clean it all up for me. Now you don't you wish there was a metaphor that, but it never happens. Okay, so thats it for today. Stack memory. You love it.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
No audio.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        You need to post to Piazza to figure out who that is.                                                                    Yes. No it's not right. Alright, so I am going to make this joke again. Alright, everybody sit down please, let's get started. I'm going to make this joke again, so if there's anybody in this room with a stapler, now's a good time to um make a lot of money, because there are people up here who need stables and you can say I'll staple your homework for 5 bucks. Um, I would prefer they be stapled. If you don't um, if you are unprepared to turn these things in, um, you need to make arrangements with your section leader to do so. I think we're fairly accommodating on homework zero, and moreover I apologize for the sort of lack of smoothness here. We admit that our system is bad but it's only one homework. So it's only bad twice a year.  We aren't putting a lot of resources into it. Let's see. What else was I going to announce? Don't know.  
Oh I know. So we have as I think you're all aware we have not yet posted the semester calendar for open lab hours. Um which is a problem because mp1 is due tomorrow night. Now here's our plan. We want to set an open lab schedule in stone and have course staff commit to it through the semester and it's taking us a while to settle in to exactly what that schedule looks like. So my recommendation for mp1, we'll get this straightened out don't worry. My recommendation for mp1 is to go to the piazza and look for course staff availability over the next 36 hours. Go and look and if course staff says they're gonna be available then they should be. They're committing to it, and your process for getting their help on debugging your code is to go to chara.cs.illinois.edu and put your name on the queue and be sure and put the room number in which you can be found because course staff will wander all over the basement of Siebel looking for you as long as you tell them where you are. Ok, any administrative questions or comments? Our intention is to return these to you in lab next week. We're probably not gonna get them to you this week. Just in all honesty here. Ok, let's work. Last time, yes? The lab section leaders eventually will be on the website too, but we're still finalizing those so the best thing to do is post to the piazza asking. Say who's in charge of section blah... And they will answer. It's not a huge, you know, we'll work it out even if you get in the wrong bucket we'll grade it and find you. It'll be ok. All right, any other questions, administrative issues? Ok, so let's start. Last time we were here. We talked about declaring and initializing variables of primitive type. And we made special note of the fact that all that happens is that this system-administered process for setting your variable up in memory takes care of finding where your variable should go. I'll put it here. Um, connecting the name of your variable to its memory location, keeping track of its value, and also keeping track of its type. Ok? And that was all just done for you upon a statement like this. Now, all of that is still true for user defined types. So we can say sphere y; and the system says Oh! I've got plenty of memory for you. I'll set that up." And all of this then is set up to denote a sphere. What's the value of the sphere at this point? This is a trick question. In what case is it garbage? If you don't have a constructor that's right. So you can use the constructor here to initialize that variable to have meaningful data.  Ok. any questions about that?
Yes. That's right, that's right. That invokes the no argument constructor. That line invokes the no argument constructor. Ok? Either the default one that's provided to you or the one that you have written. Now the default one that's provided to you will still set up theRadius and what other variables, but those values will be garbage. Unless theRadius is the kind of thing that has a constructor. Ok, but that's not what we're talking about today. So, suffice to say the system will still take care of setting up and administering the use of memory.  That is, it will detect when you're done with the variable and give the memory back to the system for somebody else to use. So nice that way. All right, now there is another kind of variable, so this is primitive-type user-defined types and there's another kind of variable that you may not have seen before. That kind of variable is a memory location. Explicitly a memory location and here's how we declare one. I would say int pointer p" Ok, now what happens is the system says Oh I see what you want here, you need a memory address," Oh, I don't know a52, p, its value is not known here, its type is the memory address of an integer. Now, I said the words memory address of an integer. But what I'm going to write is this. So these things are equivalent memory address of an int is equivalent to int pointer type. Ok? Any question about that? So just symbolic substitution there. All right, fine. So among these, from everything you see here, what's a valid value to go here? What could go here? What's the only thing given this diagram, yeah?  Yeah, so the memory location associated with x Because x is an integer is the only valid thing that you can put in this spot. Now, hmm, how do we make that happen is the next question. Any questions before I go on? Yes? Oh boy, we're gonna spend about the next 2 weeks seeing uses of this ok? Excuse me? Bit shifting? Maybe In some contexts. But there are others that come immediately to mind and I'll give you a heads up. Here's the heads up:  Data itself is huge. Pointers or memory addresses are small. So when you have a big chunk of data like a photograph or a movie or something and you don't wanna be passing it around, passing all that data around, you can use its memory address to refer to it from all kinds of different places. Ok, so that's kinda the biggest thing to keep in mind as we go forward and talk about these things. Ok? Does that help at all? But that's way foreshadowing, that's like Wednesday's lecture, ok? The question is, the question is how do we give p value? We all agree that our intention here is for p to point to, to contain you know a20 here. I should connect the dots, but I'm not going to because that's the mystery. The question is how do we assign to p? Well, what do you think of this? What do you think of that? Maybe I can give p x's memory address simply by having x on the right-hand-side and the system's smart enough to go Oh, I know what you mean." Is it? No. Ok, how do you describe what's wrong here? What gives you heebie jeebies about this assignment statement? Type mismatch, that's right, the thing on the left is an integer pointer, the thing on the right is an integer. That should be coursing through your veins as you read code. So this is a type mismatch. Can't do this, it's a type mismatch.  Ok, fine. Maybe what you do then is simply explicitly assign like 0xa20 there. What do you think of that?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
What do you think? Blake. You like it or no? This one's a little harder to articulate why you don't like it, right? So these are memory addresses. Do you wanna say something? Right. Very good. Very good. Good point. So he says well how do you know the memory address of x and that's exactly the right point. Remember we said the system gives you memory addresses in stack memory, right? It says here it is. We're gonna put this right here. At the programatic level, at the client code level, we don't know where that is. We have no idea where that is. In fact, those memory addresses are designed for the system to use. And you know what? Their representation reflects that. The representation of the memory addresses themselves are in hexadecimal. They're almost unreadable and I for one don't ever want to know where x really is. Now, I understand that if you are concerned with the low level behaviors of the machine, you  care. But we will not care. We are gonna let the system handle its memory address representation. So, what we need this so we're not gonna do that either. Hold on, so we're not gonna do that either. And the reason is that we don't know where x is nor even how to represent a memory address. [no audio] Okay, so the solution to this problem involves an operator called the address operator. [no audio] And here's how it works. I can assign to p the memory address of x. So that ampersand when it modifies a variable pulls off the memory address and returns it. So that they can be assigned to the value of p Any question about that at all? So the result and notice at the programatic level you never actually need to know what this value is. You're effectively just referring to it through that ampersand sign. Any question about it? So what happens in the backside is again what happens to be represented by a20 here is returned. And then assigned to p So, in the end it looks like this. Now, I happened to like a different mechanism for drawing this. A different way for sketching what this looks like. I like to do it like this. When a pointer is declared, I like to make a little box with a dot in it. When other variables are declared, I like to make rectangles because they're kind of bigger somehow. And then, when an assignment like this one is made, what I'm saying is that p points to x. I believe x had a 5 in it. Alright, now, here's the thing. Right now, these pointer variables are not particularly useful to us. So let's pretend for a second that we had this memory setup but we happened to not have x labeling that space and we'll see many more examples of this later but let's think about this now. So suppose we didn't have x labeling that space. Is the setup completely worthless to us? No, so if we have a pointer variable, probably we are interested in the value of thing we're pointing to. The value of the thing we're pointing to. We can get at that value using yet another operator called a dereference operator.
Yes Right because they both go off the stack those are freed for you yes? Um yeah because its an array ok you need the brackets because its an array if it were just a pointer if we had instantiated this as just a string pointer, right a pointer to a word Then you wouldn't need the brackets, you would just delete it ok so  in general in general your deletes should match your news whatever kind of new statement you use to create the thing usually in your constructor youre going to use a similar thing in your destructor Any questions about that? Is this good? yeah? Its called right after the return  As this um execution completes and control is passed back to the calling function All right Any questions? you good? Ok I'm going to show you, yeah? Oh my gosh there is so much book keeping going on for you We are so lucky right? like our, your grandfathers, my parents Ah i shouldn't have said fathers there look at that Your grandparents in computing my parents in computing ummm they think that life is way too easy for us Actually its probably my grandparents your great grandparents but um they think computing is way too easy for us  And in fact you know the fact that uh we don't actually have to keep track of what variables were using ourselves is just  uhhh you know were not authentic programmers so  the early days of c were pretty pretty harrowing i think so theres a ton of bookkeeping that goes on  and part of what they keep track of is what amount of memory is associated with each variable all right and you'll learn about it in future classes because of course thats what generations do right you work to inflict the pain of previous generations on the current all right um any questions about it any other questions? you good? Ok i have another story to tell you here Im gonna take you through another little piece of code umm heres how this piece of code goes This time Im going to declare a sphere pointer b Ok so heres b And I'm going to ask for a new sphere Now we've made a constructor for a sphere we made a constructor a sphere that sets up a uhhh a default sphere to look like this so when i say new sphere that constructor is called for us so at the end of this statement its perfectly reasonable for me to draw this picture making note of the fact that the sphere constructor was invoked for us not the copy constructor, the no argument constructor ok, any question about that? ok  now lets look at what happens when we say  delete b what do you hope happens when you delete b when you say delete b what do you hope happens by default what do you hope happens All of this memory all of this memory is given back to the system right by default without the destructor only this part is given back no dynamically allocated memory no memory allocated with a new is given back so again were responsible for writing a destructor that makes that happen this is the same destructor its just used again so if you remember that code looked like this
Excellent question, can I answer that question on the next slide? So the question is ... what if you don't have an x but you have an integer pointer, does that summarize your question? Okay that's here So it turns out that you don't want to always have a stack variable to represent your, to have to point to  and in fact in this situation if you have that stack variable , you probably should just use x. All this indirection that's just play, as often as you can you just want to use x. So what are we doing this for then? What is the deal ? The answer is we have this other chunk of memory This other region of RAM called heap memory  and it is memory that you control. That is you control when something is allocated from it and you control when the memory is given back to the system to use. Stack memory was system controlled and Heap memory is programatically controlled Now how do we do this? Again I got it set up so we have an integer pointer p and I want to ask for a chunk of memory. I'm going to do that by saying p = new int  This is explicitly asking for that integer. Yo heap I need some memory and the heap hands me back a memory address the size of an integer somewhere  and this assignment statement gives that memory address  to the value of p Any question about that ? And there is no x in sight, there is no stack variable in sight And in fact we don't generally have a name for this  the name of this is really *p or the dereference of p, this target of p Yes? [pause for question] It creates a new one, it creates new space on the heap So p is, I don't know what you ummm, it , when you declare it it sets it upon the stack and then you can use, you can use that spot on the stack as much as you want [pause for another question] Right here? this assignment? Are you talking about b24? Show me what your talking about, okay p = new int [question] It will go to p's spot because p is on the left hand side, does that make sense? It's not scary to ask a question cause I might ask you to .. Okay yes? Yes very good, I can say sphere *s, s = new sphere and the sphere the sphere constructor is invoked but in this other space I've got an s and this thing is going to point to whatever that thing is. Any question about it? [question]
Oh, excellent question Can I answer that question on the next slide? Ok the question is, what if you dont have an x But you have an integer pointer, does that summarize your question? So it turns out that you dont want to always have a stack varibale to have to point to In fact, in this situation, if you have that stack variable, you know you probably should just use x, all of this indirection, that is just playing as often as you can, just use x so what are we doing this for then, what is the deal, and the answer is, we have this other chunk of memory, this other region of ram effectively this other region of ram called heap memory, and it is memory that you control that is you control when something is allocated from it, and you control when the memory is given back to the system to use ok, so stack memory was system controlled, and heap memory is programmatically controlled ok, now how do we do this again, I got it set up so we have an integer pointer p, and I wanna ask for a chunk of memory I'm going to do that by saying p = new int this is explicitly asking for that integer, yo heap, i need some memory, and the heap hands me back a memory address the size of an integer somewhere and this assignment statement gives that memory address to the value of p ok, any question about that? and there is no x in sight, there is no stack variable in sight, and in fact, we dont generally have a name for this, the name of this is really asterisk p, or the dereference of p, the target of p, yes? It creates a new one, it creates new space on the heap Ok? It asks So p is, when you declare it, it sets it upon the stack And then you can use it, you can use that spot on the stack as much as you want Right here? This assignment? Are you talking about the b24? Show me what you're talking about, ok so p = new int Yup It will go to p's spot, because p is on the left hand side, does that make sense? OK It is not scary to ask a question because I might ask you to Yes, very good, yes, I can say sphere * s s = new sphere And the sphere constructor is invoked, but in this other space Then i've got an s, and this thing is gonna point to whatever thing that is Any question about it?
The name is the only thing missing.  The type has to be integer, and the value (how do we give it the value as we only have x?)...  Here's how we give it value.  We say the value of p equals 42.  So we know P, you follow the pointer, and you put the value inside.  In other words, P is a pointer, we ask for a new integer, it has no name but it is a box.  We assign that one to P. And then when you do this statement When you do this, this says go to P, follow the arrow, give it value 42.  Yes, that's right. You still have to assign value to it otherwise it is garbage.   In fact all constructor rules apply there.  Alright, yes.  Possibly, yes.  And also so the system is going to decide when you are done with P, based on the scoping.  When you are done using P, when your function execution stops, P is going to be gone.  This won't be.  This will persist until you say you're done using it.  Okay?  Yes?  Umm, if I have the right constructors made I can.  So if I have a sphere class constructor that takes a radius, I put a radius there.  Okay, are we good?  I think the best way to get up to speed with this material is just to practice.  So we're going to spend a few minutes practicing.  Yes?  Yes! So I'll say this, because I think it's helpful.  New is a function.  In C++.  It takes an argument. The int, the type, is the argument to the new function.  What does new return?  A something pointer.  That's right.  On the left hand side you have to have a pointer.  On the left hand side of the assignment statement you need a pointer.  So you know that new will return new a pointer type.  Oh! Okay, now you're asking for me to keep going.  Alright, I want to show you something that's very fun in that it's part of your cultural heritage.  Before we go on though.  Okay Much smoother about this this hour Nope nope no I don't want you  And Okay ready?  Okay.  Hey Binky, wake up!  It's time for pointer fun!  What's that?  Learn about pointers? Oh goody! Well to get started, I get we're going to need a couple pointers.  Okay!  This code allocates two pointers for integers.  Okay well I see the two pointers but they don't seem to be pointing to anything.  That's right! Initially, pointers don't point to anything.  The things they point to are called pointees.  The pointees are separate. So how do you allocate a pointee?  Okay, well this code allocates a new integer pointee, and this part sets X to point to it. 
The name is the only thing missing. The type has to be integer, and the value, oh geez!  How do we give it value now because we longer have x right? Here's how we give it value.  We say the value of p equals 42.  So you go to p, you follow the pointer and you put the value inside. In other words, p is a pointer, we ask for a pointer, it has no name but is a box. Ok, we assign that one to p, and then when we do this statement, that says go to p, And then when you do this statement, follow the arrow, give it value 42. Yes, that's right.  You still have to assign value to it otherwise it is garbage, and in fact all constructor rules apply there Yes ....... possibly.... yes, and also this memory, so the system is going to decide when you are done with p based on the scoping so when your done using p and your function execution stops, p is going to be gone. This won't be.  This will persist until you say that you are done using it. Yes, if I have the right constructors made, I can. So if I have a sphere constructor class that takes a radius, then I can put a radius there. Ok, are we good?  I think the best way to get up to speed with this material is to just practice.   So we are going to spend a few minutes practicing.   Yes, so I'll say this because I think it is helpful.  So new is just a function in C++.  It takes an argument.  The int , the type, is the argument to the new function. What does new return?  What does new return?  Yes, ... a pointer. How do you know that?  Because on the left hand side you have to have a pointer. On the left hand side of the assignment statement you need a pointer, so you know that new will return you a pointer type. Yes? .......... Ohhhhh ok, now you asking me to keep going ok?  I want to show you something very fun that is just part of your cultural heritage. Before we go on though.... Ok... I'm much smoother about this hour.  I don't want you, I wan't you. And...          Ok, ready!  Ok! *POINTER VIDEO BEGINS* Hey Binky!  Wake up! Its time for pointer fun. What's that?  Learn about that? Learn about pointers? Oh, goodie! Well to get started,we will need two pointers.  Ok, this code allocates two pointers which can point to integers.  Ok, well, I see the two pointers but they don't seem pointing to anything That's right.  Initially pointers don't point to anything.  The things they point to are called pointees. Setting them up is a seperate stem.  Oh, right.  Pointees are separate.  How do you allocate a pointee? Ok, well this code allocates a new integer pointee, and this part sets x to point to it.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
[Video Playing] I want to add one thing to this that is captured by the video that I sort of forgot to say, and that is if we also have integer pointer q, so he had, and that is set up somewhere in memory. You know, who knows where? And if I say q gets the value of p, this whole pointer assignment thing totally makes sense.  It's not magic at all because, think about what it means for q to get the value of p. It means b24 is copied into this space, right? B24 is copied into this space. So after doing so, q refers to that same memory address. So that whole sharing thing, it wasn't magic at all, okay? All right, any questions about it? Any questions about that? Okay, so like I said, practice is golden here, so let's spend some time practicing, yes?
P equals q. Yeah, cause q currently has garbage, right, yeah. He asked about the inverse assignment. Okay, fine. This first page is warm up. I think we should be able to kind of crank through this based on what we’ve already seen. Okay so what type is q? Raise your hand if you think it is a pointer type, q is a pointer type. You know you would hope right, but it turns out the asterisk * actually modifies the variable. So in this example q is an integer. If you want it to be a pointer you have to say, “int pointer p, pointer q. And this chaining is fine, it just sort of, it’s a little idiosyncratic thing you need to know about. Okay so let’s do this next one really quickly. I’m going to draw the pictures it’s very similar to what we saw. Integer pointer p it’s declared. Integer x it’s declared. P gets the address of x, makes p point to that space. The value of p, okay so we follow the pointer p, get six. Now what happens when we output x? It is a six. We have changed the memory associated with x underneath it. What if we output p? What do I get? I’m outputting p, the next line, oh man I don’t even want to know what I get.  This is a horrific hex number which represents the memory address of p. Alright now write a statement whose output is the value of x, using variable p. I’m going to do this one really quickly, you can race me if you like. Asterisk * p That end line is just a new line. Did I say memory address I meant dereference of, sorry, cout the value of p. Write a statement whose output is the value of x. Oh, oh yeah sorry. Good catch. I’d like to say I did that on purpose giving you a chance to like engage, but that would be a lie. Alright, good. Good. Good. Good. How would I output the memory address of p, how could I make that correct? Aww I should have thought of this.  I don’t know what you’re talking about, and then I would have done what? Yeah the ampersand & p. Cout ampersand & p, gives you address of p. Okay, good. Alright, any surprises? Anything on this page surprising? Okay now let’s get to some nitty gritty. Okay. Alright, so I have these two pointer variables. You can probably go all the way down to here. Let’s meet here. I’ll do it and I’ll talk aloud, but you can tune me out if you would like to think separately from me okay. So this code says Make me a pointer p and a pointer q give p an integer and point to it make q point to the same space use q to give value 8 there and now output the value p What do we get? 8? Yeah. Okay. I strongly encourage you to sort of trace these on your own. Okay, now let’s do down to here. Go ahead and trace down to here. Add on. So now q gets a new integer and is assigned to it  and the value of q is 9. K, so you should have the same picture. p and q each have their own memory available to them they are not shared at p's new Yes. 
ask about the inverse assignment Ok, fine, this first page is warm-up Ok, I think, I think we should be able to kinda crank(?) through this based on what we have already seen Ok, so what type is q? raise your hand if you think it is a pointer type you know, you would hope right? but it turns out the asterisk actually modifies the variable So,  in this example, q is an integer . If you want it to be a pointer, you have to say int pointer p pointer q and this changing is fine, it just sort of, this is a little, idiosyncratic thing that you need to know about Ok, so lets do this next one really quickly , I am gonna draw the pictures, it is very similar to what saw integer pointer p is declared , integer x is declared  p is the address of x, makes p points to that space, the value of p, so we follow the pointer p got 6 now what happens when we output x? it is a 6 right, we have changed the memory associated with x underneath it Alright, what if we output p, what would I get, I am outputing p, the next line, oh man I don't even want to know what I get ok, this is a terrific hex number which represents the memmory address of p Alright,  write the statement whose output is x using variable p, I am gonna do this one really quickly, you could race me if you like asterisk p, that endl" is just a new line, yes? Emm, did I say memory address , I mean dereference, em, sorry c out the value of p write the output whose value is x, oh, yeah, sorry you catch, I'd like to say I did that one purpose , giving you a chance like engage but that would be a lie Alright, good,  how would I , how would I output the memory address of p, how would I make that correct , oh I should thougt of this I don't know what you are talking about , and I would have done what yeah, the & p.  c out & p gives you  address of p , ok Alright, any surprises? Anything on this page surprising, now lets get to some ........... Alright, so I have these two pointer variables, you can probably go all the way down to here, lets meet here, I will do it and I will talk aloud, but you can tune me out if you would ilke to think seperately from me ok? So, this code says make me a pointer p and a pointer q give p an integer and point to it, make q point to the same space, using q to give value 8 there, and now output the value p, what will we get 8? yeah, ok. I strongly encourage you to trace these on your own  ok, now.  lets do down to       ...........  here, go ahead, go ahead and trace down to here So, now q gets a new integer , and assign to it, and the value of q is 9 ok, so you should have the same picture p and q each have their own memory avaliable to them, they are not shared the piece, new , yes
Yes New is a keyword that we use. Its modified, its followed by a type Its arguement is a type It returns a pointer. It's a keyboard that returns a pointer. Okay Alright, so p equals. Alright, any questions about the picture so far?  Let me tell you about NULL Let me tell you about NULL NULL is a canonically zero memory address. K, so NULL is a canonically zero memory address Not garbage, its not garbage and the main thing that differentiates it from garabge, is that you can test against it. You can say if p is not equal to NULL, or if p equals NULL K, so the key point is that is that it is testable. Whereas garbage, not so much. Alright, so now all we are saying is Never mind, I don't want p to point to that old memory anymore. I want to set it to this canonically zero memory address. Okay, now. You like this? Why, not? Yeah What about p's pointee, look at this. We went to the effort of asking for that memory. We said, Yo heap please give me some memory. It did so, and then all of the ways of referring to it were removed. All of the variables essentially turned their backs. Okay. You can tell, because you can look around 8 and there's nothing existing coming into it anymore. This makes me very sad. And, in fact, so sad... Drip. Drip. Drip. We call it a memory leak. Okay, so a memory leak occurs when all reference to heap memory are removed. Okay. Well, this is a pain. How do we fix it? The answer is we fix it by using keyword delete. So delete is the keyword that we use to say, okay, I'm all done with this memory now. The system can reuse it if it wants to. So in this scenario what we're going to do is say delete q. We're going to say delete q. That frees this memory  And now we can say q is equal to NULL and we have not created a memory leak. So how could we have fixed, how could we have fixed the p leak. That will be funnier to you when you have children. How could we have fixed the leak around variable p. How could we have fixed it? Yeah. Right. Exactly. So he said we could have not set it to NULL before deleting it. So I could have said delete p right there. Free the memory then set it to NULL so that its testable. Yes. If you say star *p equal NULL you'll get a type mismatch, because *p is an integer. *p means the value of p What you are pointing to, and that thing that it is pointing to is an integer. So you'd have a type mismatch across the assignment statement. That's right if you set it to NULL before deleting it you cannot fix it. Its a memory leak We have tools to help us, but we should still play defense here. Alright, anything else, anything else about this that's interesting? Yes. Oh, oh, that gosh. You guys are amazing, its my next slide. Alright. Okay so everybody looks, wait a minute we're not quite done with this one yet. So deleting a NULL pointer, so saying delete on q. Is what we call a no op, that won't hurt anything. That's a no op. But, dereferencing a NULL pointer, think about what that says. It says follow the pointer coming out of this thing that is NULL. There's no place to go. There's no place to go out of a NULL pointer. It points nowhere. Its just test-ably nowhere. This is called a segfault. And it happens at run time. So actually dereferencing a NULL pointer is kind of a bad bug.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
okay alright so uh the question on the board is what happens if you have two pointers that point to the same thing like this heres the set up you delete the memory through one of them and this is a to be continued dun dun dun its tru;y a cliff hanger because this is insidious
Okay. Alright. So the question on the board. The question on the board is: What happens if you have two pointers that point to the same things? Like this. Here's the set up. And you delete the memory through one of them. And this is a to be continued... Dun dun dun... It's truly a cliff hanger because this is insidious.
Can you hear me?  Can you hear me in the back? Can you hear me in the back?  Can you hear me in the back? Can you hear me in the back?  Can you hear me in the back?  Can you hear me in the back?  If you could hear me in the back, stand up  You're not the back. Ok. I think this is good, do you agree this is good? The back row, the back row, you speak for the trees. Alright So last time we were talking about pointers and their behaviors in C++. And we're going to continue that discussion Right now, I want to show you a little bit of code that I think will surprise you Oh and I have a present for you, are you ready?  Ready for my present? Woah. Not sure I like the color scheme but I mess with my, I mess with my config file. So you should find the code a little easier to read.   Okay, so draw yourself a little picture. Process this code, it's got pointers which we learned all about last time. Draw yourself little picture about of what's going on here. I think you should have at least one question, but I also think you can guess at the answer to the question and you will be right. Oooh. We are speaking mysteriously here. And then we'll talk about this a little bit, so, you're going to have a question, guess at the answer, and of course, guess at the output here Alright. Draw yourself a picture. Draw yourself a little picture and guess at the output of this. 
Okay, turn to a person sitting next to you and see if they drew the same picture you did.   And ask them what they think the output will be. [Talking to students] Up there.  Yep. Yes so I haven't started the node stuff yet.  I might end up replicating them. Alright somebody speak for the crowd what you think the output is going to be? Somebody tell me... Yes? [Student answers] 25 for the first one and... how about that second one? Garbage for the second one. Ill tell you right now that that would be good news because the intention here is clearly to be done with that memory right?  That is kind of what we are saying when we say delete p we are saying we are done with p now. We can use the memory assosciated with p, but heres the problem.  uhhhhhhhh Ready.  Ready for this. Ohhhhhhhhhhhhhh Okay.  So look at your picture you have p and q pointing to 25 right.  And you basically, when we said delete p, all you did was make that memory available for the system to use again.  You did not pull back the pointers effectively.  The pointers still point to that space and that space for the moment still holds 25. Any questions about that? So I could do this as well.  I could do even after I delete p, I can ask for its value. (talking to herself) My hands are shaking today I do not know why. And still I can access it.  Yikes! Yes? [Student asking a question] Thats a really good question.  Um so any other application can also use it at that time, but for our purposes we do not need to think about it very much.  It depends on the virtual machine that is set up around that memory. Okay. Alright so but for our purposes you do not really need to think about other processes because you dont even have to its broken anyway.  Watch this, let me see if I can make this happen. Alright so we deleted p which means we gave it back to the system to use. For example I can say q equal new int.  What value should we put in there? 5 okay.  Fine.  And now when I say... uhhh the value if I ask for the value of p. So I am going to change this to a new hue.  Lets see what happens. [output on screen]  before del p: 25, after del p: 25, after new q: 5
how did that work? what happened there? do you need a picture? yeaaaa! this is insidious! lets look at code again because this is just nasty look look i shouldn't being using p's and q's they look to much alike right? i ask for the value of p? the only thing, the only thing that has a five in it is...? is Q and that should be brand new space, right? the problem is p is still poiinting to where it was before and the system happened to, happened to reuse that space okay so lets draw a picture? Ill do it on my slides in a minute in a similar context we'll do it here for now here is p here is q ok? we originally set things up like this so that p is pointing to this space  and q is pointing to this space ok? now we deleted p which mean't we gave back this memory for this system to use and then we didnt pull back this pointer we reassigned this pointer we said okay i want a new q ideally I wouldve been able to draw a  seperate box here but guess what space the system used? it used the one we had just freed it happened to have chosen to give us that very same space which we initialize to have value 5  but think about P right? its like returning to the earlier part of the story, p still happens to refer to that space we didnt pull back the pointer so now when we ask for p we get 5 not because p was ever assigned to 5 or was intended to point to memory that we were using to have value 5 but because we left that pointer dangling into space and it got reused okay? yes? so that was, I was actually gonna do that so the question is would the space be reused again, what would happen if we used a different data type that is if that box didnt fix quite so neatly lets try that out because i dont want to do it incorrectly so lets a declare a new thing uhmuhmhm and lets declare a new thing a double r and let  new double doubles are different sizes and we'll make it 5.0 and well see what happens okay? did i screw something up? its not a pointer  you all have that and i didn't did you see it did you see what i did i didnt make it a double pointer so new handed a double back or a pointer back and thats a type mismatch across the assignment to r okay so it didnt preserve, oh it still worked tho okay so it changed memory in such a way its not 5 and its not 25 and its not  you know we still ask for an integer  so the moral of this story is the systems kind of using memory as it sees fit and so you have to be concious all the time of where you're pointer is pointing the safest thing to do is once you delete space be sure to set all the references to it that could be pointing to it to NULL so we can fix this if we had set p to NULL up here delete p, p = NULL and then whats gonna happen then what will happen  yea right
Phew Ok, any questions about it? I'll be happy to indulge any of your questions.  You had a question when you came in? Oh, you did. Did this get at the question you had when you came in? Ok, what was your question. It was a good one. [Student responds] Oh, ok good. We'll try that one too. Alright, so let's go a different example. Here you don't want ... you don't want to even initialize the value, right? You wanna try that? [Compiles code] [Segmentation fault] [Modifies code] Alright, so do you all see his question? He said what happens if you try to give p value before asking for heap memory to be associated with it. And the answer is, look, you didn't ask for memory and yet you asked for p to be dereferenced so as to assign a value. That moment right there is a seg fault, that's where you're trying to access memory that doesn't belong to you. Alright, so the upshot of that lesson is, before assigning values, to be sure to ask for heap memory to be associated with your variable. Any questions about it? Good good. Ok, yes? [student asking question] [Opening other example to answer student question] Alright, so you are asking me, after I set this to NULL... Oh, I never ran this one, did I? What are you asking me? Go ahead and ask again, sorry. This one right here? Yeah, ok, so why doesn't it print NULL there? So the pointer is a variable with a type and that's a pointer type, it's not a string type. If it had said the word NULL, it would be reflecting the fact that the contents of the variable was a string or something that we could represent as a string whose value was NULL.  Now, in this context, you might find that more helpful, but in fact, NULL isn't a string that's spelled N-U-L-L. It is a memory location that we happen to represent by that word. Moreover, it is a memory location that cannot be dereferenced. It cannot be followed. There's no place to dereference it to. And so the error message if you tried to do that is a seg fault. Because you're trying to dereference something that isn't yours. Ok? Alright, yes? [Student question] No, very very very good question. And that makes me think you're ready for the next slide, because we're going to talk about that. So, her question is, are p and the thing it points to two separate variables? When you give back the memory, when you say delete p, does that variable still exist for reassignment? And the answer is yes, watch this. I can in fact say here p equals new int and ask for a different piece of memory to use p to point to. This gets it, right, at her question. And then I can ask for the value of p. No, what'd I do wrong. Ok. [exasperated sigh]
OK. umm. OK, here we go.  So I redirected the memory and reassigned it to work perfectly fine.  Alright, yes, you're free to ask questions now   That's right. Q no longer has as it's same target, P. It's still pointing off to where it was before, it didn't follow along. Okay? That's actually a really good point. Let's draw this picture really quickly That's actually a totally valid point. Alright, so, P = new int We delete P. Set P = null. Nice. And now we reuse P. So now, we say Okay we changed our mind, we'd like to use P again" And we're going to put 42 in there. Q still points over here. Q is still just a pain in our side. Kay? So. How do we solve that? This should be a gimme at this point. How do we solve the Q pointing there? q = null, that's right. And a reasonable place to do that would be at exactly the same place we said P = NULL So, the minute you couple the two variables via an assignment, you want to keep note of that fact. Yes? Oh, geez, then it's working for no good reason! Right? So, then your things are tangled up still, but they happen to work correctly  So this issue of being responsible with your memory is actually quite deep. Yes?  Yeah, you can, so you can mess up your friends, yes. And this is a security flaw, this is a common... when people are looking for exploitation of C code this is the kind of thing they look for. Access to pointers that haven't been cleaned up. Yes.  Yep. Because then they're just sitting there and they're both separate.  Then that couples them back together Oh! If P is equal to.. is q already null?  Yeah, that's fine. That sets q equal to null. So then they're decoupled. Right, that's right. NULL breaks everything. NULL breaks all association. It is a perfect place to start and end with your pointer variables. Yes?  Yep Yep Yep, so from the start you're kind of toasting yourself. Oh! And this is a good reason... Novice programmers, new programmers like to assign extra variables for everything. Like Oh I don't have something pointing to that, I'll just make one." And the danger in doing so is that you do lose track of the way that things are coupled.  We test you on this in MP3. MP3 has a crazy confusing function in it that is really only crazy confusing if you give yourself 150 extra variables and it's very tempting to do so, but you don't have to.  So, using fewer references or pointer variables is a good idea. Use the ones you have. Understand what they're for. Don't do gratuitous variables just because you think you might need them. Okay Yes?
what null does um ok yea its the zero memory location you can think of it as the zero memory location zero x um so if you alright alright so null is  you can think of as  um p's variable has this ok in it that's its memory address ok its the zero memory addres on memory  on the chip in memory that is the spot that belongs to the system ok so if you dereference it  if you ask for this variable to be expanded to ask you what its pointing to number one it's not yours number two it's never going to be pointing anywhere ok does that make sense so if I ask for  what is sitiing here so p's value is this so if i dereference it  im folowing this it's memory that doesnt belong ito me it's belongs to the system ok yes no it won't so the question is if you dont iniitilaize your pointer will it alwyas initialize to null the answer is that it doesnt it'd be nice if it did and some compilers might do that for you but you cant count on it you should always  initialize it or atleast understand how it is initalized ok alright ok lets go to the slides and talk about some of this stuff really quickly i think the most important thing wil lbe that you draw the right pictures for a lot of it please connect ok so your only announcement for the day is that um mp2 is available umm due in two weeks  now i don't think we ever explained to you the extra credit policy in much detail there is an early deadline for the first part of the assignment and it is worth one full point towards your final grade so this is  uh oh why why tell me why i know why i know why i got it ok so this is one point of extra credit it truly is extra credit its pure grade inflation we do our final grading lines before we give you those points and um and its approximately  half of the mp so this is our attempt to give you incentive to start early on your assignment ok any questions about that and thats in about a week its also our attempt to  its our attempt to distribute the responsibility for  the course staff over the two week window yes do you have a question
No, it shouldn't we have run into that bug before, but it shouldn't. So I believe the question was, well what if you do the whole thing beforehand  do you still get the extra credit, does it compile separately, is it tested separately? The answer is yes, our intention is yes. In the past there was this bug, where if you started on 2.2, it messed you up on 2.1, but I think we fixed that. I promise you we will do the fair thing for sure.  Do you have a question? [Question being asked] Yes, the auto grader will run every night after the extra credit deadline, so the extra credit deadline happens in about a week. And then we will fully grade your mp every night between that intermediate deadline and final deadline and moreover, because we recognize if you get  an 85 on the night before it's due, you're gonna scramble to fix it. And in the process, you break it completely. We take the highest of the last two submissions.  So you don't have to worry about that night before crisis [Video Playing] So I saw a miraculous thing last night. Raise your hand if you were in the lab last night on the MP, because I want to talk to you. Was it crowded in the lab last night? Not really? This is a strange phenomenon. In the past, on the night things are due. There are like 80 people on the queue, and the course staff is going out for dinner. And so it really like a fruitless thing  to wait until the last minute, because  if you run into problems, it is very difficult to get help. But last night there were only 3 people and 4 course staff. For those of you who do not know what I am talking about with the queue and the office hours. What you are going to do is go to chara.cs.illinois.edu. And put your name on the queue and the course staff will come find you. Our intention is to staff office hours everyday of the week from 9am-9pm. Choose a box, each one of you choose one box to examine carefully with someone sitting next to you, simultaneously while you're working on your one box, I will try to work on all four boxes. Then we'll come together and spend 2 minutes summarizing things. So, you go work on a couple of these boxes, I will too. And then we'll summarize. [Video Playing](Memory Leak Practice)
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Ok. I want to pull you back together. This one is just information. This is a type mismatch you cant delete a non pointer type. This one is a memory leak it was just like the very first memory leak picture we did. This one is incidious because everything here works fine but its probably not what you intended. Anytime you refer to memory that has been deleted you have a problem. And then this is the last one I wanted to ask everyone to think about very quickly. Let me ask you a question. Is there a type mismatch anywhere? Do you see a type mismatch? Is everything ok type wise? Yes because if you dereference p the result is an integer. So across this assignment statement you have an integer on the right and an integer on the left. So is this box fine? No its not fine, why not? Yea p doesnt have any memory associated with it and you dereferenced it. So that's going to give you a seg fault. Alright any questions about any of that? Alright is a type mismatch a compile time or runtime error, that is am I going to get that error when I invoke clang on my system or am i going to get that error when I invoke a.out. Clang, this is a compiler error, those are the easy ones. Ok how about the bottom right box, compiler error or runtime error am i going to see that when i invoke clang or when i invoke the output file a.out. Yea this is a runtime error. That's unfortunate, you don't even know about it until someone is using your software. using your application. OK the problem with the first two is that they are both runtime errors with no notification. You need to be using debugging tools to even find them. So these are runtime errors but I'm going to put errors in quotes because there is no error message. Alright lets move on . Ok so somebody asked. What happens to the pointer p and we talked about the fact that it can be reassigned. What I'd like for you to do for a minute is to tell me, look at these two pieces of code and tell me whats the difference functionally. What do they do differently? Take a couple minutes and look at the code and tell me how are they different functionally what do they do differently. Main functions are identical. You can assume that string is a standard type. So we can actually do that if we are using, if we pound include string we can actually do this. ok so what is the difference functionally between these two lines of code or two pieces of code. Yes, 
Okay, I want to pull you back together. This one is just information. This is a type mismatch. You can't delete a non pointer type This one is a memory leak It was just like the very first memory leak picture that we did This one is insidious because everything here works fine but it's probably not what you intended. Any time you refer to memory that has been deleted you have a problem And then this is the last one I wanted to ask everybody to think about very quickly. Let me ask you a question: is there a type mismatch anywhere? Do you see a type mismatch? Is everything okay type wise? Yes Because, if you dereference p, the result is an integer, so across this assignment statement you have an integer on the right and an integer on the leftt So is this box fine? No it's not fine, why not? P doesn't have any memory associated with it and you dereferenced it That's going to give you a seg fault Any questions about any of that? Is a type mismatch a compile time or runtime error? That is, am I gonna get that error when I invoke clang on my system or am I gonna get that error when I invoke a.out? Clang, this is a compiler error Those are the easy ones How about the bottom right box? Compiler error or runtime error? Am I gonna see that when I invoke clang or when I invoke the output file a.out? Yeah, this is a runtime error. That's infortunate, right? You don't even know about it until somebody's using your software, using your application. The problem with the first two is that they are both runtime errors with no notification. You have to be using debugging tools in order to even find them. So these are runtime errors but I'm gonna put errors in quotes. Because there is no error message. Let's move on. So somebody asked what happens to the pointer variable p and we talked about the fact that it can be reassigned. What I'd like you to do for a minute is to tell me, look at these two pieces of code, and tell me what's the difference functionally? What do they do differently? Take a couple minutes and look at the code and tell me how are they different functionally, what do they do differently Main functions are identical You can assume that string is a standard type so we can actually do that. If we pound include string we can actually do this. So what's the difference functionally between these two lines or code or two pieces of code? Yes? [nothing]
OK, I want to put it back together. Eh, this one is just information; this is a type mismatch, you can't delete a NULL pointer type This one is a memory leak, like the very first memory leak picture like we did This one is insidious because everything here works fine but it's probably not as you intended.  Anytime you referred to memory that has been deleted you have a problem. And then this is the last one I want to ask everybody to think about very quickly. Let me ask you question: is there type mismatch anywhere; do you see a type mismatch? Is everything OK type wise? Yes, because if you dereference p, the result is a int So across this assignment statement you have an int on the right and a int on the left So is this box fine? No it's not fine, why not? P doesn't have any memory associated with it and you dereference it  So that's gonna give you a Seg fault Alright any question Is a type mismatch a compile time or runtime error? That is, am I gonna get that error when I invoke clang(compiler) on my system or am I gonna get that error when I invoke a.out?  Clang. This is a compiler error, those are the easy ones How about the bottom white box. Compiler error or runtime error? Am I gonna see that when I invoke Clang or invoke the a.out? Yep, this is a runtime error That's unfortunate, you don't even know about until someone is using your apllication The problem with the first two is that they are both runtime error with no identification You have to use debugging tools to  in order to even find them So these're runtime errors. But I'm gonna put errors in quotes Cause there's no error message Move on OK, so somebody asked what happened to point the pointer p when we talked about the fact that it can be reassigned What I'd like for you to do in a minute is to tell me, look at these two pieces of codes and tell me  What's the difference functionally, what do they do differently [Students working] Main functions are identical [Students working] You can assume that string is a standard type so we can actually do this if we include string OK, so what's the difference functionally between these two pieces of code? Yes? [Student answering]
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
ok so they used memory differently right? they used memory differently for sure we're gonna spend most of our time talking about that but what about functionally? are they the same functionally? do they do exactly the same thing? yeah? exactly! one of the, heh I owe you, nathan alright yes, one of them is quite certain of its greeting and the other one's a little, little insecure about it alright exactly but it's worth pointing out, and of course it's the point of the whole thing that they use memory completely differently so i wanna talk for a minute about how they use memory ok so the example on the left the example on the left sets up variable s on the, what is known as the stack. it is stack memory and its data structure, the structure, the way it behaves is like a stack! so this is actually an implication in, or an introduction and foreshadowing on one of the first data structures we're gonna talk about suffice to say, a stack is something that you put - you stack things up on it and it grows upward and the only place you have access is at the top okay? so this is gonna be very simple, we don't have a lot of things to put on the stack, but, uh, s is going to be one of them okay? s together with its value below is set up on the stack and then we output its value, you know this tells us our greeting and then when control passes back that is, when we finish execution of the function and we pass control back to the calling function guess what? it's the nicest thing! the system says oh! you must be done with s! I will get rid of it for you!" okay? that's what we mean when we say that the system controls the use of the memory, the allocation and cleanup of the memory, okay? so now lets trace through the other one uh, again, we make the simple function call, as we make the function call, variable s is... ... set up on a stack! it is! s lives on the stack, its type is a pointer type its value is determined by this assignment statement which is the return value from this new function so the way we denote that is like this: okay? and now, the value of s becomes hellow uh oh uh, we output that we say okay, it's time to get ready to go home", so we delete s, which frees this and then we return control back to the calling function ok? and what happened then? s, which is a pointer variable, is cleared from the stack for us. okay? so s is a stack variable, we declared it. right? the memory to which it refers is not we had to put it away ourself. what if i hadn't said delete s? i woulda had a memory leek, good. very good. because we would then... s would go away, and that would have been our only access to that new space ok, which of these uh, do you think is faster? which of these, which of these pieces of code do you think would execute faster? yes, the one on the left, that's right. if all we have to do is deal with stack memory, then
We get faster execution. Right. One on the right really does have extra work being performed . Any questions?  So, we prefers stacks memory when we can.  Alright Let's keep going. So the most of what we have been talking about today refers to primitive type. So I want to spend a couple of minutes talking about pointer as it relates to user-defined types.  So I created a new little class appear. it has three private variables. Name Picture, and Boolean function to indicate if it gets done or not. I don't even know what that means I guess I could ask you. Are you done? Tim are you done today? You are done attribute is true. But we are not done So I am gonna keep talking Alright So now, question is what is the behavior when we are talking about objects. Let's review that happens if there is not pointers. Here is a little bit of summary. We have face A and face B declared. And I am going to initialize B. Raise your hand if your name starts with B Okay What is your name? Brian. Okay . B is Brian Your picture, Are you smiling Brian? YES now he is.  There is a picture. Brian are you done? So true.. Now What we are curious about. what happens when we do that assignment statement.. In C++, it's so awesome A member-wise copy is made of the object.  So,  Each of these members are copied as it knows how to copy itself. So string knows how to copy themselves. Part of string class definition, we will talk about it later. And so Brian's name is copied to the space P and G knows how to copy themselves. Know every pixel associated that P and G copied over presumably that is how it is done Similarly, copy booleans are super easy. And now when we refer to a dot set name. We are referring to that memory location.  Presumably, we can change A's name and Brian look alike, but they are not. Any question about that? Anything surprising or issues? Let me ask you this. How long does this take. Do you like this? You know, it is kind of unavoidable. But copying pictures might take awhile So there is that issues. But otherwise, that is just fine. Let's contrast it if we have things to do declare pointers instead So we have face pointer C, and face point D. Raise your hand if your name starts with D What's your name? David. So we are going to initialize the value of D, David and are you happy? Yea, you are happy and you are wearing glasses. Okay. And are you done? Yes, you are done. And that means D's values are pointing to it.  So presumably D equals new face.  * dot set name david is etcetera Now we are going to do C equals D So C's pointer points to same thing D does.  C gets the value of D And now, when we say C set name to Carlos.
and then we say d getname(). We have been effectively change your name, David. I will forever think of you as Carlos. Okay. Any question about that? You should have a question because I completely slid over something. Let's talk about this one first. This says deference the pointer until you get the object and then call one of its member functions. So that seems to make sense. Right? Deference the pointer and use what a value gave us. Get name up there and there it is. Okay. This one is just short hand for that. I do not about you but I hate typing parentheses and apostrophes.  So this is just shorthand or exact same thing. Syntactic sugar they say. So this is different syntax. Or explicit  deferenceing. Alright. Arrays. Title of today's lecture is arrys. Shall we start? You hold your breath. Class will be over, lets see how long you can hold your breath. Alright, you can go. [class ended]
And then we say deget name weve effectively changed your name david I will forever think of you  as Carlos Any question about that? You should have a question As I have completeley slid over something The heck right Ok so lets talk about this one first This says dereference the pointer Till you get tot the obeject and then call one of its member functions
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
[BLANK]Blankd
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
(no sound) (no sound) (no sound) (no sound) (no sound) (no sound)
 To begin, that when I sent this email last night, I was surprised to send it to only 700 students So I think there are actually must be room in this class so if you know of people who have been trying to get in and they given up, you should let them know that I think there must be seats available Hmm by Friday 5pm today is the add deadline is Nooo? I dont know Alright cause you know really what's the difference between 700 and 750 Ok, let's work I have no announcements for you except to say you may find weekend office hour to be useful But I wanna encourage you to check the calendar before you actually go to weekend office hours cause Im not gonna demand that course staff be quite as religious about attending. They are gotta be allowed to change their weekend office hour More so than they will be allowed to change to change their weekly office hour so before you go to office hours especially on the weekend, you should check the calendar on the course website which is now updated with all of the office hour information ok? Are there any administrated question before I actually start here today? Questions, issues, complaints that you'd like to make publicly ya? Will there be office hour Monday? Ya, I believe we are committed to staffing the office hours like 9, do you mean open lab hours? Like to get help with your MP or do you just mean you want somebody to talk to? Ya, I believe there will be office hour 9am to 11pm everyday going forward with a few gaps here and there Oooooooooh, Monday is Labor Day I don't know the answer for that, I haven't asked them You might ask them on the Piazza: Hey Monday is vacation, is anybody gonna be there Sorry Ok Lets work! C++ academic calendar Ok, hmm.. So you know this class will not be very interesting if we didn't have a way of re-configuring memory into contiguous blocks that we completely understood so contiguous blocks that we have a model for are called arrays so programming gets a lot easier when you have an iterative way of referring to pieces of memory so that's what we are gonna talk about today! Finally, we finally got to this point  Now arrays in C++ are not so straightforward as say might be in Java say you have an array class and you just make it Hmm, eventually we will get to the point where arrays are handled gracefully on our content but I wanna pull back that the current the curtain a little bit and show you what you speculate on kind of how arrays are actually implemented Ok so arrays fundamentally there are fundamental kinds of arrays, the first one we are going to talk about is static array when I say static array  I mean that once the code is compiled, that array, that specification for that array is not going to be changed there is nothing dynamic about it the minute you say you want your array to be size 5, you are signing a contract for it effectively  it's a commitment to using memory of that size OK, so here's what happens In stack memory, and there's the syntax right there, the type and the square brackets that you tell the number that you want In stack memory a sequence of that memory variable is set up so I am gonna do this by you know grabbing 5 pieces of memory, all of them are integers
Okay. They have a location. Chosen for you by the system. Location is always chosen for you by the system.  In the stack, it sort of next available space. And the name is there explicitly given. X zero , X (1) , x(2). Do I need to keep writing? Upto X(4). Okay Of course, their values are garbage.  Alright, any question about that?  Okay, Now, again. That memory, the size of the memory cannot be changed. So, it must be known at compile time. If you do not specify a size. Or if your size isn't in the variable, system cannot figure out. Some big block will handed to you that is irresponsible request of the system for your stack. So, you want, if you are using static memory, if you are intending to array on stack, you need to be able to specify how big it is. Don't let it be flexible because it will be too big and you won't know how big it is. So you won't know how to walk, how to avoid walking end of its iteration.  So, nice small arrays are perfectly reasonable to do only if you know how big it should be. Now, think of all situation where you don't know how big array should be. Any time the size of data is changing, can change, you don't necessarily know how much memory you are going to need, or contain needs. So, we have this contrasting idea of a dynamic array one which you can resize to whatever size you need Here's how this works. You set up x as in integer pointer in the stack, so ops X is somewhere in the stack. It's an integer pointers so it has something that needs to be allocated and then when you ask the system for a memory. you say, YO, I need three integers from the heap And the system goes out define you just a right amount of space. Just right amount of space. Returns memory address which is then what stored in X. Now, Here is the cool thing Here is the cool thing: the syntax referring to the memory, is exactly what you expect any old array that is square brackets find the right element. For example, I can execute for loop that says take i from zero upto size.  And put i + 3 in position in sub i. Now where is X sub of i in each case? This one is x zero, this one is x one, this one is x two. So we end up here, here is three and four and five. Any question about that? Alright, I want to give you another thing hang onto. Another thing to justify is to use of pointers, as the way creating things. Look at the syntax for second. Here is how to think of it. The square bracket is like a D-reference So X de-reference and then i steps forward Okay, Got it? So it's x de-reference i steps foward and that binds you the memory location Wondering if pointer arithmetic applied here, Yes you can use pointer arithmetic to find your element of array. But code would be unreadable and go head and use square brackets.
Any Questions, About it? Alright, Alright fine..  Then to remind the system to tell the system that uh you want to free or get rid of or  I would give back to the system for reallocation a block of memory, you put the square brackets here ok... I believe the compiler catches if theres incompatibility If you used square brackets up here but you didnt use them there, I believe clang catches it Yes? Sure? What? Yup you can still use square brackets, yup, if you've used square brackets in your declaration or in your request for space If you've used square brackets in your new statement, you can use square brackets  to find your elements of your array, Yes? Um, if you go passed it, probably a segfault  okay? Its not as, it doesn't know exactly what you're trying to do, but you probably going to access memory that isn't allocated there, okay? Yes!  Ahhhhh okay, so the question is, well that looks kind of static right? We said how big we wanted it to be and we asked for it and how do we change that and the answer here is we explicitly are going to ask for the larger space, so if all of a sudden we decided we needed 3000 of these integers instead of 3, our algorithm- and well talk about this explicitly later- but our algorithm is going to be to ask for 3000 copy the values over and then we've got 2997 extra okay? So that's, that's our  algorithm here, there is We don't use a graceful way of extending the space cause we don't know what the heap looks like, we don't actually know if there is space to extend. Right? Alright, uhh, lets see, one more thing I wanna say here, umm, that will get at your reasoning about this, My question for you is simply What happ, jeez, you guys are gonna like get whiplash, ouch Uhh, what happens if you say cout, uhh, the value of x What're you gonna get? Yeah? Ohh, you would wish right?! You wish it prints the whole array! Optimistic soul, thats a rep reflection of an optimistic soul What do you think it does? What? No. Yeah? Yeah? Only the first value, thats right! If I covered up If I covered, If we weren't talking about arrays and I covered up all of this, then this cout statement would say, find your variable x of integer pointer type, right? deference it and show me the value thats there, the value thats there is 3! So thats what we would get Now, would we ever do this? That would be weird, instead we would do Cout << x[0]  << endl because after all it is an array Okay? Any Questions? Yes! Where? Here? Oh! So his question is, his question is, you don't have to dereference x, x is the pointer. And my response is I did dereference it, I did dereference it! That Square bracket is a dereference and 0 steps forwards Okay? So, yes I do have to have dereference it, I did! Okay? Alright, did question, any other questions? Yes? What does the delete statement do? What do you hope it does? Gives back the entire array to the system to be used for future allocation! Okay? So the next time somebody asks for some, yes? Ahan, what did you say?  If I had 2x as the address of x[1], oh boy so that would be, ummmmm,  The address of x[1], like this, probably You don't usually have a reason to do that, You are usually interested in the values on the heap, okay? But, That is what you would do its still just a way of referring to that block of memory Okay? Alright, how are we, yes?
in the what?  um no Those are static variables  those are stack variables they're all  I mean you know they are memory addresses going on all over the place but it is not instructive to think about these guys as memory addresses they are stack variables they are not going to have memory on the heap that keeps track of them ok> right its still... right right there is no explicit pointer it's ..... Yes, thats right yes it just keeps track it keeps track of how much memory is.. it keeps track of size of x basically it keeps track of amount of memory associated with that so somebody who speak C tell me what 3 does what parameters are associated with 3 what parameters are associated with the three statement cuz this is like malloc free right? ok nevermind it keeps track of amount of memory for you uh hum yep there is a lot of steps going on behind the system the scene a lot of stuff behind the scene we clearly speaking something that is almost English right? and the processor doesn't understand anything close to that yes? so the question is what happens if we just do delete x here I believe that clang catches that for you at compile time I think thats true it used to be that if you say delete x there only that first one would be free but think now it is detectable at compile time alright. yes? no malloc doesn't But but Null does. NULL and free do yeah you know C still works here you can still ask for the size of your variable yea Yes yes yes yes so if you speak C++ already if you familiar with the C++ standard library what we are talking about now is under the hood of the vector class yes yes yep yep yep vectors live in the heap yes so the question is if it is possible to partially delete the block of memory and anytime anybody asks me questions in C++ starting with is it possible to the answer is yea probably but the more relevent question is should you and the answer is probably not so it was a ... we thought it was a straightforward conversation but it is always kinda (knew oddsed??) right? yes do you need to set the values to NULL before you delete  no\ is it a good idea to do this ? after you delete  Yes yes but you know when you are talking about values no problem dont get cocky with your Microsoft device thats just crazy I'm sorry okay if you are talking about reinitializing these values the answer is no you don't really have to you don't have to clean them up they are just going to go back to memory and the next allocation is responsible for initializing them the way they want them to be okay? alright. can we move on is that ok? yes
What do you do if you want to copy a static array? You just assign do the assignment Okay What do you do if you want to copy this array Oh we're gonna talk about that a lot Okay so I'm not going to spend a lot of time talking about this problem I want you to make sure you understand how to do this  because I think you can puzzle it out. I would love to see a discussion of this problem, um, on the Piazza, so here's the setup: I have declared, I have declared a double pointer of flowers, so I want you to assume that flower is a user defined type You can imagine how that would be true, I've defined class flower and I'm defining a double pointer to them Now I'll give you the first one here This could be a pointer to a pointer to a flower. Right? So it could be the memory address of the memory address of something that is a flower type. A box that contains a flower Or, what else could it be? Somebody give me one other thing it could be now that you know another use for pointers. Very, uh, close It could be a pointer to an array of flowers , right, because it's the array part that eats up one of those pointers. I don't know how to make flowers. There. Those are flowers. Yes, yes. Oh it could be a two dimensional array right. So here's what I want you to do, I want you to figure out the other couple of these, and moreover, I want you to write a few lines of code that look about like this that set up that memory, that ask for heap memory. Okay? I want you to think about what it looks like both to allocate and delete,free up, put away, finish using memory that is declared like this. And I'll give you a hint about this.  This is actually an important exercise because one of them - the array of flower pointers - is actually the substance of MP2. It's probably the hardest thing to wrap your head around in MP2. Alright, any questions about this? Yes So the way to think about this is that this one is a pointer and the rest of this is an array of flowers. No, an array of flowers. If it's a pointer to an array of flower pointers, I need three asterisks, three splats, who taught me splats? Three splats I'm gonna let you puzzle over it. you need to and you will and you'll unwrap your own model for this, okay? And we'll talk about it more, but not right this second. So I'm not gonna say the words 'Are there any questions'. There're supposed to be questions. Alright, so we're gonna move on. And this is actually the beef of the day. This is the beef of the day. So C++ handles parameter passing in important and different ways than you might be accustomed to if you come here from just about any other language on the planet, okay? So we're gonna spend a good amount of time talking about parameter passing. Now what do I mean by that? I mean when you have a very simple little piece of client code, like this. What happens when you declare a student, make a function call, so I have a function call, when the parameter gets passed into the calling function and then executed upon, what happens? What happens in memory, k? Now, the discussion of what happens when control is passed back to the calling function is a discussion about return type and I don't think we're gonna get there today. I think that's a discussion for next time, k? Alright any questions about that? Is it clear what we're gonna be talking about? Alright I think that you should have a question about this slide, cause I think that there's something new there. For some of you at least
Yes here? not that's not. that's not printed then printed, the code is  intended to be pretty simple what the hack is the struct?  that's right notice here oh oh what is it look lot like? if you kind of squeeze you eyes, what does it look like? the struct is a class struct by C++ compiler, struct is interpreted is a class where all the members by default is publioc exactly the same thing, why did I choose struct in this case? because I want to save screen space and I only have data associated with it, I have no function, and so it will be familar to somebody who speaks C yes you can, you can define functions, the c++ compiler will do the right thing with it so if you take c code and you put it in C++, you know, you can mess with it nathan? speaking somethinbg em a boy using typedef because you are using a class oh yeah you can just use it directly, but you can use in C too, right? ok I will look at it and make sure I answer correctly but suffice to say you can do this it's fine and use it just like a class ok alright any other question about this? ok alright we will look at the details of what's happening here this is largely replication of, look at you flip the page, we are like flying through the lecture today all the knowledge so this is largely replication of the examples of previous page and I an gonna tell you some vocabulary associated with parameters passing in C++ by default parameter passing is pass by value so default C++ is passing by value and here is what that mean it means when you set up student A they have a name they have a picture and they are not they are gonna be initialized to be not be printed ah ok, here is what happens when we make a function ncalls we gonna make a function call to print student one of A look inside the function, A is interpreted as s here is what really happened, s is also set up like the local variable on the stack and value of A is copy in to the new space on the stack allocated for s so string know how to copy themselves so n gets copyed over, PNG knows how to copy themselves and boolean know how to copy themselves so we have completely independent copy of A in the stack for s on which to operate we can write code looks like this, if its not the case s is printed, then output the name and here is what  em here is what we cannot do we could do s.printed = true here what's the problem with that
what thats right thats right i only set the one in the fucntion right so i have made note of the fact that we printed s yay good job and then  we go we return um the control back to the calling function and s goes off the stack so we have no record of the fact that we had printed it thats why in this code we return a true and we grab it on the outside and if we had hoped to change it we have to change it in the scope in which it exists alright any questions about that is that clear and thats default behavior ok and thats passed by value no questions you're good? ok lets do something different so this time instead of a student i have a student pointer b im going to set up b in memory so in this case right here i have for sure b=new student somewhere and maybe theres a param i dont know what constructors exits for this puppy bu I have set up b so its has value ben a smiley and not printed now when i when i make a function call here to be or with b as a parameter print student 2 has to take what what kind of thing must if take a pointer thats right the types have to match so this has to be a pointer  in that case what happens is  the variable s is set up on the stack as a pointer  and b's value is copied into it b's value is copied into s if you had this slide what would you draw to reflect that b's value is copied into s yup very good so s now  draw an arrow pointing to the very same memory laocation because their value is at the same memory location ok you good and now we operate on s i want you to spend about thirty sec finishing that code so that the output of this function call is  a ben so spend about thirty sec filling in the blanks effectively that would ummm make this thing print out ben oh you can yeah like i have there so  you need to finish that code or debug it if you want to use a different syntax youu're asking me exactly what im asking you ok to fix up this code yea yes yup yup but not for static arrays static arrays are all in the stack do you want to use them for smaller things ok how you doing alright so what should the conditional look lilke what should the conditional look like i left a space there whats goes in it
 can someone raise their hand and talk to me? I'm feeling kind of lonely.... YES, what goes there? [someone answers inaudibly ] yea, good. splat is splat. I'm gonna use splat on the exam yea.. k and i'm gonna do this to be explicit k... I probably don't need to but, ima be do that to be explicit so... de-reference S, and then I can get at it's value um as......asssssssss you might have noticed heeeeeeeree, you could equivalently use S printed..... to accomplish the same thing k, it's exactly the same just different syntax  Okay! What else do we need to do? how do I print out the name? de-reference, good, thats all- i just needed to hear somebody de", and I was good ok fiiiiiiiind and theeeeeeeeen yea, guess what I can do I can do, S printed is true here and this changes to true YEA and am I done? I should probably return, just to let people know that I know I'm finished  K, any question about that? Yea? [someone asks a question] um because of, so the question is why don't I have to write return true? and the answer is because this function has a different signature here it returns void my purpose for returning true last time was passing back the result of the computation here I didn't have to k? alright yes! [I guess someone is asking a question] uhuh...........yahuh [mumbling] uhuh....... yea ...............um, they are if you use parentheses correctly and there is a complexity in the mp because of the overloaded parenthesis  so for the png class, it's a little wierd and we kinda want you to, we kinda leave that there on purpose just to have you, have you untangle it sorry... OKAY! so are we done here? are we done????? ............. Yes???? .............. very good!. okay! so notice that  we cannot forget that what we are dealing with here is a pointer what we're dealing with here is a pointer so this needs to be de-referenced here as well kay?... now let's contrast the previous slide and this slide kay? who's..... so this is a popularity contest  who's speed do you like better? who's speed do you like better? which is faster? previous slide by value? or pointer by value, sorry this is pointer still by value, it's still, it's just pointer by value which one do you like better? speed wise? [space] pointer by value. thats right! passing a pointer no big deal it's this little teeny tiny representation of a memory location right? whereas in the previous case that picture, copying that picture around, bad idea kay, even if you..... even if it's super fast So! this is FAST alright fine. who's syntax do you like better? who's syntax do you like better? this one? or this one? it's like an eye test, left, or right? [pause to let people laugh] yea, le-hehehehehehhe right!... wait, left okay so the syntax here is better this is cleaner code but uh, so this is a comment on syntax but!... here's the thing... it's also safer to be dealing with; your less likely to make memory mistakes if you can refer to things that live on the stack so actually the stack variables make your code less likely to be buggy so it's much much much more than a pretty dress it's the substance of the quality of what you, what the code you create so code that uses fewer pointers is less likely to have memory errors kay? any question about that? so I'm going to say it as safer here especially for us mkay.... alright any question about that? is that good? so which one better? [pauses for dramatic effect!] probably the second....... [silence].... sighs well somebody is paying you according to how fast your code works well here's the thing, in C++ you don't have to make a compromise between the two so let's look at the third way that parameters can be passed this is called, pass... by... reference [silence]
Okay, so let's trace this code for just a second. um, notably, I'm declaring a student. I am declaring a student, raise your hand if your name starts with C.  Yes, what's your name?  Crystal. Is that how you spell Crystal?  That's one of my- you know how everybody has a word that's hard for them to spell?  Shouldn't there be an h in there somewhere?  But no.  Okay. Yeah. No.  Like Christmas, it's almost like Christmas but not. Okay. 'Cus that's gonna be on a test.  Alright. Uh, Crystal you're happy and you have not yet been printed, yes?  I'm sorry to impose emotional status on you but there we go. Okay, alright, so now this is a student in the stack and we give it value just like we normally would for this thing.  However that user defined type allows us to do so. In this case, it would just be c.name = Crystal, etc. Alright, so now let's trace this, we're going to call a function whose name is print_student3. It has as its parameter a student reference. Okay. Slightly different. Now, here's what we mean by that. We mean  take wherever s is set up wherever s lives, whatever s is, and rename it to I'm sorry - c - sorry - wherever c is okay, wherever c is take it and rename it as s okay, so give it another name which is s Okay? Now, when you write this code, if it's not the case that S is printed is it printed?  is S printed? No Then, uh, output it's name.  Can we refer to its name? Yes. That's Crystal. And moreover we can use s to refer to the contents of c so we can say s.printed = true here Change this to T. Okay? And when we get back out here what do we get? True Alright. Any questions about it? Yes? yes. And usually we will actually. Okay, there's not the uh there are software engineering issues here with changing the value of the variable underneath it within a function but we're not talking about that here we're talking about mechanics Yes? It's an ampersand before the s, yes that's right yes? Why don't we have to ampersand c? c is a student c is a student okay raise your hand if you feel uncomfortable with this because you feel why can somebody articulate why very precisely why you feel uncomfortable with this.  yes? Yeah, so it looks like a type mismatch right? it looks like a type mismatch. so two things to say.  number one the ampersand used in this context is not the address of argument you should not think of it that way, okay? you should think of it as a flag passed by reference number two the apperance of a type mismatch is to be overcome so take a few minutes and do some meditation and get rid of the of that feeling of type mismatch okay because in this context it's just a flag now what's really happening I shouldn't even tell you, right? yeah I don't want you to clutter your mind with it, but I will tell you. Yes? is it functionally different than passing by pointer that was exactly what I was going to say and the answer is no it's the same effectively effectively you are pasing a pointer but it's the way you refer to that variable thats different okay so the speed the cost of passing by reference is the same as the cost of passing a pointer by value but the syntax of it is completely different and so you're much less likely to induce bugs imposed by  the use of pointers when you write code like this okay any questions about that so this is  as fast as pointer passing but without the syntax complexity
of pointers, class. And there's one other teeny teeny tiny issue here. It's subtle. and it is a potential bug here when we pass around pointers. I'm gonna write a little piece of code and you're gonna respond yes? right. If you pass null pointers to that function, what happens? It's a segfault, right? so how would you fix that if you were writing that function? You'd have to put a conditional there, right? and you'd have to handle the issue if it is a pointer. So, another advantage here is that it's as fast as pointer passing without the complexity of dealing with pointers but also it can never be nulll it always will have a value So this is like a pointer that cannot be null So we love it ok. So i'm writing in red. alright any questions about that? no. Nope, so the question is all about the heap None of this involves the heap All of these parameters are set up in local memory, ok all are in stack memory. Al All the parameters are like local variables. They're like stack variables So nothing happens with the heap as you pass the parameter. Now, this could have been This could have been, let's see, this could have been asterisk c, and then we pass the address of c in which case, that memory location would be renamed s Right, the memory location would be named s and we could refer to it directly. Alright, any questions about it? Oh look at us, it's two more minutes Alright, so there's one more little tiny piece and we are gonna spend most of next time talking about it but there's one more little tiny piece that I think now's a good time to talk about it because the issues are analogous When you return control, that calling function. That is, when you say turn something, all the same issues exist. You can return by value or you can return a pointer by value, or you can return by reference. So the mechanics are effectively the same and next time we'll talk about the consequences of that fact.
Okay my clock says its a 11 o clock so let's get going. Umm. You haven't even asked for it yet but Im giving you an extension on the extra credit portion of mp3.  On the website it says its due on the 22nd and I just said that on the slides it was due on the 25th so we will go with the 25th. Youre welcome. I'd like to say anytime but that's not quite true either. We have more printouts coming so if you don't get a print out they'll be there. I swear I alway sprint out enough and they disappear I don't know who s taking these printouts who wants them. Maybe its sabotage. Okay so mp2 was due last night yes? Okay it was. Does anyone know how long the queue was? 66 people. Yeah no no. So that's like 10 percent of the class was on the queue. Can you guess how I feel about that.  So that says is that 10 percent of the people were working on the problem and got stuck so that means even if a higher proportion of the class was working on the mp at the last second so that just breaks my heart. Umm. Because its so fun you want to do it early. So here's the thing, I can't promise you that the queue wait times will improve. I can't promise you that. Now do you see how meta that was. Because if I say I can't promise you the queue wait will improve then you wont count on it and youll go earlier in the week and spread out your requests and then the queue times will improve.  So there's this kind of thing going on there. So I refuse to promise that the wait times on the queue will improve. There should be huge incentive to start early and finish early. I think course staff is most broadly available at like 9 o'clock in the morning or 10 o'clock in the morning. Think about your fellow students schedules and plan accordingly. Its this interesting problem right? like the flow of the crowd. We do try but 60 people on the queue is an awful lot of people.It was bad monday night too. Oh the other thing. course staff actually asked me to tell you that you have now have two labs whose focus was debugging so they are exerting you encouraging you to try to be a little more independent. When you run into a problem. Instead of just putting your name on the queue go ahead and be a little more tenacious than a month ago in trying to figure it out yourself that's going to be a valuable skill in going forward.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               There's already an important typo on them. So we'll leave it in red. This MP is due the 15th (tuesday night) Ummm and thats really my only announcement at this point. And then otherwise the errors in the slides are going to be minor, so I'm gonna go with it Okay. Let's see. So I haven't seen you in a really long time. Are there any administrative issues? Did anybody get a grade report from the extra credit last night? Have you looked at your SVN and it was there? Okay I have reports that some people didnt, so I'll look into that. If you expected an extra credit report from last night and there isnt one in Svn the first thing I would recommend is to go and refresh the page and otherwise I will also be looking into it to make sure that the entire run went successfully. I think it has to if anybody gets it everybody should My best advice is to reload the page. MP1's rerun: I'm not sure whether that happened last night. We were going to rerun MP1 one last time and I don't know when we;re going to do it, but suffice to say it'll happen at the end of the semester. Raise your hand if you're going to the career fair today? Yeah look at that. cool.
Its a good one I like it its fun I see lot of alums when I go there.  I do not go very often because I have a job. Alright [pause] So we were talking about code and C++ behavior upon parameter passing and we has just concluded last time by mentioning that all the cognitive that we talked about parameter passing where also true about returning control from a function to the calling function  So what we are talking about here is what happens so take a look at this client code, what happens when that call is made. Last time was all about the parameter passing and this this time its going to be after the function concludes what happens when you pass control back to the calling function. Now there was some keywords that come about in the discussion of parameter passing that sort of described the different ways that were interesting. We can pass parameters and that was O those forget that this says return by and remember back to pass by. and the words are the same. So what were the different ways of passing parameters? Do you remember? Value. Good! Value Reference  and pointer by value. Now that whole discussion was kind of a bridge between passing by value and passing by reference because the behavior of the system and whats happening behind the scenes is the same as passing by reference but reference gives you simplicity and some cleaner ways of stating your intentions. So this is a pointer by value Ok and you should kind of review the implications of each of those and syntax.. OK well like I said all the same things are true for parameter passing is return value and we are going to spend the first part of today discussing some issues there and kind of reminding our selves what those terms mean. OK So here again we have a little class a student and we are going to do some similar things like we did last time. Here is some client that is code that uses a student and it makes a function call one thing that guess I never said but now is a good time to say it, is that in C and in C++ , you can write functions in the global scope That is functions do not have to be class memebers They do not have to be associated with the class. And suppose all of these examples have exploited that fact.  Ok So we are going to initialize a student C and we are going to set up a student C in the stack and declare a student pointer D.  So I am drawing the wrong picture for C. Look I learned something new. When I initialize a student C, it has some fields associated with it....[pause] Cat.and the Cat looks like that. and the cat has not been printed.  and then what I am to do is print C and return a value. Ok so send C to the print student function and return a value from it who's type is a student pointer. Ok Alright so let's go and do this. When you pass a parameter in its by value so this one is called C and this one called now called S and it copy is made  Looks just the same Furthermore when we declare another student here there is a lot of gratuitous nonsense here. I understand that but its kind of to make a point the next line student w. declaareds a w and assigns the vlaue of s to it not yet printed ok and then we are going to process it like we did last . has w been printed? No so we cout the name and change this to true and then what are we returning?
The address of w. okay? The address of w and then, so, this right here, this eventually becomes the address of w.  This function call is sort of replaced by return value. Right? In the flow of the program. Then we assign it the value of d. Is this syntactically in type wise correct? Is work okay type wise? Yes, it does. 'd' is a student pointer 'w', this is the address of the student, those are the same thing. So type wise this works fine.  But let me ask you this.  What happens to 'w,' the second we leave the function? What happens to 'w'? Yeah? That's right!  The system does you a favor.  It clears the right off the stack.  Boom boom done.  Right? So 's' and 'w' are effectively gone because they were local to the function.  So what about the address of 'w'?  How do you feel about the address of 'w' out here in the calling code? Daaah!  Right? It's no longer valid!  Now will it work? Will this code work?  Most of the time, maybe? It's probabilistic thing.  You are rolling your die here.  So, the point of which this assignment is made, the point of which this assignment is made relies on the 'w' that is no longer in scope.  So, but, 'w' is not in scope.  So this is a horrific bug.  Why is it horrific?  It's worse than insidious.  Why is it horrific?  Because it might work a lot of the time you probably won't get a seg fault.  Another parts of, other times, you might get a seg fault, other times you would just get a value that you don't understand because that stack has been reassigned to be something else by some other process. Okay?  Alright.  So what was the error here?  What did we do wrong?  What did we do wrong here?  Yes?  We used stack and we returned what from the stack?  A memory address of something on the stack.  That's right.  We returned the memory address of stack variable.  Now returning that thing by value would have been fine.  Returning 'w' by value would have been perfectly fine.  So if 'd' were instead just a student and we had just returned 'w' here, then things would have worked fine.  That's returning by value, yes?  So the address is memory address.  It's the location in memory.  And, we returned it because there's nothing that says we can't return something of pointer type.  Right? We returned it pointer type.  So that types match up across this assignment statement.  This is pointer, this is pointer.  No problem.  Right?  Except that the thing that we instantiated that pointer with that, is, ephemeral, kind of.  Alright, any question about it?  Is it okay?  Alright.  That's the, that's the warning.  Don't return a local variable memory address, local variable's memory address.  Okay fine.  Uh, let's do something else.  Return by value would've worked fine here.  Returning a student would have worked fine.  Let's do something else.  Uh, let's talk here about... How would you describe that?  What have we done here in this function?  Are we returning a student?
Sort of.. what does that ampersand mean in that case? By reference, that's right. So our intention is to return a student by reference. Okay? Now we'll trace what that means here. Okay, so the setup in this case, oh brother, um here's C: cat, squigly, false. Um here's D: ok? its not initialized, we haven’t taken great pains to initialize it. When we call the function, C goes in as the parameter, S becomes a copy of it on the stack. We create a new one, W, it becomes of that, also on the stack. Okay any questions so far? We mess around with W, we mess around with W, and then we return it by reference. First of all--first question: is there a type mismatch? Oh, it looks like there is, doesn’t it? Is there a type mismatch? The answer is no. It looks like there is, but that ampersand in that context does not mean memory address, mostly. It doesn’t really refer to memory address, it doesn’t mean pointer. It means a reference. What’s the difference? The difference is..the difference is that behind the scenes, pointers are being passed around. But here, in the code, you can refer to everything by its student, by its student value. The dereferencing that happens is all done automatically for you. And in fact, you probably shouldn’t even think about it as a pointer, just think about it as a student. Now, what happens in this case? W is passed back by reference and this thing right here, the return value of this, the right hand side of this assignment statement becomes essentially another name for W. So this is now the right hand side token, whatever the system decides to use for the return value of that token. Right here, this is another name for W. Kay.. and then we do an assignment statement. We assign that to D. Do you like it? Do you like it? Raise your hand if you like it or you see no reason not to. Raise your hand if you can’t-if you can't stand it. If you detest it. Raise your hand if you’re somewhere in the middle. Okay. Good. Why do you detest it? Okay, so you think we’re wasting time there, right? Okay so I hate it too but not for that reason. Okay. I hate it too but not for that reason. Here’s why-you wanna say why you hate it? Exactly! That’s exactly right. So the comment was: it seems like it goes away and yet we’re relying on it. But look, the assignment statement relies on something for its right hand side. But the minute control is passed back so that the assignment statement is the next thing, this is gone. So that right hand side gets obliterated effectively, effectively is gone the minute the return statement is made. Which means that the right hand side has nothing on it to use. Right hand side is nothing but certainly invalid. Kay any question about that? So what have we done wrong here? Can you describe what we have done wrong? I’ll give you a hint. I don’t know, i don’t know what that dance move is. Kay so the error here is that we’ve returned a local variable by reference and that’s forbidden. Okay? Because it's invalid - it creates an invalid right hand side in this case. okay. so our error um.. oh no.. 
 Sort of, what does that ampersand mean in that case? By reference, that's right. So our intention is to return a student by reference. Ok? And we'll trace what that means here. Ok, so the setup in this case -- here's C, cat, squiggly, false Here's D, ok? It's not initialized, we haven't taken great pains to initialize it When we call the function, C goes in as the parameter, S becomes a copy of it on the stack We create a new one, W, becomes a copy of that, also on the stack Ok, any questions so far? We mess around with W, we mess around with W And then we return it by reference First of all, first question: is there a type mismatch? Oh, it looks like there is, doesn't it? Is there a type mismatch? The answer is no, it looks like there is, but that ampersand in that context does not mean memory address  ...mostly. Ok? It doesn't mean pointer, it means a reference What's the difference? The difference is that behind the scenes, pointers are being passed around. But here, in the code, you can refer to everything by its student value, the dereferencing that happens is all done automatically for you And in fact, you probably shouldn't even think about it as a pointer, just think about it as a student. Now, what happens in this case? W is passed back by reference and this thing right here, the return value of this, the right hand side of this assignment statement, becomes essentially another name for W. So this is now the right hand side token, whatever the system decides to use for the return value of that token Right here, this is another name for W. Ok? And then, we do an assignment statement, we assign that to D. Do you like it? Raise your hand if you like it, or if you see no reason not to. Raise your hand if you can't stand it, if you detest it Raise your hand if you're somewhere in the middle Ok, good. Why do you detest it? Ok, so you think that we're wasting time there, right? Ok, so I hate it too but not for that reason, ok? Here's why - you wanna say why you hate it? Exactly, that's exactly right, so the comment was, it seems like it goes away and yet we're relying on it, so look The assignment statement relies on something for its right-hand side, but the minute control is passed back so that the assignment statement is the next thing,  is, this is gone, so that right hand side gets obliterated effectively, effectively is gone the minute the return statement is made which means that right hand side has nothing on it to use. Right hand side is nothing, it's certainly invalid.  Ok, any question about that? So what have we done wrong here? Can you describe what we have done wrong? I'll give you a hint. Ok, so the error here is that we've returned a local variable by reference, and that's forbidden. Because it creates an invalid right hand side in this case. Ok, so our error...
 Ok, got it, ok, any questions about that?  This is really all we're going to discuss int he context of return value, these two warnings. Um, on honestly you are not going to see returning by reference very often. Because you can't return a local variable by referece, you can't return a parameter by reference, because that's kind of the same, I cannot say return s because it's the same issue s is going to go out of scope So what can you return by reference?  What could you return by reference.  What could you return by reference, does anybody see it? it's a little puzzle  Yeah? You could return a global variable, hmm You COULD. Do we know how to refer to global variables at this point? ehhh I don't know! yes, you could return a global variable there because that memory address, that reference is not, that memory that it represents is not going to go away, so anything in the xternal scope you could.  y So if something in the heap you could return it' by reference, the problem is that often times we don't have a name for those things, we don't actually have a name for the values in the heap So it's a little harder ok?  The parameter as it is is like a local variable, ok? But there's a big hint there The parameter as it is is like a local variable, that means it gets cleared off the stack too  Very good! So if I pass something in by reference, if I pass  If i pass something in by reference, then it becomes another name for the value in the outer scope, and so I can pass that one back By reference, here, because then that would mean we're basically referring to c ok? any questions about it? is it ok? Alright. I think reading this and becoming comfortable with references requires just a little practice and the more code you see and the more code you write, you'll become more fluent with it. I remember looking at c code And not being able to figure out type information. Just not being able to do so, and now I'm like boy! It's not that bad! Yes! right, so the error is basically non existent you're only lucky if you get an error, otherwise it's just unreliable yeah  So the question is, when I return w though that reference, what's left on the stack? and the answer is c Basically, the stack is keeping track of it's top and anything below it is valid and when you pass control back  the top of the stack is moved down. Anything above it is moved down below the local variable, so anything above it, any of the local variables are basically invalid memory alright yeah? 
Um in this current example yep right now if I change s.  If I change s to true here so I have an s dot printed equals true.  And I refer to c out heres c value will be changed.  That is partly what pass by reference gets you. Alright any other questions about this?  Alright.  So these are the warnings. Okay.  So we talked about constructors in enough detail to be dangerous.  But when we did so we didnt have a very sophisticated understanding of memory so the kind of objects we made couldn't be very complex. Remember that the fundamental role of a constructor is to answer the question, what do you want the object to look like when you declare it, and in this case rather than a sphere with a radius we are going to talk about what we want the object to look like when we have a richer sphere. So take a look at this sphere.  We still have the radius.  What do you think this business is?  You can use the diagram on the page as a clue. If somebody said hey whats atts?  What type is atts?  How would you describe it?  There are a lot of right answers here. Yeah its a pointer to a string.  Okay fine.  What else can it be interpreted as? An array that is right. So remember that when you are looking at variables, if you see something that is a pointer it may be initialized to an array rather than just a value.  Okay. So and in fact that is what we intend here.  We intend to use that string pointer as an array in our structure.  Okay so let me show you what I would like a default sphere to look like.  And you can help me write the constructor that makes it so.  It is a perfect review of what happened last time or 2 times ago? Okay so when I declare sphere A here is what I want it to look like. I want it to have a radius of 2 inches and I want it to have 3 attributes.  I am just going down this list checking them off.  And I want those attributes to be a sequence of strings that are red and juicy and crunchy. The default sphere is an apple.  Okay.  Yay!!! Alright.  So how do we make thatn.  Yeah.happe Do I need an array of arrays?  No because this whole thing is going to be A.  This part is not intended to indicate an array.  This part is just going to be a list of these variables. Okay But yeah this yellow part is an array.  That is right.  And we have to use the constructor to make that happen.  I am going to remind you of some syntax here.  So we are going to right this constructor.  I am going to remind you of some syntax. You can use the initializer list to instantiate some of the variables.  Since we are not using user input here for this default behavior it is pretty safe.  We do not need to do any error checking.  So we can say the radius is 2.0 and more over it is safe to say num atts Sorry it is a little weird to say that word.  Num atts is 3 so they would actually be up on the same line.  Initializing this array though would be a little bit more complex. [continues writing on screen]
What is atts? What's the next character I'm going to write? Say what letter I'm going to write next, what's the next letter I'm going to write? Yeah? New, very good Att's equals new string, how many of them do I want? numAtts, very good Now notice these are not string pointers new returns a pointer and that's what type of thing we need This is not a double pointer here. This is simpler than MP2 Alright, so now I have this pointer instantiated with this memory address  Where this block starts in memory And I have this much preserved Each of them for strings But they don't yet have the values I would like. How do I give them the values that I would like? What's the next character I'm gonna write? A, good Oh I did the square bracket for you, okay @ zero equals red" K Can I do dot dot dot yet? K But I like to write 'Juicy K Alright, any question about this, and that's our constructer So, when I declare A, the system says, do you have a constructor you would like me to deploy?" We have said, Why yes we do have a constructor we would like you to deploy" And then the system deploys that code It sets the radius equal to two, numAtts equal to 3, and then it allocates and intializes that array to contain the strings we wanted Umm, so the question is, What's the difference between putting something inside the constructor explicitly Like, the radius equals 2.0" vs putting something in the initializer list And the answer is essentially nothing Using the initializer list is a little bit faster There's a little bit less memory manipulation, but that only matters in very rare circumstatnces The reason I did it like this was to remind you that the initializer exists because we're gonna be using it when we talk about inheritance Take a look here and tell me if anything surprises you What are each of those things? So this is the constructor we just wrote This is one, that allows you to adjust the size of the apple I dunno, because... Maybe you have a sequence of things that you can change based on the user input What the heck? So tell me as many things as you can that are weird about that First of all do you believe it's a constructor Why do you believe it's a constructor Same name as the class, no return type That's a constructor What else surprises you? Two things about the parameter list, I think, should surprise you Yeah, it takes a sphere as an argument and the argument is passed by reference, that's a salient point. Const? What the heck is const doing there. That thing, that constructor is called the copy constructor, and it's what we're gonna talk about for the rest of the day So, what do we need the copy constructor for? The last time, or two times ago, you let me get away with some language, almost I think somebody called me on it You let me get away with saying a copy is a made between the calling function and the parameter You let me get away with saying, oh look, when we pass a into s, a copy is made" Right there at that instant, the copy constructor is invoked for you
Okay, now if you don't write an explicit copy constructor the system will provide you one, and I'm going to tell you a narrative about what the default one give you in just a second. Okay, so one location where the copy constructor is called is when you pass parameters in, that's how by value happens, that's how pass by value happens. Another case that it happens is like this. You are allowed to declare a sphere and then to declare another sphere to be a copy of that one. Okay, so maybe in here you would change a somehow. And this b, the declaration  of b with another sphere as an argument is as close as we come to explicitly invoking the copy constructor. Okay, any question about that? Okay, there is a third use that merits a complex discussion. That third use actually occurs in the first example perhaps. Ah I cannot change my pen color, I'm so sorry, things are kind of broken here. So the question is what happens when you say return s? We sort of implied that the execution is the same between passing a parameter and returning a parameter. But in this case, actually, that copy constructor may not be called, it may not be called. The system will decide whether or not it knows what you mean and in certain circumstances the copy constructor will not be called. So you cannot rely on the copy constructor being called upon returning by value. So let's see, where can I write that? This may or may not call the copy constructor. And the reason for it is simply that when you're returning a value, if you can maintain the data in memory some place, making another copy of it ends up being like an extra copy. So you're code actually executes faster if it doesn't have to make extra copies all over the place and so where it can it will avoid invoking the copy constructor. Alright, any question about it? We'll talk about it more later. We say that the return copy is elided, if you wan't vocabulary associated with it. Okay, so we need a copy constructor and I said the system provides one for you. Let me show you what it does by default. Okay, so let's assume that we have an apple a set up in memory, a red, juicy, crunchy, and we pass a to a function. Here's what happens by default, the parameter gets a new version of a and a member wise copy is made. Now, that's fine, because doubles know how to copy themselves and it's fine because integers know how to copy themselves, they have valid copy constructors essentially. And it's also fine because pointers know how to copy themselves, what does that mean?
The address is copied. now i am pretty sure when you pass by  value that is not what you intend. YOu do not intend to have your onjects kind of be tangled together THe possibliyt of this entablement is why we specify a custon copy concstructor] lets take about what type of value we want instead we want the radius to be copied, and the number of attri we want new memory to be allocated and then the values to be copied so that was a checklist that was one, two, three that gives you the boxes and then four for the values i want you to write thouse lines of code and attempt to work with somebody around you to write those few lines of code in that green box Ill wtrite is slowly here to.  YOu are welcome to peek Ill race you Actually oh no i can do this who wants my tablet who wants to write their solution on my tablet you want to try it okay its okay. Oh be sure to do it a little bit wrong because debugging is a critical skill He writes way faster than me anybody have questions its an array but the way you specify an array is via a pointer does that make sense so this means its a pointer but we are going to build it into an array any questions or anything this is stil bad no audio
 thats called abdication. You abdicated. Was it fun?oh no no one will ever do it again. Ill erase it so youll have it. Okay so while we were doing this somebody asked me a really good question and that was actually there were two questions. Im going to ask them in reverse order. ONe of them was why did he use an arrow on the left side and a point on the right side. period on the right side this is a pointer to the current object.Okay it is not the current object. It is a pointer to the current object or the memory address of the current object. In C++ we dont have to write it inside member functinos. SO i get to erase all of this and i dont know what you guys think but i think the code is more readdable the less text that is there. So that is the style that course staff like to read Now all that is correct we have to explicity assign all of the member variables. Then we have to do some for loop for int i equals zero, i less than num, atts i plus plus. atts sub i equals orig.atts[i] any questions? excellent questions i am glad  you brought it up. Look what he noticed. We have got a function refering accessing a private member of the sphere class. surely that should be forbidden but no because this right here says sphere because we are writing a spere class member function we have direct acces to the private members it is worth pointing out that if we are writing a sphere class member function we have direct acces to the private variables Any time a parameter is passed by value. that code is invoked. Okay. We are not done. OH shoot i think we have to be done. This is such a bad place for a cliff hanger because we have created new memory and we have no mechanism for cleaning it up.                        SO we are just going to leave ourselves in a mess until firday
ssil <silence>
Is the mic working? Ok. I have no new announcement except that is Friday How about the volume now It's still Can you hear me now? Ok I think this is good Alright, so I have no new announcement So let's just start working Last time we were talking about bad thing, bad one right there, I try jump roping last time for the first time in like two decades Cuz my child got a jump rope felt delighted You know, how little generator in I handle thing, and I kind of thought I would gonna die after jump roping.  So I wish I could leave and point to that function signature right there, but you are gonna save me from having to do that  Cuz you are gonna tell me what that is the function signature of, what is that So copy constructor, right, how do you know that is a copy constructor, what did you check in your mind yea, the parameter is that an object of a special type or not of the very sin class So the of sphere in that function signature what tells you it is the copy constructor OK, I have one question for you. Why is the copy constructor's parameter, first of all, what is that pbr stand for?
Did you giggle? You get it right? Are you from Nebraska? Okay. Who else giggled at the PBR? You got it too? Are you from Nebraska? Okay. I don't know. Pass by reference right? Who's from Nebraska? Do you get PBR? It's the beverage of choice. I don't know why. Yeah you go home. I'm from there actually. It might be the beverage of choice here, I don't know. It's like a fancy beer in Nebraska. That's because it's kind of close to this one. Oh man, we don't have time for this. I am so sorry. But here's why. It's close to that and if you're from Nebraska that has meaning. Go Big Red. Right? And it's football season. Okay. Alright, so why is the copy constructor parameter passed by reference. Why is it passed by reference? Not passed blue ribbon. Yes? Exactly, very good. So, think about it. The alternative to pass, oh here we go, I have a brain. The alternative to pass by reference is pass by value. What happens when you pass by value is the copy constructor is invoked for you. But that what's we're defining here, so there's sort of recursive definition problem that exists if we try to pass my value in this context. I encourage you all to go write your own little class and it can even be simpler than this. I don't think you need any data members. Define your own copy constructor and see what happens if you try to pass by value. Why is the copy constructor parameter passed by reference? Because the alternative is passed by value. Peanut butter value. And pass by value invokes the copy constructor. Which is what we're trying to define. So I encourage you to go test it out and see what happens when you try to set up a copy constructor pass by value. Okay, another question. What does it mean that the copy constructor's parameter is constant. So I'm asking you exactly about the present of that constant there. I think we talked about it really really briefly. What does it mean in that context? Yes, the parameter very good. This promises that the copy constructor and the function in general will not change that parameter.
Ok, so orig is effectively constant. Ok, um, last time we saw the, um, we saw that parameter used here. What's the difference? What's, I mean it's not a parameter, that keyword used there instead. What's the difference between using it at the end and using it in the parameter list? Do you remember what it meant when we used it at the end? I'll put a little question mark, here. Do you remember what it meant? Yeah, Nathan? Right, so this time, this time, if you put it here it means that the function will not change those guys, the data members associated with the class. So, it's still a promise that something will be held constant and it's just an issue of which thing will be held constant. Ok? Now, i wanted to spend a second and just tell you how I  happen to read that parameter list in, um, in, uh, English. I read it like if you asked me, What is orig? What type is orig?" I would say it's a reference to a constant sphere. A reference to a constant sphere. Ok? So, orig is a reference to a constant sphere. You will also see in your programming journey, you will see that keyword const here, and in that case, the English makes more sense. We just read it backwards. Reference to a constant sphere. They're just different syntaxes. Uh oh. What's the plural of syntax? Syntaccc . . . I don't know the plural of syntax. They're just syntactically different ways of expressing the same, uh, the same functionality. Syntactically different ways of expressing the same functionality. Alright. That's kind of a meta thing, right? I found a syntactically different way of saying syntaxes. Alright, any questions about it? Alright, so, const will come up. You'll see it in code that you maintain and read. Um, we will also kind of gradually ask you to use what we call const correctness. Now, as, as we ask you to write code. Now, what does that mean? It means that you, as a software designer, should be aware of what you expect to allo-allow to be changed. So, for example, as I define a copy constructor, I'm pretty sure, that making a copy of something shouldn't do something crazy to it like change it to 42 or something, right? And, so, this is a way of promising inside the code, no matter how you implement the copy constructor, that the original value will not be changed. Ok, that's called const correctness. Yes? Though, right, so the, so functionally you could eliminate the const and then just, you know, be a good steward of the code, right? Well, I'm not gonna write any code to change that. But, here's the thing.  This construct allows for, um, delegation of code construction responsibilities, right? So, I can now give it to you to write the code and you are not allowed to write bad code that will change that, that, um, the value on the left hand side. So it's a matter of security, actually. Ok? Now, it sorta fails in some context. This is purely an aside, so, if this does not interest you then it's ok to kind of turn down the volume a little bit. Um, but, it's not a pure, um, it's not a pure security measure, because, you know what? Sometimes, we want to use the copy constructor to count how many times a copy has been made, say. So in that case, and we might want to store that with the object. And, so, that level of, but, but if you make it const you can't allow for it because you can't, you can't record the state change within the object. So, you know, in effect, it ends up being functionally limiting, but it's ok. For our purposes, const for the input parameter.  Um, and in fact, there are many style guides, software engineering style guides, that will tell you that all reference parameters should be const. Ok, so, if you go work for Google, they're gonna tell you that, and you're gonna go, *Gasp* What?" But, but, um, uh, we don't make that constraint here. But, there are principles involved in the use of const. Ok, any questions about that? That was too much for a bridge on my part. I apologize. Alright, here's the big kicker though. We spent all this energy talking about this, um, copy constructor. Whereas, the first thing I said to you was, you know, the system provides one. What was wrong, in this case, what was wrong with the system provided copy constructor, and in general, how would you be able to diagnose for a class whether a custom copy constructor was necessary? So, what about this particular class demanded that we had to define a copy constructor? Yes?
Okay let's get started. So you guys in the back here. Yes, no. Nooooo. How about now, now, now, now, can't have it be a multiple tree. Alright sooo. Mp2 is due tomorrow night. There have been grading runs every night for the past you know five days or so. Uhm its looking like things are going really well. Only thing is I didn't get an autograder message from last night. Did anybody get a result from last night?Yeah? okay. Alright so I didn't get the message, maybe I'm just not done with the mp2. Alright then I want to rest assure, I want you to be rest assured that if you get a hundred percent on tonight's run and try and make a change and you get a 0 for whatever reason some compiler error, we're taking the maximum of tonight's and tomorrow nights. So you don't have to stop tonight with your 92 you can keep trying to perfect it if you'd like. Okay are there any questions for grading for mps at this point Okay so mp3 is going to come out pretty much immediately. If I had to ah assess a relative difficulty of mp3 over the whole semester, I'd say it's not conceptually the most difficult, but you are likely to spend the most time debugging on it, so prepare to spend more time on it than you might on some of the other mps Okay. We were talking about well you remind me what were we talking about, whats a concise way of stating what the subject was last time last friday when we met. Operator overloading and in particular we were going to overload the blank operator. What's blank? Assignment operator, very good. So for example, if I do something like declare, ugh I am just not going to be friends with technology today. Look I got nothing. Here. Okay. If I were to declare---accck.  My family watched ghostbusters last night on the way home from chicago, I'm thinking I'm like set up some poor karma between me and ghosts everywhere. SO if I declare spheres a and b, and create a to be something interesting perhaps, and then make the assignment b gets the value of a, then what the things you told me last time that I need to be sure to do are to free up the space previously occupied by b, the dynamic part of the space previously occupied by b and then explicitly copy over the values of , oops, of a. Okay. And that means that means, that I need to allocated new space that in the end looks just like a's space. Okay any questions about that at all I'm going to seperate that out into two sort of sub tasks. There's the clear task and the copy task. Now the clear task should feel a lot to you like another function that you've written, which one is it. The destructor that's right. The clear task should feel alot like the destructor. And the copy task should feel a lot like the copy constructor. That's right. Now do you just call those functions? No you do not Alright. So there are these two tasks. There's clear and there's copy. Okay. Now, there are some little teeny tiny and we're going to w write the assignment operator to do these two things. But there are some additional considerations that would really only occur to you during debugging, but we're going to be explicit about. So now what I want to know, is what happens upon assignment if b and a already refer to the same memory address? Now this can happen in lots of different ways. It can happen if we've passed something by reference, or it can happen because a is a dereference of some pointer that has some other name so there are several different ways where two things can be referring to the same memory address, can be names for the same memory address, so now what I want to know is what's the problem here, remind me. I think we got this far but I want you to remind me. Okay, yeah? 
Right, so when we try to copy this string array it just copy the pointer value that atts" held, and that ends up tingling our memory, right?  OK, so one way of describing our use of the heap for this string array is that we use dynamic memory. So that heap memory is dynamic memory, and that's makes so that you have to declare and define a custom copy constructor. So, why do we need one, the object uses  heap or dynamic memory. At any time, you have an object that uses dynamic memory, there's a new in the constructor is a good clue  Then you need your custom copy constructor. Ok, you happy? Good? Any questions about this? OK. Alright. So we're not done, because we've got these complex objects We've got these complex objects now that may or may not be declared in the heap, if this is a sphere If this is a sphere, say 'a', then this part of it lives in the stack, and the other part is instantiated to be a new command that lives in the heap OK, so we got this object that has pointers all over the place.  I want to trace a little bit piece of code, and show you where a problem occurs. Or let you see where problem occurs.  So my Int Main"  here declares a sphere, its name is 'a', and we are going to pass 'a' in as a parameter to this function.  Now you know at this point that a copy is made of 'a', cause look we got a good copy construct here.  A copy is made of 'a' on the stack, we got this stoop pointing off into heap memory.  The copy constructor knows how to do that. And I am going to ignore this one for a minute, because it doesn't help with my point at this point.  Now, we are going to do some computation, and maybe ask it to change, maybe use it as an input variable.  Then the function stops execution and control is passed back to just after 'myFun'. So control is passed back to 'main'. Now the question is: what happens to 's'?  When control is passed back, what happens to 's'?  It goes out of scope, it's one way to describe it, and what happens behind the scene when something goes out of scoop? Yes? That's right, it's removed from the stack like this.  OK, what do you think? Yeah there's a memory leak, that's right.  That memory that we asked for from the heap, this memory is leaked, by default.  So we're going to help out the system, we're gonna provide what's called a destructor, for the system to use when removing variables from the stack.  Now, suppose that we have just asked for this memory via a new statement, actually that one up there If I just ask for that memory via a new statement, how would I give it back, and let the system know that I'm done with it?  So my destructor, or the code that I am going to write for the system to use when a variable goes out of stack is just 'delete[] atts;.  Ok, any question about that?  So in MP2, you are asked to write a destructor, but it's for a more complex type.  In MP2, instead of objects in the array, you have pointers in the array, and memory has been allocated for each of them.  So that's what differentiates what I just did here from MP2.  So be aware of that, and that if in MP2 I just deleted this array, then all of that memory will be leaked. That should be some insight for what your destructor should look like for MP2. OK, there's a question. Yes?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
right so when we try to copy this string array When we try to copy this string array  it just copied the pointer value at the held  and that ended up tangling our memory Right okay so one way of describing our use of the heap for um this string array is that we used dynamic memory okay so that heap memory is dynamic memory and thats what makes it you have to declare and define a custom copy constructor so why do we need one the object uses  heap or dynamic  memory okay and any time you have an object dynamic memory that is if there is a new in the constructor  is a good clue then you need a custom copy constructor OKay you happy? good any questions about this okay aright So um we're not done because we've got these complex objects we've complex objects now that may or may not declared in the heap if this is a if this is a sphere I'm going to change this If this is a sphere say A Then this part of it lives in the stack and the other part is in instantiated via the new command and it leaves in the heap thats right so we have this object that has pointers all over the place Show you were a problem occurs or let you see where a problem occurs So my int main here declares a sphere it's name is A. And we're going to pass A in as a parameter to this function  Okay now you know at this point that a copy is made of A cause look we got a good copy constructor here we got a copy is made of A on the stack stuff pointing off to heap memory okay the copy constructor knows how to do that and im going to ignore this one fora minute It doesn't help my point any Now we're going some computation and maybe ask its change maybe Were going to use it as a input variable whatever then the function stops execution and control is passed back to  just after myfun so control is passed back to main now the question is what happens to s when control is passed back what happens to s it goes out of scope is one way to describe it and what happens behind the scenes when something goes out of scope  thats right it is removed from the stack like this   what do you think  yea there's a memory leak thats right that memory that memory that we asked for from the heap right here this memory is leaked By default so we help out hte system by providing a destructor for the system to use when removing variables from the stack suppose that I had just asked for this memory via a new statement actually that one up there if i had just asked for that memory via a new statement how would I get it back Delete thats right So my destructor for the code I am going to write when a variable goes out of scope is just delete atts  any question about that? So in mp2 hold on just a sec  in mp2 you are asked to write a desctuctor  but it's for a more complex type in mp2 ill put this in green Instead of objects in the array you have pointers in the array and memory has been allocated for each of them So that's what differentiates what I just did here to mp2 so be aware of that and that if in mp2 I just deleted this array then all of that memory would be delete so that should be some sort of insight to what your desctuctor should look like  
Yes! right, because those go off the stack, those are free for you, yes?  Um yeah because it's an array. ok you need the brackets because it's an array,  if it were just a pointer, if we had instantiated this, as just a string pointer, a pointer to a word then, you wouldn't need the brackets, you would just delete it, ok so in general,  you're delete should match your news. whatever kind of new statement you use to create the thing, usually in your constructor, you're gonna use a similar thing in your destructor any questions about that? is it good?  it's called right after the return, it's as this um execution completes, and control is passed back to the calling function alright any questions? you good?  oh my gosh, there is so much book-keeping going on for you, we are so lucky, right? like your grandfather, my parents, I shouldn't have said that. Look at me do that! your grandparents in computing my parents in computing, um, they think that life is way too easy for us Actually, it's probably my grand parents, your great grandparents, but they think that computing is way too easy for us when in fact, you know, the fact that we don't actually have to keep track of what variables we're using,  ourselves, is just ugh. we're not authentic programmers, so the early days of C were pretty harrowing, so there's a ton of book-keeping going on, and part of what they keep track is what amount of memory is associated with each variable Alright, and you'll learn about it in future classes because of course that's what generations do, we need to inflict the pain of the pervious generations  alright, um, anyt questions about it? you good? ok, I have another story to tell you here. I'm gonna take you through another little piece of code,  Here's how this piece of code goes.  this time, I'm going to declare a sphere pointer b So here's b, and i'm going to ask for a new sphere  Now, we've made a constructor for a sphere, we made a constructor for a sphere, that sets up a default sphere to look like this so when I say new sphere, that constructor is called for us. so at the end of this statement, it's perfectly reasonable for me to draw this picture Making note of the fact that the sphere constructor was invoked for us.  not the copy constructor, the no argument constructor, any questions? Ok, now, let's look at what happens when we say delete b.  What do you hope happens when you delete b? When you say delete b what do you hope happens? by default.  what do you hope happens? All of this memory, all of this memory is given back to the system, right? by default, without the destructor, only this part is given back no dynamically allocated memory, no memory allocated with a new, is given back so again, we're responsible for writing a destructor that makes that happen, this is the same destructor, it's just used again so if you rememebr that code looked like, this
And it is responsible for clearing up the dynamic array. The rest of it is taken care of. Alright, so I at least, found this a little bit confusing at first, because all of this is the result of a delete statement on a sphere pointer, right? But that delete statement invokes a function that also uses a delete statement. So there are kind of two levels of abstraction going on here. Alright, here's the secret, here's the secret, it's probably the case, so each of these things is a string. How do you think a string is implemented? What do you think the string class looks like? It's a type it has a class, it's just standard. Yeah? Yes, a character array, that's right. Is it a static array or dynamic array? Is it on the stack or the heap? It's a heap, it's a dynamic array. So inside this string class is a dynamic array, or we don't really know, it's encapsulated away from us, but we have every reason to believe it is a dynamic array. So how come I don't have to worry about that dynamic memory? Well I write this, why don't I have to say, Oh wait I have to clean out my strings?" Why? Who's they? So the people who implemented string, that's right. Exactly. So strings clean up after themselves. And look what we have done, we have written it so that spheres clean up after themselves. Right? Now, if you have a class that wants to make a dynamic array of spheres, they never need to worry about it, because when spheres go out of scope, they're just gone. When you call delete on a sphere, it's all gone. No big deal. Okay? So there's multiple layers here of things that work. Alright any other questions about this? Alright, fine. Here are some sort of summery information about destructors. We don't call the destructor, we provide it for the system to use in two situations, when a variable goes out of scope, and when delete is called on a pointer to an object of type "x". And so it's when a variable of type x" goes out of scope. And it's x's destructor is never called.  Okay any question about that? So, it's referring to a class, some class. Alright so now, how do we know if we need a destructor? And the answer is, if your constructor allocates dynamic memory, or if any other member function allocates dynamic memory associated with the object. So it's not just the constructor, but if any, if your object has dynamic memory associated with it, you need a destructor. 
And allocates dynamic memory. Heap memory is equivalent there. Okay any question? And then as we saw, a destructor typically consists of the sequence of delete statements, which means, and the way you handle that is basically to go through your private members and go Hey! Do I need to delete that?" No. The answer is no. "Do I need to delete that?" No. "Do I need to delete that?" Yes. So you go through each of the data members and ask yourself whether or not you have used dynamic memory. It's just a checklist. Okay, questions? Is it good? Okay. One more problem. Let's trace a little bit of code. I'm going to declare a sphere a and sphere b.  Okay so here's a, and here's b. And I'm gonna give 'a' value. That is, I'm gonna instantiate 'a' to be something. 4.8, 3, and black and white", "bouncy", and how would you characterize a soccer ball? Yeah all spheres are round, but okay fine. Whatever, not worth the time. Alright, so now the question is What happens when we do that statement?" What do you think happens when we do that statement? A member-wise copy. That's right. The assignment operator is by default member-wise. So again we have this groaner of a situation where 4.8 is copied appropriately, 3 is copied appropriately, and the pointer value is copied appropriately. Okay so the problem is assignment. Okay so the problem is, assignment is member-wise by default. Okay, so how do we fix it? We redefine what assignment means. We solve by redefining what assignment that. That symbol. Okay if haven't ever seen operator overloading before, I assert that this is not new to you. Even if you have not heard the phrase operator overloading, I assert that you will not be surprised by it because here is what I think. I think that if I write code that looks like this. If I say int a, b, c, like this and then I initialize a and b so a equals 37, b equals 63. If I say that then that code at the bottom is fine, right? Yes? Good. And moreover, I think you will take an alternative. I think if I say double a equals 37 point something, double b equals 63 point something, you're okay with that too. Right? So now, you know that what goes on behind the scenes when that operator is invoked is different in each of these cases. Right? It's a little bit different because doubles are implemented differently than integers, so this plus has to behave differently. And it didn't freak you out at all. Right? You're like Why is she even talking about this?" Well here's another thing that I think won't freak you out. I think it's true that I can say string a equals cat, and string b equals dog.
What do you think happens?  Here?  What do you think happens there?  Cat dog is right  what a minut? how come it doesn't line up arrays, take the character values and line does up?  that would be kind of a legitimate way of  doing addition as well. right? so how does it know  that in c++, how is it true?  that addition  is concatenation?  rather than some kind of numeric operation  how does it know? how does it know that the plus is different there? The plus is defined to behave differently for strings. And it is just a function. So in this case the + is a function that takes to arguements and does something to them. In the case of integers it adds them up. In the case of strings it concatenates undefined. So you already use operator overloading all the time k. Now the question is and and that is implemented in the string class. It's part of the string classes responsibility to implement  addition.  K it decided it would Okay fine.  What about this?  sphere a(5)  sphere b  eight  Let's go back to our stupid spheres. K let's go back to the spheres where there is only a radius.  How should that work?  Yeah? [mumbles (you need to find how spheres are....) of a student speaking] that's right  We haven't defined how it should work. right? What we've got now is a is a sphere and b is a sphere. We kind of want to add them to eachother. The way we make that happen is to declare a sphere class member function.  Who's name is operator+.  k so this a ...  this right here is the function that implements this symbol So we can do it no problem. Alright let's have a design moment. Lets have a design moment. What should it mean/ What should it mean for to spheres to be added to one another...together? What should it mean?  What do you think? Yeah?  Oh let's just add the radii right? let's just add the radii. We could like find the volume and add that together. Kinda makes sense but...but for the sake of illustration we are going to design an addition operator for spheres that simply adds the radius together. Kat so let's do that... OH and  can you speculate on what this thing is for? Can you speculate on what that return value is for?  You have to return one that is the sum. Right?  Okay. And it's by...we're going to return a sphere so we're gonna declare  sphere t  or return  Kay  Amd then we can say  t dot   theRadius  equals uh oh what do we have  what do we have here? We've got... we're defining what happens here.  This one is the parameter so this one is s  so its  s  dot the Radius  plus  this one is the current object K so this plus  is the member of the sphere class so it will be called on the sphere class object and so  the current one is a. So it's just s dot theRadius    plus  the Radius  and then we're gonna retururn t  Okay?  Yes 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
No, it means it's a reference to a constant sphere. Okay, it's a constant sphere by reference. So you cannot change the sphere, so b cannot be changed, and if we didn't want to change a we'd put a const right here. So you can never change the reference, reference can never be changed, once it's associated you can never change it. Okay, let's see, I want to keep going, it turns out addition and assignment are not the only things you can overload. That as of C++ 03 was the list of operators that could be overloaded. I, in my experience, in my programming lifetime, which is, you know, not all that extensive have only overloaded a very few of these. This, certainly, assignment we're going to do, these are pretty common, these IO operators are very commonly overloaded. But generally, you know, you really have to know what you're doing when you overload many of these things. We'll talk about overloading this one also. I don't know, other than that. Okay, but you may see code that overloads all of those things. Okay, what time is it? Oh we have plenty of time. Okay, so we're going to go back now, now that you're comfortable with operator overloading, we're going to go back and revisit the issue of the assignment operator in the context of dynamic memory, okay? The assignment operator in the context of dynamic memory. Alright, let's see, so just to remind you this is the code that we were trying to implement and it is this assignment operator that we want to fix. The way you declare, the way you declare the function that we're going to overwrite is to say sphere. It turns out that in this context it's okay to return it by reference but we won't here because that will freak you out, freak me out, freak us all out, so we won't. And now the question is, what does the parameter list have to look like? Well we want to promise that we won't change this thing on the right hand side.. So we're going to pass back a constant, I mean, sorry, we're going to accept a constant sphere reference and we're going to call it right hand side. And that's it. We'll talk about what goes here in quite a lot of detail, eventually. Okay, any questions? So that's what the function signature looks like, here's what the implementation needs to be. Okay, so what we're trying to do, what we're trying to do is implement b gets the value of a. So here's a, and here's b, and in the end we want b to look like it's own copy of a. Okay, so how can we prepare to do that, sorry, how can we prepare to do that? What do we need to do to make b look just like a if this is b and this is a? We don't get to call the copy constructor, that would be nice, but we don't get to. What do we need to do at a lower level, what commands do we need to run? Yeah? Very good, very good, so in the end we're going to want b to look just like this, right? Which means that I better get rid of this one. Alright, so let's clear up b, we're going to clear up b and then things can feel a lot like the copy constructor. Okay, we, you know, copy a's value over, copy a's number of attributes over, okay now I need an array that is that long. And then copy these values over, okay. So at that point, at that point it looks like a lot like the copy constructor. Okay, perfectly fine. What would be the consequence of not giving back this memory, before we make that copy? A memory leak, that's right. Because the minute we reassign that pointer to point to this space, this memory would just be sitting there, it would have nothing pointing to it. Okay, fine, here's another question for you. Given that, what we have said, is clear the left hand side, clear the left hand side and copy
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
right hand side into it. if that is our algorithm what happens if the lefthand side and righthand side are already two different names for the same space. what happens? it waste time copying it and even worse on that... yes? yes exactly. think about it. we have just said that are copying process is to first blow away existing memory and then make a copy of the right hand side which that pointer is not valid so one of the things that we are going to be sure to do is protect against self assignment because they are already the same thing for one thing there is no sense in making a copy but the other thing is if you do make a copy will destroy the current object and then we will talk about well i will ask you this could be quick we will revisit the start how do we implement that and i will give you a hint by doing this so how do we implement this chained assignment we will start it next time
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
(silence - video playing)
Okay let's get started. So you guys in the back here. Yes, no. Nooooo. How about now, now, now, now, can't have it be a multiple tree. Alright sooo. Mp2 is due tomorrow night. There have been grading runs every night for the past you know five days or so. Uhm its looking like things are going really well. Only thing is I didn't get an autograder message from last night. Did anybody get a result from last night?Yeah? okay. Alright so I didn't get the message, maybe I'm just not done with the mp2. Alright then I want to rest assure, I want you to be rest assured that if you get a hundred percent on tonight's run and try and make a change and you get a 0 for whatever reason some compiler error, we're taking the maximum of tonight's and tomorrow nights. So you don't have to stop tonight with your 92 you can keep trying to perfect it if you'd like. Okay are there any questions for grading for mps at this point Okay so mp3 is going to come out pretty much immediately. If I had to ah assess a relative difficulty of mp3 over the whole semester, I'd say it's not conceptually the most difficult, but you are likely to spend the most time debugging on it, so prepare to spend more time on it than you might on some of the other mps Okay. We were talking about well you remind me what were we talking about, whats a concise way of stating what the subject was last time last friday when we met. Operator overloading and in particular we were going to overload the blank operator. What's blank? Assignment operator, very good. So for example, if I do something like declare, ugh I am just not going to be friends with technology today. Look I got nothing. Here. Okay. If I were to declare---accck.  My family watched ghostbusters last night on the way home from chicago, I'm thinking I'm like set up some poor karma between me and ghosts everywhere. SO if I declare spheres a and b, and create a to be something interesting perhaps, and then make the assignment b gets the value of a, then what the things you told me last time that I need to be sure to do are to free up the space previously occupied by b, the dynamic part of the space previously occupied by b and then explicitly copy over the values of , oops, of a. Okay. And that means that means, that I need to allocated new space that in the end looks just like a's space. Okay any questions about that at all I'm going to seperate that out into two sort of sub tasks. There's the clear task and the copy task. Now the clear task should feel a lot to you like another function that you've written, which one is it. The destructor that's right. The clear task should feel alot like the destructor. And the copy task should feel a lot like the copy constructor. That's right. Now do you just call those functions? No you do not Alright. So there are these two tasks. There's clear and there's copy. Okay. Now, there are some little teeny tiny and we're going to w write the assignment operator to do these two things. But there are some additional considerations that would really only occur to you during debugging, but we're going to be explicit about. So now what I want to know, is what happens upon assignment if b and a already refer to the same memory address? Now this can happen in lots of different ways. It can happen if we've passed something by reference, or it can happen because a is a dereference of some pointer that has some other name so there are several different ways where two things can be referring to the same memory address, can be names for the same memory address, so now what I want to know is what's the problem here, remind me. I think we got this far but I want you to remind me. Okay, yeah? 
Okay, let's get started. Can you guys in the back hear? Yes, no? No? How about now, now, now, now? Can't have it be a multiple of three Okay that's good Alright, um sooo MP2 is due tomorrow night. Um, there have been grading runs every night, for the past, you know, five days or so. Um, it's looking like things are going really well.  Um, the only thing is I get an autograder, an autograder message from last night. Did anybody get a result from last night? Yeah? Okay, alright so I didn't get the message. Maybe I'm just not done with my MP Um, alright and then I want to rest assured, I want to rest you, I want you to be rest assured that, um, if you don't get 100% on tonight's run, and you try and make a change and you get a 0 for whatever reason, some compile error, we're taking the maximum of tonight's and tomorrow night's. So, you can, you don't have to stop tonight with your 92, you can keep trying to perfect it if you like, k? Are there any questions about grading for MPs at this point? Okay So um an MP3 is going to come out pretty much immediately. If I had to assess a relative difficulty of MP3 over the whole semester, I'd say it's not conceptually the most difficult, but you are likely to spend the most time debugging on it. So, prepare to spend more time on MP3 than you might spend on some of the other MPs of the course. Okay, we were talking about, will you remind me what were we talking about? What's a concise way of stating what the subject was last time, last Friday when we met? Operator overloading and in particular, we were going to overload, operator overloading is what I was going for, and in particular we are going to overload the blank operator. What's blank? Assignment operator, very good, okay so for example, if I do something like declare, oh I'm just not going to be friends with technology - look I got nothing. Here. Okay, if I were to declare, ugh, ack. d here. My family watched ghostbusters last night on the way home from Chicago. I'm thinking that like, I like set up some poor karma between me and ghosts everywhere. So if I declare spheres 'a' and 'b' and create 'a' to be something interesting perhaps. And then make the assignment 'b' gets the value of 'a', then what the things that you told me last time that I need to be sure to do, are to free up the space previously occupied by 'b', the dynamic part of the space previously occupied by 'b', and then explicitly copy over the values, oh oops, of 'a', k? And that means, that means that I need to allocate new space that in the end looks just like 'a' space. K, any question about that at all? I'm going to separate that out into two, uh, sortof subtasks. There's the clear task and the copy task.  Now the clear task should feel a lot to you like another function that you've written, which one is it? The destructor, that's right. The clear task should feel a lot like the destructor, and the copy task should feel a lot like the copy constructor, that's right. Now, do you just call those functions?  No you do not, but we'll talk about that in a minute. Alright so there're these two tasks: there's clear and there's copy Okay, now there are some little teeny tiny, and we're gonna write the assignment operator to do these two things, but there are some additional considerations that would really only occur to you during debugging, but which we're going to be explicit about, k? So now what I wanna know is what happens upon assignment if 'b' and 'a' already refer to the same memory address? Now this can happen in lots of different ways. It can happen because we've passed something by reference or it can happen because 'a' is a dereference of some pointer that has another name. So there're, there're several different ways where two things can be referring to the same memory address; can be names for the same memory address, k? So now what I want to know is what's the problem? What's the problem here, remind me, I think we got this far, but I want you to remind me. K? yeah?
Very good.  So remember that our two tasks are clear and copy.Ok? So let’s do that.  b gets the value of a.  So we clear….. And there is nothing to be copied anymore.  So we basically invalidate our algorithm here, invalidate our data here. We are gonna solve that in the code we write  for the assignment operator by protecting against self assignment. Ok? And then the other thing that we need to do is to implement this behavior.  So C-based languages tend to let you chain together assignment operators. ok?  And all we are doing by creating the , writing the assignment operator is a single chain right here.  I am gonna draw a pair of parentheses and see if that helps you come up with a suggestion that we might use to create a chain assignment operator.  How could we implement that. How could we make it so it is ok to return values.  I am sorry. To assign chain values. I just said the whole thing. I have no brain.  Ok, so I said the answer that I was hoping you would say. So sorry... Alright. So notice this is a function call. Right? This is just like b.operator=(a).  If it were to return a value and then that value could be the right hand side of c's assignment statement. Right? So effectively, what we want is c.operator=(b.operator=(a)). How do we achieve that? Well we have a return value out of the assignment operator. And I am just gonna describe that as return a helpful value. Ok? Any questions about it ? Alright. So let's make some plans.  Here is what the function signature looks like. We are gonna just sort of make a list of things that we are gonna need to do when we actually write the code. Ok. Make a list of things we need to do. First things is: We need to protect against self assignment.  And that's a conditional. That says if the things already don't refer to the memory address then we are going to clear out the left hand side. Then we are gonna make a copy of the right hand side.  And then in the end we are going to return a helpful value.  Ok? We will talk about that in a minute when we write code.  And any questions about it? Ok?  So this is our list right? This is a list of what code needs to look like.  Writing  code this way is really common. You know. Do your comments first and then fill in the blanks. Because no one of these is going to be  particularly complex. And here we go. Alright. So how do we protect against self assignment?  How could we ask the question of whether or not being A" refers to the same spot in memory. Yes? So if this is no the same as right hand side it's almost correct. Help me debug it. What is the right hand side?  What kind of thing is right hand side?It's a sphere.  What kind of thing is this? I think I have only mentioned this very quickly once.  So I will write it again here. this" is a pointer  to the current object.  Ok? And in this case that's the left hand side. 
Very good. So remember that the two tasks are clear and copy, so lets do that. B gets the value of A. So we clear, then theres nothing to be copied anymore, so we basically invalidated our algorithm. We invalidated our data here. We're going to solve that in the code we write for the assignment operator by protecting against self assignment. And then the other thing that we need to do, umm, is implement this behavior. So C based lanuages tend to let you chain together assignment operators. And, all we are doing by creating the assignment -- writing the assingment operator is a single chain right here. I'm going to draw a pair of parentheses and see if that helps you come up with a suggestion that might be used to create a chain assignment operator. How could we implement that? How could we make it so that its okay to return values? I have no brain. So I said the answer that I was hoping you would say, so sorry. So notice this is a function call. Right? This is just like b dot operator assignment operator a. If it were to return a value then that value could be the right hand side of C's assignment statement. So effectively, what we want is c dot operator equals b dot operator equals of a. How do we achieve that? Well, we have a return value out of the assignment operator. And then I'm just going to describe that as return a helpful value. Any question about it? So let's make some plans. So here's what the function signature looks like. We're going to just make a list of things that we need to do when we actually write the code. Yeah... okay. Make a list of things we need to do. First thing is we need to uhhh protect against self assignment. And that's a conditional that says if these things already don't refer to the memory address, then we're going to clear out the left hand side. Then we're going to going to make a copy of the right hand side. And then in the end we're going to return a helpful value. And we'll talk about that in a minute when we write the code. Alright, so this is our list of what the code needs to look like. Writing code this way is really common. Do your comments first and then fill in the blanks. Because no one of these is going to be particularly complex, and here we go. Alright, so how do we protect against self assignment? How can we ask the question whether or not b and a refer to the same spot in memory? Yes? So if this is not the same as right hand side is almost correct. Help me debug it. What is the right hand side? What kind of thing is the right hand side? It's a sphere. What kind of thing is this? I think i mentioned this very quickly once. This is this is a pointer to the current object. In this case that's the left hand side.  
okay. Alright, fine, so help me debug this Couple different ways you can debug it I think It would be relevant Clearly, there's a type mismatch Right? Yeah? Right that's right. So we want to be looking at the memory address, right? The location in memory, the only time this is really truly broken is if they refer to the same location in memory So, we're gonna say, the address of the right hand side, so this is not the same as the address of the right hand side We'll talk about that in a little bit Ok, we're going to clear out the left hand side, gee, we have written this code before So I'm gonna go head and do it, we're just going to delete  The attributes Do I need to go through that array and free up the space associated with the string?  No, because they're just strings. They are not string pointers that we allocated the memory for, they're just strings each string might have dynamic memory associated with it, but it's not our responsibility to deal with it The string class can deal with it Okay? Any questions about that? Alright, fine, and now we need to copy the right hand side  So let's see if I can do this, um, the radius  equals right hand side the radius yes somebody told me about that woah numAtts equal right hand sides numAtts  atts equal new  string  how many of them do I want Good and then, for i int equals zero less than numatts, I don't know why I am narrating this Okay. Yes?  You write it faster than I did? Haha Okay So, while I was doing this, I had that feeling that you should have when you write code and you're writing code that you have written before If you're writing code that you have written before, you should be going, why am I writing this again? Why am I doing this again? And you should make for yourself a function that you can invoke in each case In fact, we're going to do that here. We're going to  Go ahead and pull this out, and put it into a member function called copy Uh, who's return value what kind of return value do we want for it?  Nothing. We don't need anything.  And it's code is merely this, ugh, that code  So this goes right in here Now, I have a question for you. Okay? Any questions about it?  Yes I don't know what you're talking about Alright. Any questions about it? Is it okay? I have a question for you So this is a sphere class member function, which means when we actually do the implementation we're gonna scope it to the sphere class, much like those are. Now if this is a sphere class member function, it means that it needs to be declared inside the sphere class itself Is it public or private
okay, private is correct. Okay, private is correct and the reason for that is... It's only used by other sphere class member functions right It's only created so as to simplify our internal implementation of the class So, clear here is a private member function. Any question about it? Alright, of course I have this feeling while i was doing this part as well. This one needs a member function It's not gonna return anything. It's going to be void copy this time it does have a parameter. I'm going to go ahead and pass through the right hand side As a constant sphere reference  Uh, right hand side.  It's implementation is going to be exactly that . And again it's going to be private Any question about that all all? Yes? That's a good thing to notice.  Yeah, no . You can not. His question is, Why are we doing this? We already have the destructor and the copy constructor. We have those ? Why aren't we just calling those here. The reason is because in principle. You are writing those functions for the system to use. They aren't yours You can't just call them willy-nilly The indication that is this true. There is no return type. The compiler is expecting you to be calling a function that yields a return type. There is no return type for the destructor and the copy constructor. So you as the coder have no business calling them. On the other hand, you are going to back and change your code for the destructor. The new shiny code for the destructor is simply going to be a call to clear The new shiny code for the copy constructor is going to be a call to copy. Okay so, i agree that we shouldn't have the same code in multiple places. I disagree where we should stash it. Yes? Um, so the question is.. Whether or not we should. How we should. Wait whether or not we could check for equality instead of inequality. If they are the same then do what. Nothing. So you want the other side. Or whether it wold be single or double assignment operator. If it is a logical question then it is double. I assert that you really don't want to do that. Then you are being explicit about the else. And then there wouldn't be anthing to do otherwise. We will run into this later in the class such that if something is true then we will do nothing Alright, let's return a helpfull value 
What kind of thing do I need to return? A sphere, right? So what I'm going to return is oh, you're not going to like this I'm choosing that one, in principle at this point I should be able to choose b or a the right hand side or the left hand side choosing the left hand side so that i can return by reference because nothing is going to happen to this" in the execution of that function Alright! Any questions about it? OK. Now, guess what, if you replace that rectangle with a call to clear and this rectangle with a clear to copy, except for type information, we have just written every single assignment operator you're ever going to write. You should just go, and cut and paste from this. Any questions about it? If you should decide to be creative, you are still responsible for all these parts you still need to check for self-assignment you still need to clear out you still need to make a copy, and you still need to return but, yes, you can do those in different order if you want, but I wouldn't, why? Ok! Any questions about it? Yes?! I'm not returning by value, I'm returning by reference. I could return by value if I wanted to but it would be slower to do so so I'm going to return by reference. I know that this" is not going off the stack, right? I know that this is not going anywhere because if it were, I wouldn't even have the function, so this is fine. this" exists in the outer scope. in the calling function OK, so I can return the value of 'this' by reference. Alright, so this is what it looks like in the end, and like I said, except for type information, every single assignment operator you ever write just like this. I have a question for you though, and it's on the board, (Repeating student's question) Process it? What does it mean? (Iterating question) What's the difference between it, and what we did? Yeah? Yeah! Very good. Instead of referring to the memory location labeled by this on the right hand side we're referring to its value right? The information that they hold. In this thing So we're checking to see if the value of each side of the assignment statement are already the same. It's kind of reasonable, right? Why not? Why wouldn't we do that? Why would that be a bad idea? It takes longer time, good. Why? Yeah, you have to go down and look at everything, right? I'm going to use that as the second one of these bullets. So, it might take significant time to check equality ok, fine. Why else? I could've put it first, there's no real reason. It's not like to other one is that much more expensive. It's kind of dependent. Yeah? Very good, very very good. This operator right here, has on its left hand side, a sphere and on its right hand side a sphere So the only way that that is going to work is if that operator is overloaded so, operator not equal must be implemented.
I don't know about you, but if I could avoid doing that I think I would like too. Ok.  And the last one, the last point is kind of subtle. There is a software engineering principle that says that you should leave the decision of whether to reassign to the client.  Ok. So leave the decision of whether or not a reassignment should happen to the client. So yes, they might both be the same, but they might do an assignment anyway and maybe that's to avoid a conditional maybe we do not know why. But what we do know is that when we when we check to see if they're the same, we are essentially doing the same amount of work as an assignment anyway. So because you have to you know we have to look at every last thing, so we are not going to presume that we are allowed to take that time here. So the short way of saying all of that is leave the decision  to reassign  to the client. so that when they say 'a' equals 'b' they want it to happen and the only time we are not going to let it happen is if it is a destructive maneuver. Ok. Ok. Alright, I think that is all I wanted to say here. Alright. We've been talking for about two and a half days now. About things that all feel kind of the same. They are all about responsible use of memory and sure enough we have the rule of the big three. A rule of the big three simply goes if you have reason to implement any one of the copy constructor the destructor or the operator equals (operator=) then you must implement all three What I want to know from you is a concise statement about when is that. When is it that you need to implement them rather than rely on the system provided. When is it, when do we implement these things? Yea? That's right. When the object itself uses dynamic or heap memory.   Now, umm... I guess I feel like that's a little bit inaccurate because if you use a string are you using heap memory  are you using string...are you using heap memory if you use a string  who knows is the right answer we don't know for sure but we might be and so what the real criteria here is not that it explicitly uses, but that it.. that the object itself explicitly allocates. Ok. So not that it uses cuz we don't necessarily know, but that it allocates that is it says the new word.
Alright, any question about that? The rule of the Big Three. Okay so, we're going to return for a bit to a object oriented programming. Because C++ has some idiosyncrasies and some distinctions from Java, in particular that you should know about.  And then many of you will have come here without a lot of experience in object oriented programming. So, historically, the objective for even creating objected oriented languages was two-fold. One was to create code that is smaller, that is to increase code reuse. And two, which sort of follows from that is to decrease the cost of maintaining such code. So, the idea that in objected oriented language should exist really arose out of the need to structure your code more efficiently. From a programmer's perspective, not necessarily from a code execution perspective. So from that understanding, from the understanding that we are trying to write less code and thereby make it more maintainable, these characteristics arose. So, encapsulation we already talked about. If you wanted a little quiz, you should sort of go back and make sure you know of two ways that C++ implements encapsulation. Or makes encapsulation easy to implement. Polymorphism we are actually going to talk about today. Suffice to say its definition follows its name. Basically, a function can behave differently depending on the type of the calling object. We will talk about that a little bit today. But the biggest thing we're going to talk about today is inheritance. And, without further ado, let's begin. So we have been talking about the sphere class. And now we have decided from a design perspective, that spheres are not specific to us. In fact, what we want is a named sphere class. A named, when I say named I mean sort of labeled, named sphere class but otherwise this thing should behave a lot like a sphere. I'm going to decide that I'm going to call this thing ball but of course I could call it anything I wanted to call it. Usually, it's the case that the name you happen to choose is a specification - is more specific - than the original thing. The original functionality, and we're going to set it up, we're going to define class ball, So that it is a - use language is a - public sphere. So this indicates inheritance. That colon is inheritance. Inherits from sphere. Now we have specific language in C++ to denote these things. We refer to sphere in this context as the base class. We refer to ball as the derived class. And this corresponds to superclass and subclass in Java. Any questions so far? So now, there's sort of an interesting little parallel between these two things that you might find kind of interesting. I have no english today, apparently. This word corresponds with this word. Is it just a happenstance that we chose the word public in each of those cases? And the answer is no. In fact, the inheritance type keyword can be the same as the access types. So we could have private inheritance as well, and in a minute we'll talk about protected inheritance. But, for this class, we're only ever going to have public. Okay so here's some - here's your first key fact. The access type - the access type - in the base class that is these public and private together with the inheritance type, imply the access in the derived class. So I'm going to write that down in just a minute we'll talk about what it means. So the base access,
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
plus inheritance type imply derived access and furthermore the most restrictive of those two applies. so let's do an easy example first So let's do an easy example first. So all of these functions are public access in the base class and it is public inheritance and so it is as if all these functions live in the public section of the derived class. So now it is as if all of those don't exist there. They actually exist here in the ball class for when we declare ball. Any question about it? You already experienced a little of this when you worked with images, I believe. There's an exception to this. The exception is that the private elements in the base class are never visible to any derived class. So the exception: private in base are not accessible. By derived classes Okay. Let me see what else I was gonna say here. Okay, there's one more thing that's key to pointing out. If all we ever had was private and public, things would be a little less interesting, but this last thing here can be perceived as quite a restriction. So what we have is something called protected access. and inheritance That, for example, might allow you to declare something like surface area, in which case any of these functions could access it, but this would not be allowed. So this protected is like public to a derived class but like private to client code. [nothing] So you'll see a lot of base classes with protected access sections, very common. On the other hand, what is not so common is any kind of inheritance other than public, and certainly for this course we will only ever use public inheritance. So you can kind of not worry about getting that tangled up Were there questions? [nothing]
Uhh, so the question is how come the ball class can access the radius. How do you know it can? Did you say can or can not? The ball class, the ball class member function can not access the radius. ball(double r string n). Where? There is just a comma missing there. OHOHOH, very good! We have to invoke the sphere class constructor in order to do that and it has to be explicit. So we can not, the constructor, that's really a good point actually, so what he detected and is really germane is that that ball class constructor has a problem. Right? It can not take a radius and set the radius because it doesn't have access to this. But what it will do and you'll see is it going to call the, explicitly call even, the sphere class constructor, OK? Does that make sense? Is that answer it? Sorry, I didn't...I don't think anybody ever pick that up before. Good job! Yeah? Yep! Yep! The base class of , the base class member can certainly access the protected values, they are just like they're sitting in here. OK? Alright! Anything else about this? There is, there is a hint. Bye! See you later! (Laugh in the background). Mean mean mean. OK, anything else about this? Yes? Yep! That's right! Yes, but it does exist, we are going to talk about that in just a second. So the question is kind of: OK, what's happening in memory?" and I think that the following will clarify some of that. I can draw you some picture that will clarify some of that. First of all, let's trace some code, OK? So, start with main here, start with main. We are just gonna declare a sphere, and it gonna has a radius and nothing is surprising about that, right? We can still, of course, use that base class to declare an object, there's nothing that says we can not, OK? Similarly, we can declare a ball, now, subject to the constrain, that the ball class can construct a sphere, it does so and the way to think about it is in fact it builds a sphere first with all of it staff whenever it has, and then adds to it, it adds to it the string corresponding to the name in memory. OK, so build the sphere class thing first and then it adds to it what it means to. OK so ball is a sphere with a little bit more added on to it to make it more specific. OK. Can I say b.getVolume()? Would you expect... first of all, what class member function is getVolume()? Sphere class, that's right. Its volume kind of thing, so its member functions are in the sphere class. Would you expect me to be able to do that? YES, yes, yes, yes. That's what most of this is about, is access to the member function of the base class through the derived class, OK? No problem. What do you think happens here? Anything surprising about calling printVolume? Is it OK? Anything surprising about PrintVolume there? Yeah? Yeah, you do. Right there. Yeah, yeah, yeah, good. I love the easy ones. (Laugh). OK. Nothing surprising about it right? It all just talking about spheres. Yeah?
This one, on the other hand, this one feels a little weird [laughter] this one feels weird What's weird about it? Yeah? Yeah that thing up there expects a sphere, right? And we're calling it with a ball Guess what? Whose copy constructor is invoked? is the question, right? It's passed by value, whose copy constructor is invoked? Sphere's copy constructor, that's right. And so that means, when that ball is sent to that function there is only a sphere inside of it But in this case, of course, that's fine, right? That's fine. There's a sphere, we needed a sphere So that's perfectly fine. Alright. So Sphere's copy constructor invoked even if it's the system provided one. Even if it's the one provided by the system and not our custom  One. Okay fine. Here's what I want to know next. I'm going to declare a base class thing and a derived class thing. Can I do that? [incoherent] Okay so this is - which one of these is larger? Which one of these things takes up more memory Tell me to stop when I get the larger one Yeah okay, this one I don't know if that was ever going to work. Okay. So is this assignment okay? The thing on the right hand side is larger than the thing on the left, is that okay? It does work! It actually works. It works; it compiles; and the result is that this thing is kind of sliced off to go here Okay so the base class thing can accept on its right hand side A derived class object - but it's sliced across This still is a base class thing Okay so this is okay... But b is still base or smaller How about this one? No, no way, compiler won't let you do this It says woah, woah, woah, you didn't give me enough information on the right hand side to create one of these" Okay, so the compiler actually does not allow that Disallowed by compiler Okay... [talks to student]. The question is what happens here What happens when we're talking about pointer instead And we'll start there next time I want to be the one that tells you
Okay. My clock says it's eleven o'clock so let's get going. You haven't even asked for it yet, but I'm giving you an extension on the extra credit portion of MP3. On the website it says it's due on the 22nd and I just I said on the slides it was due on the 25th so we'll go with the 25th that's fine. Yea right, yayyy. Oh you're so welcome. You're so welcome. I'd like to say anytime but that's not quite true either. We have more print outs coming so if you don't get a print out they will be there. I swear I always print out enough and they just disappear. I don't know who's taking these print outs. Who wants them. Maybe it's sabotage. Let's see. Oh, ok. So MP2 was due last night. Yes? Ok. Yea it was, it was. Does anybody know how long the queue was? Ok. Six people. Sixty six. Six hundred sixty six. Yea, no no. Ok. So that's like about 10% of the class was on the queue. Can you guess how I feel about that? Yea. So what that says is what what it says to me is that you know 10% of people were working on the problem and got stuck. So that means even an even huger proportion of the class was working on the MP at the last second. So that just breaks my heart.  Cause it's so fun. You want to do it early. So here's the thing. I cannot promise you that the queue wait times will improve. I can't promise you that. Now do you see how meta that was? Cause if I say I can't promise you the queue wait will improve then you won't count on it and you'll go earlier in the week and spread out your requests. And then the queue times will improve. So there's this kind of thing going on there. So So I refuse to promise that the wait on the queue on the last day will improve. There should be huge incentive to start early finish early. I think course staff is most broadly available at 9 o'clock in the morning, 10 o'clock in the morning. Think about your fellow students schedules and plan accordingly. It's this interesting problem, right? Like, the crowd. The flow of the crowd. Uhm, alright. Uhh. We do try, but sixty people on the queue's an awful lot of people. It was bad monday night too. Oh, the other thing. Course staff actually asked me to tell you was that you have now had two labs whose focus was debugging. They, they are exorting you. Encouraging you to try to be a little more independent. When you run into a problem instead of just putting your name on the queue go ahead and you know. Be a little more tenacious then you would've been a month ago in trying to figure it out yourself.  That's gonna be a valuable skill as you go forward.
Okay, let's work shall we? We were talking about inheritance and we are still talking about spheres. Maddox, the other instructor for the course came up to me this morning and said, You do love spheres, don't you?" I don't know, we all love spheres. Who doesn't love spheres? But we're almost done. We're almost done talking about spheres. Alright, so we had two classes last time. One of them was the sphere class. One was the ball class. Do you remember the way that we described the sphere class in the context of inheritance in C++? Base class, that's right. So the sphere class is the base class, Base class... and how about class ball"? It is referred to as the derived class, good. And, the key thing to observe here is that basically we are exercising code reuse. That is, if we already have a sphere class, then we can avoid re-implementing a lot of these functions if we just say we intend to use them via inheritance. So this is largely an issue of code reuse. Okay, let's see... so there are a few little behaviors that we should talk about. We talked about them in here a little bit last time, but I didn't get to them for the other class and so I'm going to review them for you as well. Oh, the other thing that I intended to say here is... from a design-- I want to talk about these two classes in particular from a design perspective for just a second. Notice that the ball-- a ball-- is a more specific sphere. So it's a sphere with more information. And furthermore, observe that the functions that are associated with the ball are concerned primarily with that added information. So from a design perspective, it's reasonable to think about, Okay, what's the functionality of the ball as it relates to the data?? That is, what functions do I need in order to make that data accessible, usable, et cetera? And leave to the sphere class all the functionality that every sphere might need. And most of those have to do with its data. So it's just sort of a little-- I just wanted to bring it up because there's this little design checklist going on where you can ask yourself, Okay I need this function to go here or here". Largely, that decision is made on what kinds of data each of the classes hold. And how general the use of the function itself is. Okay, that said, let's be more concrete here. I'm going to declare a sphere, declare a ball.  Okay, you know what that means. It's certainly okay to declare a sphere because that's just our stupid sphere class that we've been talking about since day one, right? So it's okay to just declare one of these. Declaring a ball-- also perfectly fine. This is not unlike the image class and the PNG class from MP2, for example. Alright, now, this assignment statement-- what do you think. Do you like it? Assume the assignment operator is well-defined. So even if there were dynamic memory associated with these things, know the dynamic memory would be handled responsibly. So assume that generally, each of these has a well-defined assignment operator, okay? That being the case, whose assignment operator would apply here? Sphere That's right, so it's sphere's assignment operator. So what is the result here? S stays a sphere, right? S is a sphere. It is as if and it's value is exactly like b's value except... This part isn't there, okay? So it's the sphere part of b. Any question about that? So this works, this is fine. S is the sphere part... ...of b, okay? Now, how about this one? So now I have the b... I have a ball, and I want to assign to it the value of a sphere.
the problem is we can't instantiate all of the ball from the sphere's data We can't take this spere, it doesn't give us enough information to fill out this ball So the compiler will say hey, you are being to ambigious with me , i can not process this So this is the dissallowed Can't write there. You have to write it yourself  Somebody is going to ask me what did I learn this semester and my answer is going to be I learned how to use powerpoint By the compiler  Now, Someone out there , someone out here, is wanting to ask can you cast that sphere to be a ball? So that the types would match Five people were wondering if you could force that sphere to be a ball You could, but... anyone anybody who read your code would go ughhhhhhh It is a hacking way, an ineloquent and an insecure way of achieving type agreement. So, don't do it Unless you absolutely have no choice Don't do it because it is the easier thing to do, only do if thought carefully about all the other options, and you know it's not going to break things Oh i don't know, that means that the only thing you can ever assign to a ball is a sphere. is that what you wanted? oh, then the parameter ,i don't know uhhhhh, so you know i don't claim to know everything , but if you are doing things that I don't know Then you at least better document it very well, and very carefully. Not only what you are doing but why you are doing it Right simple code. People like to read simple code, right. Simple code right, simple code Except in MP3, haha.  Alright, let's work, come on I'm sorry Oh i have a typo here. I left my old variable names here We need to keep moving Alright, this is now what i intended I intended s=b and b=s here Alright, so now though we are going to declare pointers instead. I want you tell me what you think happens I am going to declare a pointer s and b. And I'm going to instantiate   them with something. Instaniate a sphere with a sphere, but it will be a less stupid sphere. It will be a smart sphere. and ball is like a sphere but it also has a name associated with it Now, Question is can I do this. Is this one okay, What's the consequence of doing this in the picture Means that s points like this that alright? yeah?
No, it's fine. It would still be fine, it would still be there. Because the ball class is gonna clean it up  Ok, so right so pretend that in this case I cleaned this up responsibly. Pretend I cleaned that up responsibly before I made the assignment. So is that okay? Yeah that's fine The only thing is, so I can make this assignment but s is still a sphere pointer so I can't get the name. I can't say s dot name any where or s dot get name. I can't refer to the ball class member functions I still have to use only the sphere class member functions. But the ball is still there and b still points to the ball so I can still say b dot get name for example alright, and so this is fine but, s, the value of s is sphere. As you would expect That's dereferencing. This mess right here says this is fine, but the value of s dereference s is sphere type Alright, b equals s, is that okay? no, compiler doesn't allow that so that's not okay good, this is just the behavior right, like there's no - you just gotta know it. Luckily the compiler tells you when it doesn't like it. You probably noticed that each of these classes has a display function and so now I'm going to as you in which contexts, which display goes. Now just for the sake of discussion, I've implemented display so that it tells us which class it comes from. In each case so the sphere class display simply says, hey I came from a sphere and the ball class display, I came from a ball, and nothing else alright, just for the sake of illustration, so now the question is what happens in this example? s dot display gives you what? sphere, exactly what you expect, yay how about b dot display? Yay, gives you what you want okay it gives you all the right thing for the concrete objects themselves Now let's make it a little interesting let's use pointers instead let's use pointers So I'm going to set up a sphere pointer s and make it point to something that is of type sphere so it's just type sphere it doesn't really matter what this sphere looks like and now i'm going to ask for display what do I get? Sphere good so the right thing happens. Alright, and now the last example. ready? Here's a sphere pointer and we said last time that it was ok to point a sphere class pointer to a ball So here's the sphere portion of it and here's the name sticking down here we said that was okay And now the question is, what happens when we do this? I'm gonna ask you about what you hope for first this is a reflection of your optimistic soul. What do you think, what do you wish would happen here? raise your hand if you wish that a sphere would be displayed, that sphere would be displayed You hope sphere is displayed here Raise your hand if you hope ball is displayed here Ok did you all see that it's about half and half right? the answer is sphere is displayed no So this is an example of what we call early or static binding. compile time function binding so I'm gonna write some of that vocabulary down here So this is - I'll say it up here c++ is by default statically bound let me start over, sorry c++ uses static or early or compile time function binding by default
No, it's fine. It'll still be fine, it'll still be there. Because your 'ball' class is going to clean it up. Okay? So right, pretend that in this case, I clean this up responsibly. Pretend that I cleaned that up responsibly before I make the assignment. So is that okay? Yeah, that's fine. The only thing is, so I can make this assignment, but, as this is still a sphere pointer so I can't get to the name. I can't say 's.name' anywhere, or 's.getName' I can't refer to the 'ball' class member functions I still have to use only this sphere class member functions, but the ball is still there, and b still points the to the ball, so I can still say 'b.getName' for example. Alright. so this is fine but s, the value of s, is 'sphere'. as you would expect this mess right here - this mess says this is fine but the value of s, dereference s is sphere type. Alright, b equals s, is that okay? no, compiler doesn't allow that, so that's not okay, either. this is just the behavior, right? like there's no - you just got to know it, like the compiler tell you when it doesn't like it. you probably notice that each of these classes has a 'display' function and so now I'm going to ask you in which contexts which display goes now just for the sake of discussion, I've implemented display so that it tells us which class it comes from in each case. So the sphere class just displays simply says 'hey I came from a sphere' and the ball class display 'I came from a ball' and nothing else, okay? just for the sake of illustration. so now, the question is, what happens in this example? 's.display()' gives you what? 'sphere', exactly what you expect. how about 'b.display()'? 'ball', gives you what you want, okay?  so gives you all the right things for the concrete objects themselves. now let's make it a little more interesting let's user pointers instead. so, I'm going to setup a sphere pointer s and make it point to something that is of type 'sphere' so it's just type sphere doesn't really matter what the sphere looks like and now I'm going to ask for display what do I get? 'sphere', good, so the right thing happens. and now the last example. ready? here's the sphere pointer, and we said the last time it was okay to point the sphere class pointer to a ball so here's the sphere portion of it and here's the name sticking down here we said that was okay and now the questions is what happens when we do this so I'm gonna ask you about what you hope for first, okay? this is a reflection of your optimistic soul. what do you wish would happen here raise your hand if you wish that the 'sphere' would be displayed you hope 'sphere' is displayed here. raise your hand if you hope 'ball' is displayed here did you all see that's about half and half, right? the answer is ... 'sphere' is displayed ooooooooohhhhhh... so this is an example of what we call early, or static binding, compile-time function binding so I'm gonna write some that vocabulary down here [writing on the slide] C++ is, by default, statically bound... [wipes the notes] C++ uses static, or early, or compile-time, function binding by default
Okay but the fact that each of those words has an opposite or sort of an opposite static opposite is dynamic early opposite is late compile time well sort of the opposite is run time the fact that each of thsoe words has an opposite and this is just the default means you should probably suspect there is an alternative okay alriht so almost it's almost certainly true that this behavior is not what's intended it's almost certainly true that if we were to put effort to make this a ball then we intended for the pointer to behave like a ball and so um we have a programatic mechanism for making that hapen now why does c++ do it like this by default and the answer is that this assignment could be inside a conditional right? in fact you could assign any derived class to a sphere pointer because of that, you can even necessarily figure out until runtime which of all the different options are necessary so at compile time they all have to be expanded into machine code now the cost of that is huge it makes for larger and a thereby slower executables so uh by default you know c++ imagines itself a racehorse it'ts trying to do everything fast so by defaut its choice is to use early binding which says okay im just gonna go with the declared type information as the only type information okay? any questions? lol yeah! silence silence um oh we're gonna talk about that i have a whole slide on destructors is what you're asking about right? like what happens in thsi world with a destructor very astute of you to notice and we have a whole slide on it alright so how do we fix the problem and the answer is we use keyword virtual chirp chirp silence wheeee so the virtual keyword means tha the function may be overwritten in a derived class more silence yawn pull out your pillow like actually there's like 5 more seconds of silence wheeee jk there's more chirp chirp chirp ok alright! and so now and so now this code will work just fine k? i put things in a conditional and the rigt kind of display will happen based on which of these assignments occurs k? so now you can imagine instead of a=0 who knows what a is here you can imagine any conditional here like if the left button is pushed or the right button is pushed or if the temprature is over 75 degrees this can be any conditional and we can still attach at run time any kind of thing that we want and still get the display that we like so in the in this example in the case that a is 0 we get sphere otherwise so a!=0 we get ball k? that is polymorphism spooky because it we change the behavior of display based on the type of uh uh they type of uh the object yeah? oh there's two of you let's see if i stand way over here then you're in different palces places* very good question um um the question is do you need the virtual in both places? and the answer is nope you dont once the function is virtual, it will always be virtual k? so it's superfluous for me to say that but because code is communcation, I'm always going to say it just to remind uh future derived classes that display will be overwritten or can be overwritten k? you guys should jsut talk to eachother! wait wait then they'd be completely wait what huh? k don't talk to eachother what alright any questions about that so once a function is virtual it is virtual throughout the inheritance hierarchy but we are awlays diligent about writing it jsut as a reminder yes whee am i done yet? woo hooo!!!
so the question is does the sphere pointer also now have access to b's attribute?
Okay and that is really the only time I feel like it's accurate to say we call the constructor. Other than just letting the system invoke it for us, okay. Any questions about that first example so that's the ball class constructor we need to instantiate the name. But we also need to instantiate the sphere part of it and to do so we invoke the sphere class constructor. Yes? So umm, so let me if I got your question correctly. So by invoking that sphere class constructor it's gonna go lay out its memory. In the way that it wants to, right? So that's how you get it for the ball class. Now the ball class might have its own dynamic memory but that would happen inside the ball class constructor, okay? Does it help? Yes, on top of, below actually is how I think of it but it might be on top of. I don't know how memory does it. Yes. Yes yes yes, very good. That was the next thing I was gonna say. So I explicitly called the no argument constructor of the base class here. If you don't do it, the system will do it for you. But that's the only one, that's the only one it will ever do for you. So if you don't invoke a constructor. The no argument constructor is made for you But I assert you already knew this. When did you experience this behavior? Image class, that's right, this is what is going on in the image class, right? For mp2. You declare a image and the system says okay i'll make you a PNG with this additonal functionality. Okay so this happens by default. Okay and if the system provided one the system provided one will be used if there's a custom one the custom one will be used. Okay but those are kind of boring constructors. Let's talk about this more sophisticated one that takes not only a name but also a radius. Okay so here, here we really do want this is the behavior you wish you had for the image class. It would be nice to be able to invoke the PNG constructor that allows you to give it a size. But we didn't tell you about this yet. Alright so all you have to to invoke that sphere class constructor is essentially make a call to it in the intialization line. Right? And so object itself then looks like you know the sphere with radius r. theRadius and its value is r and it has name whose value is n. Okay any question about that? Yes? So the question is can you move it out of the initializaiton line.  Anytime somebody says can you in c plus plus I'll go oh probably. But number one I don't know how to and number two the expectation is that it will be there so somebody's looking at your code and you're wondering what constructor you're using. That's where they gonna look for it, if you hack something...
melts (I'm not sure) together. There gonna go I don't know what the heck he's doing. They're gonna throw your code away.  So  and that's like the biggest insult right?  biggest insult possible, if you right code and give it to sombody else and they go AAH  throw it away  Alright  Let me see if I was going to say something else here. Um... So I sort of implied this. I sort of implied this  and we're gonna talke about it more on the next slide but  The way these things are constructed goes in order from  base  through the derived classes so we can have lots of derived classes but they go in order from the base through the derived classes. So it really is constructed to think about it as the base class with additional things tacked on.  as you navigate the derived hierarchy  and such that's the order the constructors are effectively invoked  Kay. So the constructors  are invoked  base class  first  followed by  derived class  and notice that there's sort of a  there's sort of a recursive, there's sort of a recursive description here because that derived class could also furthermore be a base class. So you could have this sort of chain of... um...  chain of  inheritance. Okay.  Ummmm... Let's do next slide. I love this slide. Love it.  Always excited for this point in the semester yes?  uh huh  oh no, just the first one.  just the...justs the...just the one above it  Yep  yes  no  no  just calls balls because what's balls going to do?  yeah  right that's right so, his question was a good one and that is. is this like a makefile? It ...um if you have three, say a basketball. This example is a good one. If you have a basketball which is a derived class of a ball, does the constructor for a basketball have to call the sphere class constructor and the answer is no The answers no. You could just call the ball class constructor which in turn will call the sphere class. kay?  All right, I've given you some code here. Now this code is for illustrated purposes only. It's barebones a couple of class definitions and basically I want to know what the system does when I execute this. I want to know which constructors are called when and which destructors are called when. So the code is this, It's a base class pointer but I'm going to instantiate it with a derived class thing. So that's fine.  So ba...base class const...I'm sorry base class pointer instantiated with a derived class thing  and then I want to clean up memory  Kay I'm gonna clean up V The question is  what's the output of.... what's the output of main? Go ahead and talk with the person sitting next to you and write down what you think the output of main is. And I'm gonna give you thirty seconds to do this  Maybe 45  
Okay ready? Ready? Alright So I'm executing this code and the first thing I do is ask for a new derived class thing. What is the first output that I see? Constructor of...? What order do constructors go in? Constructor of...? Base! Good. So the result of the first statement is constructor of base And then because its a derived class thing, the next thing I see is..... Constructor of dervied Now the interesting things begin I'm doing two colors of ink here and the reason for that is because I'm going to go with what you hope. What do you hope happens here? So what you hope is....somebody say..somebody volunteer What do you hope happens here? Ok so what you hope happens is...Dtor:D and Dtor:B Anybody strongly disagree with the hope here? That feels like it would be responsible right? Guess what really does happen Which one? Only one of them goes by default Raise your hand if you think its derived goes.... Raise your hand if you think its base goes.... Okay so 50/50 So what I take from that is that collectively we're guessing What goes is Dtor:B The question is...how do we make Dtor:D go... and the answer is the we make the base class destructor virtual and then the right thing will happen Thats what causes Dtor:D and thats it! That just how it works! If only Dtor:B was printed...think about what that means if there was dynamic memory associated with it. There would be a memory leak The question is...do we need the virtual keyword in front of the derived class destructor I believe that implicitly its there but I'm not sure so yes you should put it there Anytime you are creating a class that might be a base class just make your destructors virtual
can't clean up after itself right? aughhh that's almost not certainly what you intend alright any other questions about this? kay.... alright uhh.... take a look at square in the upper left hand corner and tell me what's interesting about it [people telling Cinda what is interesting about it] tell me what is different it's the flower class, what is different? .......... this is an easy one [waiting] what is draw blossom? its just a..... function right? it's just a function happens to be virtual so we get the idea that this is intended to be a base class. so what's weird about it is that assignment statement here is what that assignment statement is its... its.. its...it means that draw blossom is a pure, virtual, function kay so....pure..... virtual.... function and what does that mean? it means a function that is not implemented here but will be implemented in some derived class kay? so a pure virtual funtion is a function not implemented................. in the base class........................ but rather................ in a derived class [pauses for dramatic effect] k? ....alright.............. so here's the cool thing about it basically in the base class, the base class now is prescribing what the derived classes have to look like if you want to implement a flower you HAVE TO, or i'm sorry, if you want to, uh, derive from flower you have to implement draw blossom function.... kay? so it ends up being a prescription for the functionality of the derived class or effectively an interface  uhhhhhhhh let's see, so an abstract base class is the name we give to any CLASS that has at least one pure virtual function .............. any class..... containing..... greater or equal to one pure ... virtual... function ......k? any question about that? yes..................yep yep that equal zero is sort of like i'm i'm intid- it's an indication that i'm intending not to implement here right? it's equal nothing function is nothing alright! any other questions about this? yes???? [listens to question] yep maybe put it on piazza, a question like that, cuz i dont really know java that well i might not be able to answer anyway so any other questions about this? ...... okay! yea? [] uhuh [asfasfasdfasdfasdf] yep.....multiple, right, multiple derived classes all have to implement draw blossom so look at this. I've got, in fact we've done that here we've got class, daisy and it implements draw blossom, draw stem, draw foliage  but..... we could have, we could have, uhh, class rose, or class tulip, class Astor. we could have any of those flower classes and they would all have to implement um, draw blossom. I have one more thing to say though!!!
You're so sweet. :) Um, what I'm gonna say is, I want you to look at this and tell me what you think of this for next time, that's where we'll start next time. Kay, so respond to each of these for next time. [Student] Um, on the previous slide... Yeah? [Student] Er, you said, well, first you go to print(?) B Yup. [Student] 'Cause the virtual was not there. Right. [Student] So if we add virtual here... It will do all four. [Student] All four. [Cinda] Yup. [Student] Ok. [Student] Um, so what do you mean by having more than one? [Student] 'Cause in the previous lectures, the class didn't - Right. They didn't - we've never seen an abstract base class til today. So this one - this one is our first abstract base class. [Student] So every abstract base class will contain... Yes. At least one. Any. That says, any class containing greater than or equal to one pure virtual function is an abstract base class. Ok? [Student] So all you have to do is type virtual infront of this, or what else- Yup. Yup, that's it. Mhm? [Student] And what does that change? It tells the system to look for additional destructors. [Student] Um ok, so it's gonna say, like, if it's a derived class [Student] that it's gonna call the base - er, no, sorry - [Student] the derived class and what if it's like the base [Student] class it won't care [Cinda] Yup. It doesn't care for it. For the functionality of the base class, it ignores it basically. [Student] All you need to do is add virtual to the class. [Cinda] Yup. [Student] So the virtual class destructors call all of the superclass destructors? Erm, no, the sub- ones. [Student] All of the sub- ones. You put it on the base class. That is- it's kind of - [Student] Oh, ok right. [Student] So then, here, when we change [Student] when we put virtual in front of here -  It was this one. We did it in front of this one. [Student] Right. [Student] So then it will print - it will call both of these destructors Yup. [Student] whenever we want them. [Cinda] Yup. Yup, exactly. [Student] We don't have virtual here so we are only triggering - [Cinda] Yes.  [Student] Is it just not so - a drastic impact - I mean  Is it what?  [Student] Is not - we like, we like always(?) Right, we probably don't - we probably don't want that action. Like if you had written something that had invoked a constructor You want it's destructor, just in case. 'Cause you dunno what the constructor did, so you want its destructor too. So back - [Student] This is bad(?) Yes. So right. Back here... This - this was - destructors can and should be virtual. [Student] Oh. [Cinda] Ok. What's up? [Student] Don't they already inherit those functions, [Student] so why would it be important to have them? Um, they're not implemented here. So it's admitting, in the base class, that those functions probably have to be different in all the derived classes. They're gonna mean - they'll explicitly mean something different. In each of the derived classes. Like, drawing a blossom is going to be a different process for a carnation, than, for whatever, right? [Student] Yeah. They're just very different. And, so, And there is no default flower, right, like there is no flower that you could draw and implement in drawBlossom that is like the average flower or something, like it kinda doesn't make sense. [Student] So you wouldn't execute(?) this function if you wouldn't [Student] call on like, just from its base class. That's right, right. And in fact, um, what we're gonna start with next time, is that box where I've declared a flower, (whispering) and you're not allowed to do that. There is no flower class. The flower class actually needs derived class, it does. That's right. But it doesn't have those functions. [Student] Why couldn't this be just an empty class?(?) It is essentially an empty class. I - well, no it isn't, it might have data associated with it it might have a string that it's name, it might, you know it might have data associated with it but we can't draw anything about it because we don't know what it looks like So, so yeah, I mean it can be a full - in fact, we could have all of them except the blossom we could have all the functionality except the blossom but you still can't declare one. Nope, it has to be more specific. Ok? [Student] You said that initally that for the definition of pure virtual functions [Student] That means that in one of it's derived classes that it's defined, like [Student] This function is gonna be defined. [Cinda] Yes. Yes. [Student] But even if somebody else asked, they said,  [Student] that, suppose you say, a rose, [Student] and then you say, daisy, and each one of [Student] these, it has to be defined. So Yes. No, no. Yeah, so it's greater than or equal to one that isn't implemented here - [Student] Oh - and that
You're so sweet Hmm, what I'm gonna say is I want you to look at this and tell me what you think of it for next time, that's where we will start next time OK? So respond to each of these for next time.
OK, alright, let's get started. So guess what's coming up in two weeks? Yes! The exam, very good. But also wait a minute, this is a problem actually, the exam comes first, then we have reflections projections, the coolest student run experience I have ever seen, closely followed by Hack Illinois, which is later. Yeah so we're well represented here. So Jessica and Victoria want to talk to you about opportunities for, um well, to tell you about reflections projections and how you might participate. Hi I'm in Victoria I'm the chair for reflections projections this year. We have a lot of cool speakers coming in this year between the first and the fourth of October. We also have a programming competition so if want to come build an AI we have awesome prizes, including an Oculus Rift in those. So if you want to come compete and try to win that we'd love to have you. It's October 1 through 4. The programming competition is between the second and third. We have a puzzle competition going on over the course of the event. We also have speakers all of Saturday and some scattered throughout the rest of the event. Two job fairs, one is on Thursday, one is the big job fair on Friday. So if you want to come meet recruiters, see speakers, and maybe compete in a programming competition, come to RP. And here's Jessica to tell you how you can get involved and volunteer. So yeah in addition to experience the event itself, we would love it if some of you or all of you would come help us our during the event. So there is a sign up URL for that, it's www-s.acm.illinois.edu/rpvolunteer. Essentially it's the ACM URL slash rpvolunteer, no special cases, no spaces, just rpvolunteer. If you go there and sign up we will get you fitted for a time slot. And if you volunteer you will be fed, you get food. And you get a free t shirt! Who doesn't love free t shirts. Also food is free for the entire weekend. And it's always good food. OK thanks guys, are you coming back for the next hour? OK nice to see you both. Let's work! Seriously, when I go to reflections projections, I walk out of the talks going oh I'm so glad I'm with computer scientists." It It's really inspiring to hear all the huge variety of cool things that people are doing. And the most interesting thing for me is that the speakers tend to be kind of younger, so there's this generation between you and me kind of, and those tend to be the people who come to speak. So I'm always very excited.  So I want to work, and so unfortunately I'm going to have to erase all of this. I know, I know, erasing all the fun. There shall be no fun. 
OK, so last time we were talking about inheritance and we really truly left things hanging because we basically had. We basically had. Talked about the existence of abstract base functions, I'm sorry, abstract base classes, ABC, and we said abstract base classes are classes in which some of the functions are not defined. That feels to me like, you know, we left it on a cliffhanger. Well, if they're not defined, where are they? Where are they? Well, we did talk about the fact, I guess, that they are implemented in derived classes. That is the only place. OK? So here's the example, we have this abstract base class, you can tell because it has these pure virtual functions. Just reminding you of the vocabulary. Here, there it is, pure virtual fun-ction. I better put it there, that's just too, too weird. OK. Pure virtual function Um, there's the example, and here is a a derived class. Here is a derived class. Now, the point is, and you can see that the implementation is done here. The point is that I could not declare a class rose that neglected to implement any one of those things. This serves as a prescription for implementation. Any question about that? Is that clear? So the base class serves as a prescription for the functionality and implementation of a derived class. Should I write that down? OK.  Alright, I will. Alright, so the abstract base class serves as a prescription for the functionality of any derived class.  OK, so in our previous example, where, you know, that we talked about the fact that, uh, we talked about polymorphism. Like a ball could have a display function, but a planet could have a display function as well. um, this is a way of saying that every derived class must have a display function and we'll see in a minute, um, an example where that is pretty cool. Alright, any questions about what you see here neglecting this blue box, the next thing we're gonna talk about is this blue box, so anything, yes? Uh-huh. Uh-huh. Yes. No, you do not have to use any kind of keyword to overwrite it, you're already saying. Keyword overwrites? No. No. No, no, no, no. I do not have to. This is a straightforward simple, nothing else is necessary, OK. Alright, anything else about this? Yes? Right, yeah we don't have to here. That's right, right. That's right. OK. Uhh, let's see. So lets talk about how we use this then. You can imagine, well, let's talk about how we use this. Can we use this? Can we declare a flower? No we cant. There shall be no more flowers and the reason for that is simply that flower is not a complete class name. Flower is not a finished class. Can we do this? Sure, of course, right. This is. Now we have all the functionality we need, so this is fine. How about this one, can we do this. OK? We can still do this one so that might be a little counter intuitive. We can't have a flower, but we can have a flower pointer and the reason for that is we already said that a declaration like this OK.fptr equals new flower. And it looks like I only have a default constructor there. OK? Any question about it? Yes?
ok so last time we were talking about inheritance and we really truly left things hanging because we basically had talked about the existence of abstract base function or I'm sorry abstract base classes. a b c we said abstract base classes are which some of the functions are not defined ok so that feels to me like.. you know.. we left on a cliff hanger well if not defined where are they? well we did talked the fact I guess that they are implemented in derived classes and thats the only place. ok so heres the example we have this abstract base class i can tell because it has the pure virtual functions. just reminding you of the vocabulary here there it is pure virtual fun..ction i better put it there thats just too weird.ok pure vitual function hmm. thats an example and heres a derived class. okay now the point is as you can see the implementation is done here . the point is i could not declare a class rose that neglected to implement anyone of of those things. so this serves as a prescription for implementation. okay any question about that? is that clear? so the base class serves as a prescription for the functionality implementation of a derived class. should I write that down? ok i will. alright . so the abstract base class serves as a prescription for the functionality of any derived class. ok? so in the previous example hmm you know where we talked about the face that hmmm. we talked about polymorphism where a ball could have a display function and a planet can have a display function as well hmm this is the way of saying that every derived class must have a display function. We will see it in a minute and the example of that is pretty cool alright any questions about what you see here neglecting this blue box. the next thing we will talk about is this blue box so anything? yes  no you do have to use any kind of key words to overwrite it. You are already saying keyword over writ.e no no I do not have to. this is straightforward simple. nothing else is necessary.okay? alright anything else about this? yes? right, yea we don't have to here. thats right thats right. okay. hmmm lets see. So lets talk about how we use this then you can imagine,well, lets talk about how we use this. can we do this? can we declare flower? no we cant there shall be no more flowers,okay?and the reason for that is simply that a flower is not a complete class name.okay the flower is not a finished class. can we do this? sure of course right, this is , now we have all the functions we need so this is fine,how about this one? can we do this? ok , we can still do this one. okay so that might be like a bit counterintuitive there.can have a flower but we cant have a flower pointer. and the reason for that is we already said the declaration like this is okay. fptr=new flower. that looks like i only have a default constructor there. okay? any question about it? yes?
hmm so we..so yes there's a jump here. you didn't know when I first talked about inheritance why i was telling you that it was ok to have a pointer type, base class pointer on the left and a derived class pointer on the right you didn't know where I was going with that but you did talked about the fact that that was okay. So this assignment is okay because the thing that we were making is a flower we are building up flower at this point. right here. Im sorry. this is wrong, this is wrong thats why I almost broke your brains.I am so glad you asked this question.what could I have said that would have been not very confusing here. daisy very goo thank you oh my gosh. the whole point of the whole slide was the word i wrote here and I screwed it up great ..come back next hour that mistake would not be made or maybe it should be. ah maybe I should have do them on purpose just to see if people are as awake as you. alright.alright, so everything i just said is true still. Its still okay to declare a flower pointer cause there's no flower constructed there it would not be okay to say that new flower here cause we can't build the flower but we can build a daisy, we can plant a daisy okay? alright any questions about this? you should have more questions i think yes? theres no slicing so we make a daisy, right , right, so the things is thought, so the problem is once you do this daisy, you don't have daisy's specific functionality but you do have access to any polymorphic function. so when you prescribe what functionality it has to have, you know they are all gonna have it anyway and they are virtual,and, so we can't reach them through flower pointer. Does that make sense? because there, the,the functions are declared in the flower,okay? hmm,oh,lets talk about it later,cause lets talk about it later, if they encourage it to go experiment. okay, so heres the thing about inheritance, you see it about twice in this class about twice.. well maybe 3 times. We are doing it mostly because you are gonna see it in your life not because you need it a lot for data structures in the our context so sort of, we are trying to do is increase your curiosity about it. give you a little bit of functionality, and then, move on to the stuff okay, so I encourage you to go experiment , but i wanna stop it. okay, all of that said,, hmmm, notice that , oh i have a question for you, what if i had done this,yea? ah-ha?  hmm,no that presence of that equal zero do the same thing. okay?  if it is one of them equal zero, it is an abstract base class, okay? alright, can I do that? did you see what i did? this equals zero, can i do that? ignore the blue box, now can I do it? yes, i can. But then i can't do them, i have no daisy, right? what this demands is that i derive from the daisy class and further specify well, is it a gerbera daisy or freeway daisy right? so this demands that we'll be specific about the kind of stem that we draw apparently okay, any question about it, yes? oh there may be sort of some redundancy there, infact i don't think the compile will let you say equal zero without putting virtual
Um, so we already, we yes. There's a jump here. You didn't know when I first talked about inheritance why I was telling you that it was ok to have a pointer type on the left. A base class pointer on the left and a derived class pointer on the right. You didn't know where I was going with that, but we did talk about the fact that that was ok. So this assignment is ok because the thing that we're making is a flower. We're building a flower at this point. Right here, I'm sorry, this is wrong. This is wrong, that's why. I almost broke your brains. I am so glad you asked that question! What could I have said that would have not been confusing here? Daisy, very good. Oh my gosh. the whole point of the whole slide was the word that I wrote here, and I screwed it up. Great. Come back next hour, that mistake will not be made, or maybe it should be! maybe I should do that on purpose. Just to see if people are as awake as you. Alright. So, everything I just said is true still, it's still ok to declare a flower pointer, cuz there is no flower constructed there. It would not be ok to say new flow, because we can't build a flower, but we CAN build a daisy. Alright, any questions about this? You should have a question I think. There's no slicing, so we make a daisy, right? Right, so the thing is though, the problem is that once we do this daisy, we don't have access to the daisy specific functionality, but you do have access to any polymorphic function, so when you prescribe what functionality it should have, they're all going to have it anyways because it's virtual, so we can reach it through the flower pointer. Because the functions are declared in the flower. Let's talk about it later, and i encourage you to go experiment. So here's the thing about inheritance, you see it about twice in this class, well maybe three times. We're doing it mostly because you're going to see it in your life, not because you'll see it a lot in data structures in this concert. We're trying to increase your curiosity about it, a little bit of functionality, but not a while lot. I have a question for you, what if i had done this? No, the presence of that = 0 does the same thing. If there's one of the =0, then it is an abstract class. Can I add an equal 0? can I do that? Yes, I can, but the I have no daisy. What this says is that I derive from the daisy class, well is it a Gerber daisy or a freeway daisy?This demands that we be specific about the kind of stem that we draw, apparently. Any questions about it? There may be some sort of reduncy there, in fact I don't think the compiler will let you say =0 without putting virtual  f
So we already, yes there is a jump here you didn't know when first talked about inheritance why I was telling you that it was okay to have a pointer type, a base class pointer on the left and a derived class pointer on the right You didn't know where I was going with that but we did talk about the fact that that was okay So this assignment is okay because the thing that we are making is a flower We're building a flower at this point Right here, I'm sorry THIS IS WRONG, this is wrong that's why I almost broker your brains [pause] I am so glad you asked this quesiton [pause] What could I have said that would have been not confusing here? Daisy, very good. Thank you Oh my gosh The whole point of the whole slide was the word that I wrote here, and I screwed it up Great, come back next hour that mistake will not be made Or maybe it should be? Maybe I should do that on purpose? Just to see if people are as awake as you [transition words] Everything I just said is true still, it's still okay to declare a flower pointer because there is no flower constructed there it would not be okay to say new flower here because we can't build a flower but we can build a daisy, we can plant a daisy Any question about this? You should have a question I think Yes? [question] There is no slicing, so we make a daisy [question] So the thing is though, so the problem is that once you do this daisy you don't have access to the daisy specific funcitonality but you do have access to any polymorphic function So when you prescribe what functionality it has to have You know they're all going to have it anyway and they're virtual So we can reach them through the flower pointer, does that make sense? Because there the functions are declared in the flower [question] Lets talk about it later and I encourage you to go experiment, okay? So here's the thing about inheritance, you see it about twice in this class Well maybe three times We're doing it mostly because you're going to see it in your life not cause you need it a lot for data structures in our context  What we are trying to do is increase your curiosity about it, give you a little but of functionality and then move on to the stuff the course is actually about So I encourage you to go experiment but I want to stop it Okay, all of that said  Notice that , oh I have a question for you What if I had done this? [pause] No that presence of that = 0 does the same thing If there is one of those = 0 it is an abstract base class Can I do that, did you see what I did? I added this = 0, can I do that? Ignore the blue box, now can I do it? Ignore the blue box, now can I do it? Yes, I can but then I can't do , then I have no daisy. What this demands is that I derive from the daisy class and further specify, well is it a Gerber daisy or a Freeway daisy? So this demands that we be specific about the kind of stem that we draw apparently. Any question about it? [question] There may be some redundancy there, in fact I don't think will let you say = 0 without putting virtual. [question]
You only use virtuals if there is a chance that it is a base class. Furthermore, if your class is available, you do not really know whether it is going to be a base class or not because that is a part of the design.  Where you can strongly argue that virtual is not necessary, you should eliminate it because it will make faster code. So use it judiciously. Anyway, so here is an example that I think is really cool. I am going to declare a farm, it is not unlike a garden, but it is a collection of animals. Notice what I can do here. I can use this pointer to represent an array. When I instantiate it I can declare it with square brackets to make a dynamic array. And I can let every element be of type animal pointer, each of which can then be instantiated with a different derived animal.  So, when I actually fill in the value of farm sub k I say new animal sub whatever or animal whatever. So, new pig, new horse, new cow. Alright, notice what this is. It is an array where the things are not necessarily the same. So this is the way that you would implement what is called a heterogeneous array in C++ So this is a heterogeneous array. in C++ Not all elements have the same type. But it gets cooler than that, because it means we can do things like this. The polymorphic behavio The polymorphic behavior and the ability to insist that that function be defined means that we can demand that each of those classes has a speak function and that they are instantiated in a class specific way. So what happens for this for loop? You get 'barf, oink, nay, moo, quack'. Alright, so we already talked a little bit about the fact that inheritance gives you this polymorphic behavior at the significant cost to performance, because at compile time the system has to look at the code and see what kinds of things might require this polymorphic behavior, and it has to build the machine code for all of it. So that makes for bloated machine code. Now that is called dynamic polymorphism, where you might not know at the compilation of your code what kinds of things this will be instantiated with and you do not need to know it. So that comes at a performance cost. There is another kind of polymorphism that because of this performance issue was introduced into the language a little bit later. It is implemented via this construct called templates. And it is a kind of polymorphism where all of the type dependent information is known at compile time. So there is no ambiguity and there is no need to build in this flexibility at compile time. So that is our next topic. Templates. I have some code. Here is my main. I am using some integers and some characters and I have got these two functions that swap them. There are my two functions. What do you notice about the code. There are 2 germane points to be made.
Yes? Yes very good. So err the code is identical except for type information. Okay what else do you notice about this code? Yeah. You. Very good. Yep. It actually doesn't do anything! Neither function actually does anything. Okay and how could I fix that. I will fix that one first. How could I fix that? Pass by reference. Very good. Don't say pointer to me. Alright, good. So let's talk about the first point in a little bit more detail. So this is fine, right, to have these two functions that do pretty much the same thing.  In fact if somebody were asking you to include these two functions in an mp you go 'oh yay they're about the same I can cut and paste'.  I can cut and paste my solution from one and I got the other one done. Yes, right? The problem is that then you have to go back through and kinda check and make sure that your type information is updated correctly. Now the compiler's gonna help you mostly with those kinds of bugs but it's still a pain in the neck. And in fact if somebody, if somebody came down and said 'there is new technology for swapping'. Okay? Unlikely to happen but it could.  Somebody came down and said there is new technology for swapping. Drawback of doing it this way is that you have to go find all of these little swap functions and change them, right, to take advantage of this new swap algorithm. Okay. Yes it's artificial but. Alright so code reuse is important for maintenance and incremental improvement of codes. Okay? And we admit here that look they are about the same. So how on earth are we going to unify those two functions into one thing but still allow for type information to be err recorded in the code? And the answer is that c++ provides syntax for passing as a parameter hah my gosh type information, type information into the function. Okay? Alright, so how does this work? I have my same main except that I'm writing a single swap function. The way we, the way we tell the system exactly how we want swap to work is we have this alternative syntax for, alternative syntax for parameterizing type, and we put it between angle brackets. So first you have the type parameters and then you have the value parameters, okay? Similarly here we would do char. And I'll tell you right now that if you forget to do this, when the compiler can it will infer it for you. So sometimes it's not the case that you'll see those angle brackets even for a templated class. Okay so the system can infer it , it will. Okay. So now that's how you use these template functions, how do you define them? Well you prepend the function signature above the, above the first line it becomes the first line with this keyword template. This is a keyword. Class which is also a keyword but it could be typename instead.
Yes? Yes very good so uh the code is identical except for type information. ok. what else do you notice about this code. yea. yea. you.  very good. yeup it actually doesn't do anything. neither function actually does anything. ok and how can I fix that. well fix that one first. How can I fix that. Pass by reference. very good. Don't say pointer to me. Alright good. so lets talk about the first point in a little bit more detail. so this is fine right to have these two functions that do pretty much the same thing. in fact if someone were asking you to include these two functions in an mp, you'd go. oh yay. They are about the same. I can cut and paste. I can cut and paste my solution from one and I've got the other one done. yes right. the problem is that then you have to go back through and kind of check and make sure that your type information is updated correctly. now the compiler is gonna help you mostly with those kinds of bugs but its still a pain in the neck and in fact if somebody came down and said there is new technology for swapping ok. unlikely to happen but it could. somebody came down and said theres new technology for swapping. A drawback of doing it this way is that you would have to go and find all of these little swap functions and change them right to take advantage of this new new fangled swap algorithm. ok. yes its artificial. alright so code reuse is important for maintainence and incremental improvement of code. ok. and we admit here that look . they are about the same. so how on earth are we going to unfiy those two functions into one thing but still allow for type information to be recorderd in the code. and the answer is that C++ provides syntax for passing as a parameter type information. type information into the function. ok. alright so how does this work. I have my same main except that i am writing a single swap function. the way we tell the system exactly how we want swap to work is we have this alternative syntax for parameterizing type and we put in between angle brackets. so first you have the type parameters and then you have the value parameters. similarly here we would do char and I'll tell you right now that if you forget to do this when the compiler can. it will infer it for you so sometimes its not the case that you'll see those angle brackets even for templated class ok so if the system can infer it. it will. ok. so now that's how you use these template functions. how do you define them. well you prepend the function's signature above the first line. it becomes the first line. um with this key word template this is a key word. class which is also a key word but it could be type name instead.
... and you will see type name. And, the reason I put class there is because of pure character. And that's what I am optimizing for sometime on the slides. So template class T or type name T, and then T is effectively a type variable. So every place you see T in the code, especially when it is in the type location. The type variable T is replaced with whatever you give to the function through the template parameters
know what's this? Here Um Try to draw this space shuttle. Ok, that's kind of what I (want)... I don't know. You can put rocket ships in there. Spaceships, right? Spacecrafts. I think I used to no more spacecrafts than I do now. TIE fighter, X-wing fighter... No? Isn't it obvious? What's number one? What? It's the Enterprise. That's right Alright, I have to know I have to know this. I have to know this, okay? So, yes, here is the TIE fighter. I think; I don't even know really for sure. And this is the Enterprise. Doesn't it look like the Enterprise? Which of those do you like better? Okay, this is a deep deep question. This is a deep deep question and it's gonna affect our relationship, okay? Just let you know. Raise your hand if you like... If you are a War's person. A war's person or a track person. It's gonna be the alternative. War's, star wars' person. You had to choose. A star trek person? Hey, did you see half and half. Neither? Okay. I gotta go with star trek. Okay Alright, oh, man. The point is you can put anything you want to in these things. You can put anything you want to in these containers because you can parameterize type. Yeah?  Next generation all the way... Of course. Yeah. Okay, what's this? Right, this is a linked list. This is actually... this is actually these structure that you are going to be manipulating for MP3. Okay? MP3. Each one of these little arrows there is a pointer and the point of MP3 is to get you frustrated in manipulating these pointers, okay? Now, we are gonna talk more deeply about these particular structures starting next week and sort of give you some classic things to think about. But, so if I [is] to say now, at this point, really all you should think about these things as boxes that have pointers and that you have to, you know, that you have to tangle with.  Okay? Alright, I don't expect you to... and oh, and the point is...  It's a stupid joke but I feel like, every time I say point, like pointer... Uh, the point of this exercise is that we can put in here anything we want, like integers or pixels. And, the connection to MP3 is simply that we are asking you to implement something that manipulates pixels but testing that code would be a pain in the neck. So we strongly encourage you to get the code working with integers and then re-parameterized the thing... generalize the parameters so that it well take pixels as well. And the magic will be whala, that now, that your same functions can be used to manipulate images, okay? That's MP3 in a nutshell. Alright, this one serves to provide four shadowing to the rest of the course which is very data structure centrics. See, you can look at that and go wow, there is a lot of structure to that illustration or to that class, to the data that it contains... And our point will be not to care about what goes inside of here but rather what is the characteristics of the structure itself. So we will be thinking very loosely about the types of the things and more concretely about how they are ranged, okay? Alright, so classes can be given templates to... uh, how do you do that syntactically. That was really just inside and uh, you know.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Welcome to the rest of the semester. Er, how do you do that syntactically? Much like you do for functions, you preface the class definition with a template syntax, ok you warn it(?). And then anywhere you see a T inside, anywhere you see a T inside the class it is replaced with whatever you happen to put in. K? Alright, so let's look at this code in a little bit more detail. Right, so I'll pull out my list so I don't forget anything important and it's been a while. So... My notes are fantastic. They tell me Start with the blue code" Yay, okay! I'm gonna start with the blue code. Ok? Er, so I'm declaring one of those things and I'm recognizing that it needs a type. Now you can tell from the name that it's a pair of integers. Ok? The variable is - so this is the variable name, so variable twoNums has type ezpair of integers What is this? What's going on here? What's going on here? I'm - right. I'm using a constructor. Right? I'm using a constructor. So I should look up here and go, oh yay, the ezpair class has a constructor that accepts these two things. Now at this point I think, you can probably guess what that constructor does it simply, takes the two arguments and uses them to instantiate all the member variables. Ok? That are right here. So this, comes from there. And the constructor. Any question about that? So far. I think you will have questions, but let's keep going. Alright, so now we also have declared getmax. What does this version of getmax return? What does it return? A T? It's not a T. This code doesn't know anything about Ts. Right? It doesn't know anything about Ts. So what does it return? An integer. That's right. That returns an integer. Ok. Er... let's see... So I wanna emphasise that point. That this code, once you instantiate the template, you don't have to use that again. Right? You've already told the class that you want an ezpair of integers. It is as if, now, this is the name of the class. You don't have to keep reminding it that you're talking about integers It's like this is the name of the class. If we had said ezpair char, that would have been the typename and if I had said getmax and this was an ezpair char there would have been no ambiguity. K? Just like display, there would have been no ambiguity. Yeah? Um, so I think the compiler, so if you just said ezpair here the compiler would infer what you mean so you wouldn't have had to do this but I actually - when I read code it helps me a lot to have that there. So yes, it's optional for functionality, but it's, erm it's important for maintainability. K? Alright, so lets see... So let's talk about getmax. So if you execute this code what do you get? You execute this code what do you get? Take a look at what getmax - oh, getmax is funky What would you expect if you couldn't see that code up there what would you get? A hundred that's right. Now lets go look Now let's go look at the code. Alright. So getmax is implemented to return an integer, right or to return whatever the parameterized type is and, er, it sets up a value for return What is this?
Yeah we refer to it as a yes you wanna tell me instead of me telling you? Say it loud. It's an if statement, that's right. That saved me three lines of code right there which is important here. Oh I don't what I intended for this but it feels like it was important. Actually the reason I did this is because I want you to see it, right. I want you to know that it exists. This is called a ternary operator and it effectively in very very simple cases replaces a conditional. So this is a shorthand conditional. Okay so it says if this then return a, otherwise return b and then assign that by return value across the equal sign to retmax and then return retmax. Okay there's something that should bug you about this code. It's very very subtle. And the way to think of it is think of all the things that come in pairs. When I say name something that comes in pairs, what's the first thing you think of? Shoes, okay, okay fine. It feels like then that we should be able to instantiate ezpair with shoes right? The shoe class. Right? What would happen for getmax if we did that? Yeah? That's right, very good, so did you here him? He said he made note of the point, I don't know what greater than means for shoes. I know what it means for integers. I can guess what it means for characters. I have no idea what it means for shoes. Um and so the implication of that is in order for that code to work on the shoe class, we would have to have overloaded the greater than operator. So the greater than operator must be implemented in any class using, wait, any class passed to is the right way to say it, ezpair. Okay? Alright so it feels like a restriction but it's okay and the really good news about it is when the mistake is caught. Okay so if we tried to use ur ezpair on the shoes, who would tell us NO NO NO you can't do that? Who would do it? The compiler, that's right. The compiler would say I know you want to use ezpair on shoes but you can't. You need to define a greater than operator in order to do so. Okay? Any questions about that at all? So is a compiler demands that er this exist. So the compiler has to be able to look at all of the code, all of the code and determine exactly what functionality it means. Yes? twoNums, it's an variable, this is a variable. It could be frog, it could be Alex, it could be... It's just a thing that holds two numbers. Yeah, sure! What about it surprises you?
No. So how do you declare type. When I say int x(5), okay, this is simple syntax right?  For declaring an integer. So I want to this for all of you, because I think it's a germane point, okay, it reinforces something good.  When I say int x(5), x's copy constructor, which is implemented for us for integers is invoked And x is instantiated to 5, ok? Not a copy constructor, It's constr- you can do this. There is a constructor for integers that will allow you to do this Ok? Now, it's probably an assignment Now, look at how this matches. This is type, this is name of the variable, this is parameters passed to the constructor, ok? You got it? Same thing here, this is the type of the variable, this is the name of the variable, these are the values passed to the constructor.  Ok? And there's that constructor. Any questions? You need that name and then from then on, two nodes is one of those things, could've been frog. Alright, so there you go. So this is how you will be writing your code for MP3. It's a templatized class.  The List class is a templatized class. Ok, I have some challenges for you to do, let me see where I'm going here. Look, we're almost done! Ok, go for it, spend a couple minutes on the three challenges on the bottom.       Oh! That's the other thing to say about MP3. We want you to struggle in isolation. It's a solo MP3, and to clarify what that means, it means that you can draw pictures with a friend, but that sweaty time of debugging, and actually crafting the sequence of commands that wiil fill the pictures that you draw on the white board, those have to be done on your own, or in the presence of course staff. Ok, so don't work with your friends while you're writing the code. You can draw pictures all you want, but if more than two eyes are on the code, then that's probably not valid collaboration case. Ok? And yes, I recognize that two people can close their eyes, close one eye, ok,  That's not okay. Alright, how's this going? Anyone want to write solutions on my tablet? That'd be great. No way?  Ok, anyone want to write their solutions on my - alright, fine. I'll do it.  Challenge 1: write the function signature for the copy constructor, oh brother. It's called ezpair, and the name of the function 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
So how do you declare a type? When I say int x(5):"  This is simple syntax for declaring an integer. I want to do this for all of you because I think it's your main point. It reinforces something good. When I say int x(5), x's copy constructor, which is implemented for us for integers, is invoked and x is instantiated to 5. Not copy constructor. You can do this. Let's just say it that way. There is a constructor for integers that will allow you to do this. Now, it's probably in this assignment. Look at how this matches.  This is type, this is name of the variable, this is parameters pass to the constructor. You got it? Same thing here. Type, this is the type of the variable, this is the name of the variable, these are the values pass to the constructor.  and there is that constructor. Any question about it? You need that name and from then on towNums is one of those things.  could've been fraud. Alright. so there you go. so This is how you'll be writing your code for mp3.  It's templatized class. The list class is a templatized class.  ok. I have some challenges for you to do. let me see where I'm going here. Look we are almost done. Ok. Go for it. Spend a couple minutes. spend a couple minutes on these. On the three challenges at the bottom. That's the other things to say about mp3. We want you to struggle in isolation.  It's a solo mp to clarify what that means.. It means you can draw pictures with friends, but that sweaty time of debugging and actually correcting the sequence of commands that fulfills the pictures that you draw on the white board.  Those have to be done on your own or in the presence of a staff. So don't work with your friends while you are writing the code.  You can draw pictures all you want but more than two eyes are on the code than that's probably not a valid collaboration in this case. Alrignt. How is this going? Anybody want to write their solution on my tablet?  Anybody want to write their solution? Alright. Fine. I'll do it. Challenge 1: write the function signature for the copy constructor. It's called ezpair and the name of the function
[Silence] Question is, where do you need the angle brackets? [Video Playing] Template, class T, ezpair T, here is the only place you don't need it, in the function name itself. [[s Const, ezpair T reference, what do we call it? Copy constructor, so it's orig. Raise your hand if you happened to get that right [Video Playing] How do you declare a dynamic array of mypairs of integers? So this part down to this line, challenge 1 is related to lecture for today. These two are review because you have this exam coming up. How you declare a dynamic array of mypairs of integers. So this is a declaration, not a definition, not an instantiation. So I want to declare this thing, what should we call it. It's a declaration so it needs a name.  [Video Playing] Dynamic array, I'm gonna call it ma", my array [Video Playing] I want a dynamic array of mypairs of integers [Video Playing] How do we do that? [Video Playing] I think this should be ezpair [Video Playing] Alright, the dynamic part gets an asterisk, and ezpair of integers, is the kind of thing you're gonna put into it [Video Playing] So, now you've got this array we declared. I guess this is not review. And inside is 2 integers. 175, each one of them has a pair of integers in it. Alright any questions? Okay, how do you allocate memory if you want that array to have 8 elements? So, ma" equals, I know I want "new", I know the last thing is going to be 8.What goes inside? [Video Playing] Ezpair, int [Silence] Any questions?  [Question being asked] It does, it doesn't point to it, it contains it, it contains an ezpair
Alright, you ready to work?  Okay, I think I'm ready to work, let's do it Um Okay, so today's the first official day that I'm announcing next week's midterm.  Um, it's on Wednesday night. So, those of you who have sections on Wednesday might be a little confused. Should I go to section or should I go to the exam.  I think you should probably go to the exam. Um, and what we're going to do, what we're gonna do for you is um, give you a attendance, the people for whom there is this conflict, if you go to the exam instead, we'll give you credit for attendance of the lab. The lab will still be due, there will still be work due on Sunday, just like every week. Um, but you just won't you know be able attend the lab section to do it. You are welcome to attend any other lab.  Um, this is kind of a new thing for us, we don't know how this feel this yet. We always do our exams on Tuesday night, but the room, the space wasn't available, so we couldn't, we couldn't do it like we usually do. Um, so, let's see. So there are additional things that go along with this.  Um, class is canceled, so the, the lecture is canceled that day.  Lab, moved, okay. You can go to any other lab you want and we'll give you attendance automatically Um, and there will be review sessions going up to it In fact, the first review session that you should know about, the review sessions are these  There's one that meets at 11 AM And, one that meets at noon Uh, can you guess where? Yeah, here On the day of the exam, yeah, cause we have to cancel class, but we figure that it's a good time to just meet anyway optionally Um, we'll do other reviews too, that's kind of just a little joke, right? Class is cancelled, but we're gonna work on anyway Alright. Uh, any questions about the exam? There are sample exams posted I believe, I'll have to double check and make sure that's true. Um So for years, the format of the exam has not changed But, we're writing all new, all new exams, and we're gonna have new exam procedures, things are going to be a little different this semester, so i actually don't know exactly what the exam will look like yet, um I think it will probably be similar format though, so multiple choice questions, some short answers that are based um on lectures, some short answers that are based on labs, some short answers that are code, largely coming from the MPs. So, that's kind of what these exams are like. Uh, alright, any questions At this point. Yes.  The rooms are TBA, um, cause we have this script that we run that allocates people into rooms, and we just haven't run it yet, so it will be announced on the website and on the piazza Okay? Any other questions about that?  What What's the giggle Oh yeah, exactly, pretty much You can figure it out, you figure out where to go If you didn't do the second lab you're toast. Okay Um, let's talk about templates Everybody good? Monday is monday, you know? This is tough here It's tough crowd today Talk about templates Alright. So I think at the end, so last time we were talking about um templates, and we got pretty much through the material, um there are a couple little details that I want to talk about, and we're gonna revisit them and a sort of rich, use for them in another week or so So, we're gonna leave C++, and, and moreover templates are our last C++ topic. C++ specific topic So, today is the day, today is the day, we actually start the data structures portion of the course. Yayy The day of celebration for me, but we have some loose ends to tie up. Not that I don't like C++, but. 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
So I did something this weekend.  I've never done it before, and its incredibly empowering. I signed up for an amazon EC2 instance and installed my own web server, and got my website running on it all by myself. Up until this weekend I had no idea what a web configuration file was or a server configuration file. I didn't know what httpd meant. And I just feel like I'm a bigger person today because of it. It is really empowering. This thing that we do, its a blast! Alight, I thought I would share that with you. Its one of those intimate moments between friends. Okay, so lets talk about templates. Why did that occur to me because we are leaving behind the C++ portion of the course and moving more into the abstract data structures. A little more mathematical portion of the course. So I was waxing about the fact that I like to program and I am going to miss it. But, here we go anyway Alright, so the couple of little things you notice about this immediately. You might have wondered about last time or we might have talked about it but I can't remember. Its  okay to pass more than one type. More than one type as a type parameter to a function or to a class. So what you see here applies to a class template as well. Any question about the function addEm? Addem. No questions about the function addEm. Its okay. Alright, now I of course have questions for you. I want to know how this does. So look at this client code, the code that uses addEm and speculate on what each of these function calls returns. Speculate on what happens when you run this code or when you compile this code. Okay what happens when you've compiled this code? What do you think? Works fine? It doesn't work and it doesnt compile. Tell me why? If these are the line numbers in the code and the compiler tells you what line fails. Which of those fails? Four. Thats right. So, suppose I get rid of line four. So line four doesnt compile because. Actually, well someone else describe it. Say my sentence for me. Somebody raise their hand and say my sentence for me. Why does line 4 not compile? Why? Yes ? Right, operator plus is not defined for strings plus integers. Good. Not overloaded. Okay fine. Suppose I get rid of line four then do you like it? So  I am going to get rid of line four. Then do you like it? Way in the back, do you like it? Also, line five the compiler doesn't like. Okay, so again operator plus is not defined for the alternative order as well. Okay fine. Then just to double check very quickly. Now assuming that this code compiles, tell me what the output is when we run it. Whats the output of line one here? Seven. Good. Whats the output of line two? 7.2 thats right becasue the first template. The first template variable is the type that is returned. So you get 7.2 How about here? Line three. Right it truncates to integer. Good. Any question about that? Alright, so I want to talk a little bit more about the compliation process. Because it kind of changes the way we do buisness. So, I am going to give you kind of a diagram of compliation as we done up until this point. So, imagine that this purple box includes the code for sphere.h and the green box includes the code for sphere.cpp. And the blue box is client code or main.cpp in this case. Okay. Now, our complilation process combines these two compiles sphere.cpp. And the way that it knows about header is because we have pound included sphere.h here. Okay, any questions about that. So we can compile those files together into a .o file.
There we go, ok? And it's executable code.  Ready to be linked with anybody who would like to use it. Alright, fine. Well, I know somebody who would like to use it. This main would like to use that compiled code. All that has to be done, is sphere.h has to be included, oops. Sorry. #include, sphere.h here. And then these two, are effectively compiled together. Into main.o. And, how do we get sphere and main linked? Yeah, the linker does it for us.  So, it's the linker that creates the union between main and sphere. Ok? And, that whole process is sort of orchestrated for you by the makefile. That's the whole point of the makefile. So, that you could do all that seperately, and then put it all together. And, not have to type it out every time.  When you're trying to compile your code.  Now, the world is a little bit different. In the case of compiling templates. So, again we've got sphere.h and sphere.cpp and main.cpp. But, if you noticed on the previous page, the compiler detected. The compiler could detect. That it didn't have a plus operator for integers and strings. And what's going on there. Is that the compiler needs to know ahead of time, exactly how, and so you got a compiler error. The code for the addEm function, was not created. Now, the reason that that happened is because, The code for all of the use of your template functions, Must be visible to the compiler, all at the same time. That means that, main cannot be compiled separately from sphere.cpp.  And more importantly sphere.cpp cannot be compiled separately from main.   More importantly sphere.cpp cannot be compiled seperately from main.  Because, in order to make the sphere class. You need to know how spheres are used. The type of thing that you're passing in to spheres. To use for its radius, I don't know. The parallel falls apart a little bit here.  Ok, so what do we do? The main principle is that we do not expect different behavior from the client codes. The client code is still going to say #include sphere.cpp, ok? H! Geez, sphere.h. We don't want the client to have to change. So, the client is still going to say sphere.h. But it can't just be sphere.h, it also has to be the implementation. So, how are we going to do that? What are we gonna do here?  Hmm.... When we compile this, we have to compile it all together, and the code has to be all visible. And we don't want to client to change code, change behavior. Yeah? Yeah. Look at this. The only thing we're including is sphere.h. So that's the only code we get. So the only way that that include statement can include all the sphere class definition. Is if we say, #include... sphere.cpp at the bottom of sphere.h. And now when you do this #include sphere.h, you actually get all the code. And then, you compile main.cpp, and all the compilation happens at once.  There's no use for the linker, in this case. Yes? Because the declaration of the class has to come first.  So you have to have the class declaration, the implementation of the member functions, and then the client code that uses them. Ok? Alright, yes?
Yes, if you don't have a template, then yes, So more efficient isn't really the point. The point is in practice. If you do it the first way, and then someone came to you and said, I need a sphere class, Do you have one I could use? In the first case he can say yes, and you can give that person a compiled sphere class that they could use. As long as he also gave them the header file And not have to expose the implementation In the second case, you lose that and in fact, in my mind, from a software engineering perspective, that is kind of the cost of the template instantiation. You kind of lose a little bit of your elegance. Alright No, so the pound include thing is a string substitution, so You could do that, you can say #include sphere auto, but you would get code that you don't ever want to look at That would'nt be interpreted correctly That can't be parsed or processed. Um, so the question is can you use the same make file, um and the answer is that you would have to get rid of the sphere target, because you can't compile this sphere seperately, but that you could Yes? You cant change it In the client code, yes anything that is private is still private, its just that you do expose it, you still show it I mean it is just code, so they could actually change it But, not in the client code, it would have to be using an editor or something Its a differerent thing, yes you have to expose your code Good question, ok so his question is very astute, he said how bout if we have the behavior in the class be the same, and then just make this #include sphere.cpp The answer to that is we want the client to not have to change what they do because of our implementation choice What do clients typically do? They make a list of all of the classes that they are going to use and look for their class definitions in .h files, so we dont want to impose that burden on them to go huh, I wonder if that's a .h or .cpp We just let them go to the .h file, you could yes, but functionally you shouldnt Any other questions? Yes Um, oh do you need to, Im gonna throw that back at you, do you think you do? Because then you will have the circular include Alright anything else? And I didn't, right? I did it right Alright anything else about this? Beating a dead horse, I've got something new Yayayayayay, we are doing something new today Um, i wanna move us to something new very slowly, ok because there are lots of points i want to bring up, take a look at my new struct here Um, and what I wanna know about it What I wanna know about it is what is this line What is that line Somebody raise their hand and tell me what that line is, there is a good way to describe it Good succint way of describing what that line is It's a constructor, thats right, its a listNode constructor very good, now when I actually declare a listNode, for example If i say, well look at this, listNode<int> nln(5) new listNode 5 What happens effectively is that this constructor is called, this data is oh look, put in the data field, and this next becomes what? Null, that's right, so upon this declaration, the result is this In general, what we have is this sort of rectangle that has two fields The way im gonna describe it, and always draw it, is a rectangle These two fields are going to exist here, and here Just the way I'm always going to draw these This one is a pointer, the other one is just, oh what is the other one? What is the other one?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
List item type, ok? So LIT there, list item type. You saw it as class T before. Alright, any question about that? Ok. Yes? Why not? This is C++ we're speaking here. Ok? So the c++ compiler will look at that struct and go oh I know what a struct is. It's just a class where everything is public. It's exactly the same thing and you can put functions in there too. Guess what? You can even put a private section in there if you wanted to. You can store dat- I mean you already do store data. You can put functions. It's exactly like a class, ok? Why did I do struct? Exactly so that you would ask me that question. Thank you. Ok. Yes? Uhm, oh you tell me. I'll tell you right now that this is a declaration. So what does it mean when you have a variable declaration? You've got a type, you've got a name. You might a param- an initialization parameter. It's just the name of my variable. Ok? So, you know if I were drawing this out.. here's nln. It's not a keyword, it could've been frog. Which at that point sounds sort of like a keyword. Alright, any question about it? Yes? Yea. Excuse me? Nope. No no no. Except to keep in mind who you're communicating with. If people expect a class you should use a class. If people expect a struct you should use a struct. That's really it. Yes? Yea. Yep. Alright, uh, or at least mostly so that it is. I mean maybe it's kind of convenient to not if you're making things with everything public. It's just, I don't know. It's class where everything's public. Ok, uhhh. Let's see... Here's what I want instead. I don't want this uhhh stack variable nln just sitting here. Instead I want this. Write me the line of code that you could use to create this in memory. Ok? So.. Instead I've got a pointer. Do you want me to give you a name for this? Ok, call it yum. I used yum a little this weekend so it's on my mind. Ok. Anybody want to write it on my tablet? You can. You want to try? Oh, mine's terrible too. It's kind of a pain actually. Sure. It's fun isn't it? He say's it's intoxicating. Good. Good. Anybody want to comment at all?  Yea I would be explicit probably the system will infer it but I would be explicit. So I would've put an int right here. That's all. Ok? Alright, any other questions about this? Good job.  Alright, now why did we do this? Why do we do this? We're going to admit that... this thing holds on to future ones of these. Ok? And we're going to consider a unit to be we're going to consider a unit to be the pointer together with the data in a sense. Together with this last box. So a unit in our structure is going to be one of these things. And then notice that that's what we have hanging off here. It's a pointer to a box. Ok? So if we do this. If we make this like this. Then every list node... is effectively the same. Ok? Here it's kind of you, you'd have to you'd have this case where sometimes it's null and sometimes it points to everything else something else. And so we're not going to do that. We're going to... uhm, for elegance sake hold on to the first thing via a pointer. Ok? Now, here's what I want you to do next. I want you to change this in memory into this. So write the line of code or two lines of code or whatever you need to make yum now instead point to this where this is what yum this is what yum used to be. Ok? It makes sense and you can work with the person sitting next to you to make it happen.
Who got it? Want to do it? Somebody want to write it? Okay, I'm going to talk loud and do it, okay? So I need to make a new, I need to make a new list node here whose value is six and I know just how to do that. It's going to something very much like this line. So this is going to be list node pointer new equal new list node... Oh, int six. Okay, I'm going to give myself clearance here, okay? You're going to want to raise your hand a hundred times over the next few days and say, You forgot a template!", okay? I hereby absolve myself from the responsibility for including every last template. If it looks like I need one here and here, please just pretend that I did it, okay? These are compiler errors at worst, so, you know. We're much deeper than compilers here. Okay, so I have list node pointer, I better not use-- that isn't new", that is n-u-u. Alright, new... u-u. Okay, it isn't the word new". Equals new list node six. Okay, so now what I have is something that looks like this... Right, and I have yum" over here. So here's six, here's yum" like this. Hmm... how am I going to do that? Hmm... this is n-u-u. Nuu dot next equals yum, good. And... No... what next? Good, and then yum equals nuu. Yeah? You like it? It's okay? Okay, because that means now nuu next, I'm going to do this in green. Nuu next equal yum, that means it points way over here. Right? And yum equal nuu, so... that means yum-- oh, wow! That was cool. Woah! That's really cool! Now yum points to nuu. And look! It looks just the same, right? Yum goes to there goes to back to where it used to be, okay? Any question about it? Alright, so if you have not started MP3 yet, MP3 is like... it is like a million of these kinds of puzzles in much more complex scenarios. Moreover, in MP3, instead of just having a next pointer, we also have a previous pointer going to the previous element in a chain of these things. Okay, so let's write, let's write a little bit more code here. We did an exercise that we probably want to generalize and replicate. This inserting something at the front. Okay, so here's what I'm going to assume is the setup. I'm going to assume that I have a series of these linked nodes and I'm holding on to them by a list node pointer called head. Okay? Any question about that? Is that alright with you? Okay, and we've already somehow built these up, kind of like we put the two together on the previous page, Now what I want to do is to write a function that, given a chain of these things, will just insert one at the front, okay? Alright, so let's do that. Hmm... How does this go? Do you want to write it, or shall I write it?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
I'll write it, so listNode pointer again, template's missing, you would have to put it there listNode pointer n = new listNode, what should we put in it? e, good! And so now, we've got this box called n, that looks like this, and there's a cow inside, alright? For our little example, now what? n's next equals curr, good, and then curr equals n, right, isn't that what we wrote on the previous page? This code is broken, is that what you're going to tell me? Oh, very good. Yeah this code is broken. Here's why: I slid one by you, okay? And we're going to see this lots of times, so I want to kind of go over it carefully. Alright, here's the deal. This code, as it's currently written, takes a pointer by value That means a copy is made of head, okay? Like this, we happen to call it curr. Okay? Through our manipulations, we assign curr to point to here, and this one points here, and then when execution stops, curr goes out of scope. So what happens? Curr goes out of scope and n goes out of scope, so we no longer have a hole on the front of this list anymore, right? On the front of this chain. Okay? We no longer have a hold of this chain from the front anymore. Okay. So how can we fix it?  What we want is for curr to be a different name for head. Then, when we change curr we also change head, the way to do that is by passing by reference Any question about it? Now, do I like this code? No, I don't, there's actually a better way of doing this, but I wanted to bring this potential for error up to you  If I were really writing this code, I would return a pointer that is the result of this thing being inserted at the front, rather than doing it by side effect, ok? Ok, alright, any other questions about this? How long does this take? How long does this take, what's the running time of this, ooh it's our first running time question! Okay, let's take a look at what the code does. The cycliant point here is that there is no iteration and there is no exploration, recursive exploration, okay? It is an assignment statement followed by another assignment statement followed by another assignment statement, okay?  Each of those will take, effectively, a fixed amount of time. Choose the slowest of them, probably the new listNode's going to take the slowest, I don't care. Choose the slowest of them, think of that as your constant amount of time and understand, then, that you can bound the running time of that entire function by 3 times that largest amount Now, the way we write this, is to say that it is constant even if we don't know what it is and even if it changes across machines Or, we write it as big O of one. Okay, so and the observation, the sort of back of the envelope observation, says that there's no iteration, no exploration.
Just a sequence of assignment statements that are going to be the same every time we execute this code. Alright, any questions about it? Okay, fine. Here's another one. 8 4 2 6 3. So suppose we built up this list; suppose we built up this chain of linked memory and this one is we'll call it head and we'll pass it in. We want to printReverse(head). So what we expect out of this is the sequence of printed numbers. We want this to return 3 6 2 4 8. Any questions about it? About what we expect this hting to do? Alright, here's what we want to exploit in this code. We want to exploit the fact that this chain of memory all linked together is a listNode pointer instantiated with the listNode together with another chain that looks just the same, that is just a smaller instance of the original problem. This situation begs for recursion, that's right. Any time you can break a structure down into something that is smaller than the original but has the same characteristics of the original, you're talking about a recursively defined structure. Alright, so that's what we have here and that's what we're going to exploit. So suppose I can print the reverse of this, the rest of the list. Suppose I know how to print the reverse of the rest of the list. How do I assemble that into a print the reverse of the whole list? Yeah? Very good, very good. So you print the reverse of... print, reverse of the rest of the list and then print the first node. Node's data, should be careful about that. Any questions about that? What's the base case here? Oh, we're in the world of recursion. No, that's right. What's the reverse of the empty list? Nothing right? There's nothing to be done. Alright, I think you just suggested all of our code here. So my code is going to look like this. If (curr != NULL) then I'm going to printReverse(curr->next) and then I'm going to cout <<  curr->data << endl.  
Alright, and it better have this. And nothing happens if it's NULL. Okay. Any questions about it? You like it? Yeah? Do I? I was going to ask you that! He said do we need to pass by reference? What do you think? No, because we're not changing anything about this list. We're just sucking values off for printing. Okay? So we don't have to in this case. Alright fine. Uhhhhh... This comment is in the wrong place. Any questions about this code? Okay. Let's talk about the running time. Kay, now we can no longer say that there is no iteration and no exploration, right? Uh-oh, we got a problem. So let's look at this holistically. Well there is a couple of different ways of looking at it.  We will look at it holistically first So I'm going to parameterize the running time by... uhh...a function by n. Okay, so the running time is T(n) Function for the running time is T(n). Now I don't know how long this thing takes, but I do know that it takes time. But the amount of time it takes to print the rest of the list Plus some constant sum of time it takes to print a single node, the data from a single node, right? I also know that the time it takes a list of nodes of size 0, or the NULL case, is  some constant amount Kay? Alright So there is our first recurrence Ohhhhh Raise your hand if you did not take CS173 or a discrete, if you're doing this without the  discrete prerequisite.  No, you don't have to raise your hand.  If this is unfamiliar to you, find a friend. Kay? Because this is...this is part of the prerequisite of the course Okay! So one of your friends who has already done this, what is the solution to this recurrence? What's the solution to this recurrence? T(n) equals I think it's n times c plus d, yeah? Yeah, alright! n times c plus d I don't know about you, I don't know about you, but this back to algebra one  Where y equals m x plus b Alright? f of x equals m x plus b What is this thing? It's a line Right? And in fact, if we can express the running time of a function in these, in this line We call it linear So the running time is linear In the size of the data And in big O terms we express it as big O of n And we'll talk more about the definition of big O later but suffice to say that it also is prerequisite from 173 Okay, any questions about that? You doing good, yeah? Oh boy I'm not in jogging shoes today   Ahhh, so the question is.. oh this is excellent discussion. Let's talk about this code a little bit So he's really worried about...he thinks that base case should be curr next not equal NULL right? okay But here's the thing
I said we said an empty list is our base case, right? And the only the empty list is the case where curr is equal to null, so the alternative case is that it is not equal to null. The general case is that it's not equal to null. So the list of length one is not the base case here. Even though, yes, it's true, even though yes its true the reverse of the list of length one is, you know, the list itself If I pull that off then I have to have two base cases, because if I'm allowing an empty list then I better handle it in the code. Right? Does that makes sense to you? Okay, so there something else I wanna ask. How do I know that this thing will not segfault? How do I know that this is okay, to call printReverse on the rest of the list, that there is a next, how do I know that? It's not null, thats right. We already checked as validation of the general case, the not base case, we already checked that it's not equal to null. Okay, so thats the sa-so dereferencing it is a safe thing to do. Alright, any other questions about this? Same with curr->data, you dont have to worry about dereferencing it Alright, uh, sorry for the scribbles and stuff there maybe the best thing the best thing for me to do is to go to the next slide. Okay. Alright, lets write this code too, really quickly. [pause] So this is going to end up being useful to us. This is going to end up being a useful function for us, because it turns out,  that walking around on these lists is a function that occurs anytime we're searching a list for anything. So the one that we're gonna want to write, the function that we're gonna write here is simply  given a position in the list, given a pointer to a position in the list walk k steps forward. Okay, walk k steps forward. Um, I'm gonna go ahead and write this code really quickly is that alright with you? Yeah? Okay. Let me get my notes so I don't screw it up. I dont have my notes I already lost them, I will screw it up -we'll screw it up together. Alright. [pause] So I'm trying to think how, okay, alright, so what is the  base case here? [pause] Yeah, k == 0, very good, or what if I called  find of, uh, on this list of 42 [pause] Oh, and notice we're gonna return a pointer to the kth the node we get if we walk k steps. I should do this, look, this is how this works find on head pause of 3 walks 3 steps, so theres 0 steps, 1 steps, 2 steps, 3 steps, and returns that pointer. Okay so returns a pointer to that element. Okay, any question about it? Okay Walks three steps forward. Okay fine. So, I'm going to say if k is 0, or if curr is null, then I'm just gonna return my current position. And in the case where curr is null thats fine it's an indication that we have walked off the end.
Okay, so that is either the current position. That is, when there are no more steps to be taken or it's an indication that we walked off. Otherwise, it's the recursive case, right? Otherwise, return the find of curr->next and k-1. You like it? Kinda boring. Why are we returning? Because I want a pointer to, I mean I want to return a pointer, I want to walk a pointer down case bases in the list because this one is going to return something. Wait! Before you leave, whats the running time of finding the kth thing in an array? Right? That is array sub k. That's constant time, random access memory allows you constant time access to a particular place. Soooo, that's a problem.
So that's either the current position that is when there are no more steps to be taken or it's an indication that we walked off Otherwise, it's the recursive case right? Otherwise, return the find of curr->next  and k minus 1 You like it? Kind of boring. Why are we returning? Because I want a pointer to I mean I'm returning a pointer to I want to walk a pointer down k spaces in the list Because this one is going to return something Wait before you leave What's the running time for finding the kth thing in an array? What's the running time for finding the kth thing in an array? Right That is array sub k That's constant time Random access memory allows you constant time access to a particular place So that's a problem. Yeah 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Okay, so that's either the current position, that is, when there are no more steps to be taken, or it's an indication that we walked off. Otherwise, it's the recursive case, right? Otherwise, return the find of curr->next and k minus one You like it? Kinda boring, why are we returning? Because I want a pointer to - I'm returning a pointer - I want a pointer to - I wanna walk a pointer down k spaces in the list. (Student question) Because this one is going to return something. Wait, before you leave, what's the running time of finding the kth thing in an array? What's the running time for finding the kth thing in an array? Right, that is array sub k. That's constant time, random access memory allows you constant time access to a particular place So, that's a problem (Student questions) (Class ended)
Ok Alright, let's work I am both proud of you and dissapoint of you today I am proud of you for coming here But I am just a little-tiny-tiny-bit dissapointed in you for coming here giving how beautiful it is out side So I am pretty sure... I know I know I know I know I know I know thank you for coming here I understand how It might have been difficult to walk over here and like come in the doors. Like, I can't see outside so emm, my, eh, my admonishment to you is to find a way some time today To breath these breezes, look at some trees, play some frisby with some friends Skip some other classes Oh.... Ok ok so the out side Emmm, alright, so here we are, yet here we are We have an exam coming up, if you have an academic conflict or you think you would like to convince us that your alternative conflict is worth discussing. Is something we should discuss, which I don't mean to trivilize it, no I shouldn't say it like that  It's always worth discussing If you feel like you have a conflict with the final or with the midterm 1 please send an email to Terry Emmmm That's his email address and please send it from your U of I account so that he has your netID, or at least be sure to include your netID in the email at the very least. Umm, so that's with conflict requests On Friday I should have a clear picture of the review sessions that are avaliable to you. One of our course stuff people want to do a review session tonight Like, that, it's too early We will try to do that in weekend some time, and if we dont please request them on piazza and then We will feel guity at least for not doing that  Alright, I think that's all I have, MP3 out there is due Friday night The early part of it will be on the exam. So you will be responsible for the material in the first part of MP3 on your exam Tell me your name one more time I think I know it but I don't wanna embarrasse myself.  Ahhh, really?  Does it start with an A? What is it? ??? Oh it's ???? and sorry I'm sorry You maybe embarressed by self, go ahead
um, yeah, the auto grader will still, will run on 3.2 begin Um, yeah, the auto grader will still, will run on 3.2 beginning on the 26th. Ok? No, i don't think so, i don't know, I don't know what actually got put into the grading scripts, ok? Yeah, it'll run for a week before the final due date. Ok, let's see, where are we, should we work on linked list? I think we should, Um, so  Um, so we had created this structure, we created this structure here of memory that is chained together ok, and I want you to think for just a second about this as simply that, memory that is chained together. Because this Designation of this thing as a linked list is merely sort of our culture's way of describing memory  Memory that is chained together, cause we don't like to say memory that is chained together every last time. Ok? Now  When you say linkedlist, you are not necessarily implying a particular implementation of a  Of a list, no, I'm sorry, that's exactly wrong. When you say linkedlist, you are implying a particular implementation of a   list of thing. Ok? And that particular implementation happens to be this sort of chained together  Um, chained together pieces of memory, nodes of memory. Ok, we wrote this code last time, we wrote this code last time, and um it works like this, it works like this if I have a set of memory that is all chained together and Um i designate the first thing as a variable called head, the very first memory address, as variable called   head, and if I say find k  On head, for, um, i don't know, two steps, find the second one effectively. What this mean, what I intend for this to mean is   please, function, return me the pointer that points, that effectively walks me forward, this  meant steps in the structure, ok? So, head curr in this instance, in this case begins here And the one that I'm going to return is the one that constant to walking to forward in the list. So   There's the pointer to something after taking one step, there's the pointer to something taking two steps, it is this one that    I want return in that function call. Any question about that? So it's sort of if your consider yourself be in the first walk forward two steps, yeah?  Um, so right now, he's asking I think about  where this code go, right? Ah ha, ah ha, yes, right, so um the, I'm gonna say it again That I'm gonna change the vocabulary just a little bit, ok, so if function like this is useful to you in  your, in your mp, where this is not a function in the globe scope, but it's rather a function inside the list class then it is true you have to declare it inside the list class. See you have to add that function's declaration to the list  class. And we'll actually see that later today when we do the same thing here. So it's pretty astute observation to see  that what we have here is a function in the global scope, rather than member function of some class, like a list class, ok?  Alright, last time we got far enough in this section to actually write down clearly we didn't, for find K. Maybe we didn't get this far. I can't remember Here's what I want to know, I want to know what's the running time of this function. That's a general thing that I want to ask, a lot of time that's how I ask the question What it means is i want the asymptotic running time that means approximation on the running time for input of size, some parameter N, ok. So I'm gonna write that down  here, just because I don't ever want you mystified for it. So when I say running time when I ask for the running time, of a function, what I mean is the 
asymptotic. asymptotic. that's not a p there. running time. that's in terms of big-O on a structure of size and now again I could write anything I want here. I could write k. I'm going to write n to differneitate it from k so I want. not asymptomatic but asymptotic running time. asymptotic here means big-O. ok uh running time, we'll write a function for that on input of structure of size n. ok alright so that means in this case, I'm asking if my linkedlist has size that we parameterize by n. my chained together structure has n elements.  my chained-together structure has n elements what's the very worst case for the running time of this thing could be? big-O of the worst case is we might have to look every element, right. we might have to look at every element and so the analysis the running time is big-O n. ok O(n). you want to talk about that more or is it ok? the way to think about it is how much work do you do at every node?" at every node, how much work do you do? well well, I look at it. and I evaluate whether or not I'm done and k is equal to 0. look at it and evaluate whether k is 0. look at it and evaluate whether k is 0.  that's the same every time. there's no iteration or exploration at each node so each node is just a constant amount of work for all the elements is c times n ok. too much talking... it's too much talking raise your hand if you're kind of worried about k in this. you're a little bit worried about k. you're not worried about k at all? ok. alright. so k is. k is a particular input to the problem the very worst k that somebody could give you is no worse than n because this thing is going to bottom out at when uhhhhhhh current is equal to null it's going to stop at the end of the list so even though k could be 593,000,000 or a two element list, this thing is not going to run that far so it's bounded by n. n is the worst thing we need to consider ok. alright. uhhhh let's see. how long does it take to find the kth thing in an array? constant time we say it's constant time. and that's was random-access memory gets us that's what letting the computer figure out the memory address for our data does for us alright. I'm tired of this slide. let's move on it's a big moment. it's a big moment because we're going to look at our first abstract date type. ok now, the rest of this class is going to be the rest of this course is going to be an exploration of a sequence of abstract data types now, what is an adt? it's simply a description of the functionality of a data structure a description of the functionality
of a data structure. And data structure is a little bit loosely used here, but its okay, You'll let me get away with it. Alright, so the first abstract data type that we are going to talk about is, dun dun dun, a list. Now, this is an abstract notion of a list. This is a list like your to do list for today which includes playing Frisbee outside. And doing your homework and studying for your exam and working and uh, I'm sorry for the stress of your lives. Alright, so this abstract notion of a list includes your list of things to do today, it includes your list of favorite movies, it includes, I don't know, your contact list, it includes any list that you might want to keep track of data in some ordered fashion. Any question about that? Grocery list, the list of classes you go to, any collection of things where you care about their positions. Now, heres the cool thing about the abstract data type for the list class, and in fact for any abstract data type that we will study. C++ puts the abstract data type into the class definition, the public section of the class definition. So, the cool thing is, if I asked you about the functionality of your general notion of a list, you could point to the header file, point to the class definition contained in the header file and say look, I can create you a list, that's part of its functionality, I can tell you the size of the list, you can insert new things into it in a particular spot, you can remove things from a particular spot, and you can return the data contained in a particular spot. And that right there, this is the ADT for a general list. Operative word there is list. And the only reason i say general there is to distinguish it from what we thing of as a linked list. This is not necessarily a linked list. Okay, notice that we can use this list, this abstract data type list, by simply looking at the public section for it, and I get to keep this secret. I don't have to tell you what data is associated with the list, i just have to promise you that i will fulfill that functionality. that I will implement that abstract data type. Okay? Alright, so fine, lets get a feel for what these lists are by walking through a little bit of client code, designed to illustrate the fact that we can be functional without having to know about the implementation. So the first thing we do is we initialize the thing, it is a list containing integers, that's good. And now I'm just going to use it. I'm going to insert into the first position number 4. Here is my list. I'm just going to put it right here. I'm just going to put my list right here, the front of the list is on this side. And now I'm going to insert into the first position number 6 and now where is 4? The second position, right? You are moving things down. It's sort of like you have a list of favorite movies and you see a better movie, its not like your previous best movie disappears, rather it moves to your second best movie. And that's just how a list class is supposed to function. And now I'm going to insert 8 into the front of the list. Okay. Then I am going to insert into the third position, value 0. Okay, so I think i put it right here. Yes? And then I will insert into the fourth position, the get item number 2, so in the end it should look something like this. And it should be sort of opaque to you what actually happened in memory when scratching out and moving around happened. That's all encapsulated away. Alright, and then I want to Cout the size, we better get 5 here. I want to remove the second thing. And then i want to get the third thing, so this should give us 6. Okay? So this list is really an ordered collection of items. Ordered...
... collection of items, okay. Alright, any questions about it? Yeah? Raise, your hand, if you had that question. He said, How come you aren't using  zero?" Raise your hand if you that was a question you had and you kind of wanted to ask it. Raise them hight. Okay.  I need to whisper to you, okay, because this is a secret. We are the only people in the world that worry about this. Alright. Okay. So thank you for asking the question. I was hoping someone would. Ummm, yeah, so you know we're custom to indexing things by zero, right? But, when you are talking about a list, you know, if I ask you to write down your top five movies... If i ask your top... okay, we'll do three. Write down your top three movies. You can initial them, I don't care what they are, okay. Write down your top three movies, real quick, just so you can remind yourself one two and three." And I say, put your finger on your favorite movie, there is no ambiguity there, right? Like, favorite means first best. Put your favorite... put your finger on the first one you'd see if you had a chance. Like, there really is no ambiguity on the understanding of the first thing in a list, in the rest of the world. And that's what we're implementing here. So, raise your hand if the Princess Bride is among your top three movies? Okay, if you... and raise your hand if you have not seen the Princess Bride. Okay, so if you want to change your list, go watch the Princess Bride. Alright, so the point is, ummmm, whats the point? The point is that you always want to think about what the client expects. The world expects lists to have a first element, and that first element is not something you say a first element," right? You say a first element. It means one. And because thats what the user of your class expects, that's how you implement it. The interface has to behave in a way that is not unfamiliar to the people using it, okay? That's a little software design... a little piece of software design for you. Alright, any questions about that? And yes, I know, we start from zero, and there's lots of economies to be gained. When we right code for each other, we can start at zero, that's fine, okay? But when we write it for general use, we should be very sensitive about who's reading the code. Did you have a comment or question? You're good? Were you going to point out that we're really writing code for each other? Yeah? How does a destructor work for a list? Well it depends on how the list is implemented, and that's actually the next thing I want to talk about. So notice here that I didn't tell you how we made this happen. The implementation of an abstract data type is not necessary to be known. We encapsulated it away. It's a separate conversation. Now it's absolutely true that we are going to be talking implementations a lot, and in great deal, but to talk about the abstract data type ermm generally, discussion of implementation is not part of the discussion. Okay, ummm, let's see, but you are asking about what's my little secret, and I'll show it to you. Now, look at the class here. Look what I did. I made a list, I created a way of us implemented a list, yes? Yes, do you like it?
Tell me what that implementation is? Is you have to describe that implementation, what would you say?  It's an array, good. I even drew a little picture for you. Got any problems with that array? It can't get any bigger that's right. It's a static array and you know what? That one even won't hold your to-do list. Probably. It would hold my grocery list but it would not hold your to-do list. It's too small.  So this thing is a, the more appropriate name for it would be a short list.  Or a tiny list or something like that.  Okay, what is meant by size here is the actual number of elements in the list. The number of valid things in the list.  So what this implementation does is it sets up a potential slot but then it's intention is to, you know, put the first thing here, the second thing here, and ect.. I'll go ahead and use your zero if you like, okay?  And that's the implementation. Any questions about it?  So notice what I'm neglecting here. I'm neglecting kind of what to do about the fact that some lists are longer.  We are gonna handle that in a couple different ways over the course of the next week or so.  But we that said, I want to talk about a little bit of a technical detail even if we used an array to implement an ordered collection of things.  Try to ignore for the moment the fact that this is a fixed size. We are still gonna look at the use of an array of any kind assume it's big enough in this context.   Oh because I made these an abstract base class.  Oh you know what I don't know what happens if you templatized type is in an abstract base class. I would have to think about that.  So it won't compile unless it So it could be an abstract base class. But that's tangling up in here templates, in a way that there are a hundred different ways of doing that and so it gets kind of  Like you'd want to look at particular compilation procedures for handling that.  So I think you have a clear picture in your mind and I probably don't have it in mine. But it suffices to say it would be more complex.  But we are allowing for any old type here, so you can put any type here I can't go there right now Alright, we are we though? Let's talk about use of arrays for implementing lists in general Don't look at this code, but I want to talk about what it is.  So our process is that we need to be able to insert into a particular position in a list, and we need to be able to remove from a particular position in a list. Alright, I'm going to pretend that we actually.Well no I'm not gonna pretend anything.  Alright, I want to say insert into position 1, item I don't know. Let's put integers in because I'm not creative.  I wanna insert into position 1 value 3, where should I put it?  Zero that's fine. I'll do that. Now I want to insert into position 1 again value 4. Where should I put it?   Position 0, okay. What should I do with the 3? Move it over. Okay okay. You are saying open up a hole for 4 and put it in right? So the 3 has to come over here  and the 4 goes here, yes? Okay, pretend that I do this a few times. Okay I'm gonna insert to postion 3 an 11, I'm gonna insert into position 4 a 5, I'm gonna insert into postion 6 a 9 and now dot dot dot  I'm going to insert into position 1 a heart how do I do that?  How do I do it?
...to two four, yea. So in the end it looks like four, three, eleven, five, nine. And then there's room for my heart. Okay. What do you think about this? Say it stinks. Thank you. Why does it stink? Oh my gosh. All we're doing is inserting into this puppy, and you have to open up a space?! That shifting is incredibly expensive. So this incurs an order n because it's a loop...potentially all of your data to shift. Okay. And so, this is bad. This is not a heart. It's rather a sad face. I guess you can do it like this. Oops. Yea you can do it like this. Why is that funny? If that's all it takes man, woooo haha okay. Here. There. All right. Any question about that? How else can we use a list for, um, I'm sorry, an array to implement a list? Well, you can put the front of the list out here, right?  But you can kinda... But you incur the same problem so if I say insert one three. Put it here. And then one four. Then I can put four here and here's the front of the list, right? That makes sense? So here's the first item of the list. Here's the second item of the list. And then if I say one five. I can put five here and move the front of the list to there. Do you like that? Yea? How would I keep track where the front of the list is? Right? I can put it there. I can put an index there. Fine. Um, but then I'm going to say, eh, I-I'mma add a bunch of things to it: nine, eleven, twelve. And now I'm going to say insert into position, uh, I don't know. Where do you want to put it? How about six, value, um, frowny face. Okay? Where's frowny face supposed to go? Right between these guys, right? So it means I got to scoot all of these over. Okay, so there's a shift. So this one's here, this one's here, nine, five, four, and then the frowny face goes here. Okay? And again, that's big O of n. Okay. So we can't keep the front at the start of the list. We can't keep the back at, I'm sorry, at the start of the array. We can't keep the back at the start of the array. There's no good place to keep at the start of the array and honestly, you know what? We can always do insertions right, like, between sort of halfway in the middle. Right? Because those openings must occur or can occur anywhere in the list, and we can't predict it, we will always have this shifting problem. So we can't avoid the shifting problem if we allow insert into the middle of the list, so given the list interface we defined or the list ADT. Okay? All right! Any question about that? So here's a better way of implementing a list.
How is this one implemented? If you have to describe this implementation, how would you describe it? Somebody raise your hand and speak for the crowd, yes? It's a linked list, very good. Chained memory put together we are using it now to implement my List class. Is there anything special about it? Yes? Yeah, it's not like MP3. We do not have previous pointers here. A typical way of describing this you might have seen in your earlier class is a singly linked list.  Okay, we will refer to this as a singly linked list implementation of a ADT List. Ok? Alright. Let's see what we have then. We have a way of holding on to the front of it. A number of element that it includes. This little Find function that we are going to find helpful; that will be helpful to us. Okay, and here is the implementation. Guess I changed the variable name but otherwise, lol, Ohhhhhh.. Wow.. Okay, do you all see my little bug? The compiler will help me so I don't even feel guilty about it. But you see my little bug here? These things are... in the wrong order, you can handle that one. And then we have this class defined... I was thinking about this last night and I think I should've been explicit. When I demanded that our base cases been NULL, I should have actually assure you that we intended to have a no-argument constructor for the listNode class. Okay? I should've assured you of that.  Alright! So this is an implementation of the List class together with one helpful helper function. Now, I have a question for you that I don't know if you can answer yet. But I want you to think about it. OK? We put this helper function in the private section of the List class definition. The question is why? Why is Find in the private section of the List class definition. Find is in private, why? I am gonna point to something that might help you. Yeah? Right, so we don't want the user to know the implementation and look, this Find function completely betrays.. Well, actually it only halfway betrays our implementation, right? It shows them, oh bud, you got a pointer-based structure. And you know, built of nodes, and furthermore, the way we have this set up, they can't access it. Why? Because look, listNode is also private. So this listNode class right here that is so important to navigating our implementation of List. It isn't even useful to client.  Right? but that's OK, they don't need it. They only need to know positions inside the list. Alright? any question about that ? So why is Find private? The answer is because it relies on the details of the implementation for its functionality. And that implementation is hidden away. from client. Alright. Anything else? Any questions about this? Ok, let's see if there is anything else I want to say on this page. Hold on...
ok. alright let's write some more code. we can write this together alright. so umm if you notice one of the functions here is insert() um I want us to implement insert() ok. and that's what this slide is for I want you to write an implementation of insert() into the list now notice this is the interface for insert() this is the connection between the code that the client writes. they write insert() into position a value and then you're going to take that function call and actually put things into the linked list ok so go ahead and write this code really quickly. I will write parts of it too I'll write parts of it as well and I'll remind you we know how to create new list nodes because we did it last time so... let's see what I'm going to do is ummmm list node pointer new node equals new listnode e I'm going to find starts here maybe I should just talk aloud do you want me to just talk aloud alright sorry alright so what's going to be my process let's say somebody says insert into position 2 ummm value oh. we have to have an integer 8 ok insert into position 2 value 8 now what do they mean by 2 tell me when to stop when I'm underneath the position that it should be inserted ok. yeah, right they intend in the end that 8 will be between 3 and 6 so that means that what we're going to want to see is an 8 here pointed to 6 and then this goes here alright alright now this would be easy if only we had a particular pointer. which pointer do we want. which pointer would make this easy? I'm changing this to 3. I'm sorry I need to not, like, ermmmmm. sorry changing this to 3 ummm so that all of that discussion led up to here instead makes it more interesting k now where do you wish we had a pointer k this is what we want it to look like where do you wish we had a pointer? ok yeah, you wish you had that pointer. right? like ooooh how do we get that pointer ? how do we get it. how do get a pointer to that place find! right. find will help us walk down the list. ok ok find() uh. we're going to find how many steps from head how many steps do we want to take location minus I started with 3 here how many steps do I want to take? I want to take one step. I started with 3 so it's actually minus 2 yes it is Noooooooooooo!!!!!! so that's the combined effect of you want a pointer to the thing before together with our list you know we're counting this thing by 0 steps by steps by the number of steps and you want it to the thing before ok alright so I want to go loc minus 2 and then oh and I need to grab that thing oh my gosh what I mess I'm going to call this oh I can't call it curr how would you like to hold on to it. um temp ok temp equals this guy so now this is temp alright I am so sorry guys tmp uhhhhhhhh let's see I can do temp ahahahah I'm going to do this in canonical order. new node next equals temp next yeah right. is that true? that the right thing to say? ok and then.... tmp equals tmp next ummmmmm. equals
Where's temp next? It's this one right? Where do I want it to be pointing? To my new node, Good. Good Good Good Alright. You happy with it? Yes? Very Good! Exactly! This code's a mess! It doesn't even work if we want to insert in the first position, but we have a function that inserts in the first position. So, if location is one ( if loc == 1) insert at front(e) else do all of this. okay, and then... then we know that thing will never be 1, we already know it won't be 0 because 0 has no meaning. We know it won't be 1 because that's a different case, and so in the worst case it will be 2, right? This code will go if we're inserting into position 2 and the number of steps we walk forward will be 0 and this code is fine. Okay, do you like it? I don't like this code. Okay? I don't like this code because it makes a special case out of something that's the same as everything else? Right? It made a special case out of inserting in the front of the list, and I think we can write code that avoids that. So, let's work on that. Here's what we're going to do... we're going to redefine our implementation of an empty list, okay? So we're going to redefine... geez *Pause* What we're gonna do is we're gonna say an empty list is a single node. Followed by the rest of our list. Okay? This single node and then yes... empty list is a single node, all other lists are this single node followed by our data. This node, this auxiliary node, that we place in the structure is called a sentinel node. This is a sentinel node. *Pause* This is a sentinel node... Thank you And, look what it does for us. So the empty list has a sentinel node; all lists have this sentinel node in front of this. Look what it does for us. No matter where we insert into the structure, we're always going to be after a list node, right? If we insert into the first place in the list, it's going to be after the sentinel node.  If we insert into the second place, the third place, etc. and so we remove this special case of not being able to grab the pointer before because every node that we insert will have a pointer before. Okay? Any questions about that? That means that the code we write to actually insert this thing looks more like this. This is no special case because we've created an invariant situation where we're always inserting between two nodes even though at the front of the list that node is kinda meaningless. Okay, any question about it? Yeah? *Pause* So that would have to be handled via error handling. Right? We're not talking about that, we're assuming the user is going to honor our abstract data type which says it starts at 1. Okay, so how do we make this happen? How do we create an empty list with a sentinel node in it? In the constructor! That's right. Your opportunity to shape memory upon declaration is in the constructor. So this is where we'll start next time. Oh my gosh... *End of recording* *very end*
oh shoot I forgot to tell you  you are wondering what hack is given the arbitary okay so the location is known, it is a fixed location like k is equal to 3 or something a location is equal to three this one is parameterize so you are allowed the user to input whatever they like for the location you gotta go find it okay ready? should we talk where are the mistakes? where are the mistakes on this so I guess I start walking my pen down actually I will start my pen down up to bottom  alright You tell me when this stop where ther is a mistake stop? okay is this costing ordering to shift in an array which of these two is wrong? this one, okay why, is, why can we not do insertion in old place could you have to walk down the list you cannot just get to any position that you want in a list so this big O of n to find here just like removal okay fine any question about that? alright I m keep walking up remove a given location is okay insert at a given location which one is wrong yes this one is wrong because we have still have to include the shift to open up the location the spot, the space  okay fine should I keep walking up? okay so you are happy with this?no no this is a fixed location i know where it is  which one  which one are we talking about? who am talking to  I forgot already which one you asking about anything esle? is this good? reallly? yeah? ohhhhhhhhhhhhh,this guy right this is the red haring thats the reason I start at the bottom I make this red this is the red hairing
ummm that was little break because it's friday. how about that I owe you 5 minutes in your life sorry umm let's see so I have a new announcement related to the exam there's going to be a review session umm on saturday from 11 to 12:30 we don't have the room for that yet but we'll be announcing the room saturday as in tomorrow but we'll be announce the room on the piazza so ummm ah go to the piazza to find out exactly where it is so let me write it down. ooohh that's pretty oh man getting old sucks ok so the review is 11 to 12:30 o umm 11 am to 12:30pm saturday and that is tomorrow room tba on piazza and the plan is to do the spring 14 exam k. so they'll be ummm they'll be going over the spring 14 exam we may have additional yes ummmm it depends on what room it's in. so I will automatically ask for video tape of it. but it depends what room they put it in so I hope though um ah if not, you know the collective intelligence you know its you know you guys can recreate that sort of review experience by getting together with other people to study you know like that sort of transitive what they said at the review session was this. and I think that's actually a great way to study because it's good for you and the person who is telling you the stuff ummm so any other questions about this? alright. we'll keep you posted the exam still feels like a long way away to me so I apologize for not having a whole list yet seems like we've got a lot of time still ok ah the extra credit is due tonight how was the queue last night? little dicey, right? I think I heard that there were quite a few people on the queue last night maybe right after class today you might want to go maybe a good time ok so I ended last time kind of in a hurry and I wanted to revisit some of the uhhhhh very last closing thoughts from last time because i wanted it to be clear ok so here's the story. here's what we were trying to implement we have this chained-together memeory that we use as an implementation option for an adt now this adt allowed us to insert things into particular locations the application that you should think of I think or a reasonable application is like suppose you have a list of your ten favorite movies your top 10 favorite movies there they are and then you see minions they you see minions ok then you see minions well, you might need to change your list right so  at the number 3 stop, probably because minions is not better than prince's bride or idk what's your favorite movie? or back to the future ok so in the 3rd spot. you need to make space for minions and that means sliding everything else down this is the list adt that we are intending to implement ok any question about that now it's not some clasic data structure ok it is a this is a adt that we're sorting crafting for instructional purposes there are equivalent or there are similar ones but there is no sort of unified language around this particular umm adt ok now furthermore we were talking about implementing this insert function insert into the location into a particular location ok now think about what is necessary for that to happen you need a position and a data element that you're putting into uh the list say of movies ok that's the interface. that's what calls this function or what this function is called with um I have a question for you before we even talk about details here is insert() in the public or private section of the list class? definition is it in the public or private section and when you answer. when you raise your hand to answer, I'm going to have a follow-up question so raise your hand and answer somebody raise their hand to volunteer yes it's in public how did you know what did you check
uh ha xu... very good two key points we need the client to be able to use this function to give it the insert date into the structure dot and when you look at the parameters they are public variable none of them are private to list class okay now let's talk about elegance, last time when we talked about our first implementation of inserting into this linked memory implementation of a list we had a complexity with inserting at the front of the list ok so every place cells inserting every place cells other than the front was a matter of  positioning a pointer before the node we want to insert and creating the new node readjusting pointers that set up but there is a special case in the case of inserting at the front so I am gonna write it down for a second  so our old technique for inserting creates a special case out of inserting at the front now the way we diagnose that the special case is by putting in the conditional the whole code was if  this okay that's a problem later on in your suffering generic experience you learn about a uh... a contact called cyclematic complexity and it basically has to do the conditional branching the amount of conditional branching in your code every time you can redo an if statement every time you can get rid of the neat conditional and a if statement  you reduce the cyclematic complexity or the branching of the program magziqusion of your code  now you might not care about this until I tell you that when you writing code, you have to write a test case for every possible conditional branch in your code now I don't know about you but I hate writing test cases It's tidious I don't want to think about it and so if you don't this many that is cyclematic complexity if your code is lower then you relive yourself of that responsibility  okay so think what we did even in this case, we don't have to write a test case for inserting at the front of the list different from inserting anywhere in the list because everywhere we insert is the same now how do we do this ideal, how do we make it happen the answer is we put a node, a sentinal node at the start of our list now what is this node It's nothing It's data is garbage there is nothing meaningful in it in fact we can't put anything in ti because it's just a list node if is a list node and we don't know what kind of thing list node hold so we just let that be garbage we don't care what its data is okay? all right so it's called the sentinal node we put it the start of the list gives in the insertion that means it gives us the fact that inserting is the same no matter where we are going to do it in the first in an a whatever any question about that said okay is it better? I hate tail ok all right what's the process for inserting is I say inserting into position 1 element eight eighty-five just to make sure difference then what is this code do is takes that many steps forward from the start so this is still head
very good, two key points, we need the clients to be able to use this function, right? To be able to insert the data into this struct this function, right? To be able to insert the data into this structure, duh. And when you look at the parameters, they are all publicly available. None of them are private to list class. OK.  Now, let's talk about elegance. Last time when we talk about our first implementation of inserting into this linked memory implementation of list We had a complexity with inserting at the front of the list, ok? So Every play cells, inserting every play cells, other than the front was a matter of positioning of point before the node we wanted to insert and creating the new node readjusting pointers etc but there was a special case in the case of inserting in front so I'm gonna write that down for a second so our old technique for inserting created a special case outof inserting at the front now the way we diagnose that special case is by putting in a conditional the whole code was if this now that's a problem later on in your software engineering experience you'll learn about a  a concept called cyclomatic complexity and it basically has to do with the conditional branching, the amount of conditional branching in your code every time you can reduce an if statement, every time you can get rid of the need for a conditional, a if statement,  you reduce the cyclomatic complexity or the branching of the program execution of your code now you might not care about this until I tell you that when you're writing code you have to write a test case for every possible conditional branch in your code i don't know about you, but I hate writing test cases It's tedious, I don't wanna think about it and so if you don't have to write this many, that is the cyclomatic complexity of your code is lower than you relieve yourself from that responsiblity ok? so think what it did even in this case we don't have to write a test case for inserting at the front of the list different from inserting anywhere else in the list because everywhere we insert is the same, now how do we do this? or I guess that's the ideal How do we make it happen? The answer is we put a node, a dummy node, a sentinal node at the start of your list, now what is this node? It's nothing it's still a list node but its data is garbage there's nothing meaningful in it in fact, we can't put anything in it, because it's just a list node.  it's a list node and we don't know what kinds of things list nodes hold  so we just let that puppy be garbage, we don't care what its data is ok? alright, so it's called the sentinal node we put it at the start of the list, it gains us in variance in an insertion, that means it gains us the fact that inserting is the same no matter where we are going to do it, in the first, in the eighth, whatever ok? any questions about that? is that ok? is it better? ok so what's the process for inserting if I say insert into position 1, element of eight? 85, just to make sure it's different then what is this code do? it takes that many steps forward from the start this is still head
Head take that many steps forward from the start. Oh look! It has position pointer exactly in a useful spot.  okay? Any question about that? I'm sorry. This must be trerribly painful to listen. And then it does these things. It creates a new node, inserts our data inside, and then fits a pointer. New next euqals curr next, curr next equal new, and that's the code! This pointer's no longer there. When you start from the head, you see the sentinel node, then you see the one we just entered, then you see the rest of the list, which is what we intended. Any question about that at all? So how do we make this happen?  Well, here is a thing, the question to ask ourselves is, what do we want an empty list to look like? That is, when I say, when client code says: List<int> brandNewList, my brand new list. What do we want an empty list to look like, and the answer is what we want it to look like. We want head to be pointing to this sentinal node, like this. That's it Cause then it's ready If you gonna insert into the first position, want the pointer to point right here, we create a node and we are done! Fix up the pointer and we are done. How do we do it? I don't know. I think what we must do is, say, head equal new listNode. Depending on what the constructor looks like, we simply want listNode next equal NULL. So head next. equals Null. Any question about that? And I guess these parenthesis are optional and you don't really need those there and I am gonna erase them because we should do that. Any question about this? Yeah? You don't see what the point of the sentinal node is? Raise you hand is you agree with that question. That's a very brave question. Look at those hands. I can tell the looking in your faces, Why? I don't like conditionals. No, we don't like conditionals. In the old way of doing this, we had to use a conditional because this code didn't work if the head in intended to point to the very first thing. There was no NULL" before. So what this empty node does, is it makes it so that every single data node will have a NULL" before. There's no differece. in structure between the first data node and any of the others. Does it make sense? It's an empty node. It is a node, but it's data is meaningless. It's data is garbage. Oh, very good points. So the question was, to achieve the functionality in a doubly link list, should we probably have a tail? Yes. You should. Yep, you should. Yes?
So there is a little location zero right?. I cannot say to you. I canno say to you.  So I am gonna take it around the ben.  So first in principle there is no location zero . You don't ever say what's your zeroth  favorite movie.  ok? So from the client side of things, there is no location 0. But from the implementation side of things  If it helps you. If it gives you peace to think of that as  location 0. Perfectly reasonable to do so .   That's a perfectly reasonable way of thinking about it.  Yes.[question asked] [asking questions ] Yes  Ummm. So location is passed in.  So remember that the parameter for find is the number of steps you walk forward .  Right? That is what it means.  It happens to be a function of the location asked for but it  right,yup,zero steps[answering question] ok. How we doing. Is it better. I felt really bad last time. It's like ahhh... And then I got 6 so it's like no no I am not gonna be able to make it better . Is it better. Oh, yeah.Ok. Thank you. You speak for the crowd.  Ok.  Alright, any other questions.  So, so this is kinda fun.This is kinda fun So here is waht I know about you guys . You guys are here after having taken an introductory class  which means you are in command of the basic structures, like iteractions and conditionals  And variables and arrays and functions  You are in commoned of those things  But it is unlikely that you have in your experience had  an opportunity to think creatively about  how you use memory  and so this is sort of the first opportunity  where you can kind of use memory to your advantage.  Now am I worried about this amount of memory that we used here? It is a little expansive how much do we pay? for this additional list node?The answer is no.  I am not worried about it at all. Ok ?  But it's a reasonable question. And [answering questions ] So,  this implementation the list has no tail pointer. This is a singly linked list . But if it's  a doubly linked list  you are gonna initialize the tail to point to the tail. In fact .  Alright,Let's have this conversation. Let's throw it down right now.  Alright,so what does an empty doubly linked list look like?  I think it looks like this,  Here is head. Here is tail. Umm...The next of head and the previous of ...oh I did this wrong  Ok? The next of head and previous of tail point to each other, ok ?  So I think that's an empty doubly linked list if you are using sentinels Ok Now, I really feel bad that mp3, every semester , every single semester. I say we should change mp3 to use sentinels and Course staff goes, no no no no. They should have to do this.  So I am on your side on this one. I never ever throw course staff under the bus but this time .... Yeah?[answering question ] So our implementation of the list class already doesn't use sentinels.  Ok? Our constructors don't create sentinels for you.  So I am sorry this one is not my fault. Just kidding, I am kidding  I don't even know we had that conversation recently . Hey  shaw we work on sth new? ok... I got another puzzle for you .  I have another puzzle for you.  Here is what I am gonna give you ok? We got some big linked list. We got some big linked list . Umm, that what's that little dot dot...you can use a a sentinel if you like in fact I think we need one.  Um, and I am going to point to the node that I want you to remove. So I am going to give you a  pointer explicitly to the node that i want you to remove. Ok? There it is. I want you to remove that node.  containing 7.  From this list  Ok? Remove the node containing 7 from this list now I am gonna let you vote.  Do you want a few minutes to struggle over the code yourself?  thereby kinda giving a you a testy sort of experience? Or do you want me talk over writing the code  Raise your hand if you want to. Umm... Do a little test review by wrting the code  Raise your hand high so I can see.  And raise you hand if you want me to talk aloud to do this? Alright. I am gonna give you guys a few minutes  To write this code.  And Then I will talk aloud. We are just never get through this semester.  Figure out this code. I think it is clear.  Ummm. You could call this guy head.  [ending]
And it is a singly linked list I'm going to start writing here because I'm bored, so if you're really stuck feel free to follow along Okay I wrote my code Okay, so raise your hand if you wrote something similar Okay, good Okay, let's trace it really quickly, I'm going to give myself, effectively, a way of iterating down the list Okay, I'm not going to call it an iterator because that's a special word That we're going to learn about soon; but I'm going to give myself a way of iterating down the list It's called t" and it's a list node pointer, okay?  Started at the beginning of the list, walking down to where? Where should I draw the pointer t" after that while loop? Yeah, it should point to 2, right? So right there is where it is after the while loop And then I just, now that things are set up, all I have to do is fix up pointers I'm pretty sure all I need to do is this and then free up this space And sure enough, that's exactly what those two lines of code do Now, seems pretty clean to me Do you like this code? No. What don't you like about it - and there is a one word answer for this, starting with w While, that's right! Think about this I'm telling you exactly what node I want you to remove I tell you there it is, I point to it; and yet you have to incur the cost of starting at the front of the list and walking down the list All the way to the node that you might want to remove, even though I told you it to begin with, right? This is an expensive problem, this is an expensive proposition Okay So I'm going to show you a potential solution to this problem Okay, so first of all... what's the running time of this?  Linear of n, that's right So what would be better than linear? Constant time, that's right So I'm going to show you a constant time solution to this problem And then we'll talk about this choice of word in just a minute, okay? Alright, so suppose I give you this And I'm going to ask you a question I tell you I want to remove that node and then give you that pointer What node would be easy to remove? The next one, right? Oh, but then we'd lose some data... I wonder what we should do with that data Store where? Does anybody see it? Does anybody see this completely? Yes? Do you want to tell us
and it is a singly linked list can i start writing here cuz im bored if youre really stuck feel free to follow along ListNode * t = head; okay i wrote my code raise your hand if you wrote something similar lets trace it really quickly im going to give myself a way of iterating down the list im not going to call it an iterator because thats a special word that we're going to learn about soon but im going to give myself a way to iterate down the list called t and it is a list node pointer starting at the beginning of the list and walking down to where where should i draw the pointer t after that while loop yeah it should point to two right? so right there is where it is after the while loop and then i just now... now the things are set up ... now all i have to do is fixed up the pointers im pretty sure all i need to do this and free up this space and sure enough thats exactly what those two lines of code do now think pretty clean to me do you like this code? no what dont you like about it? and there is a one word answer starting with a w ... while thats right...think about this im telling you exactly what node i want you to remove i tell you there it is i point to it and yet you have to incur the cost of starting in front of the list and walking to down the list all the way to the node that you might to remove even though i told you it to begin with  this is an expensive problem / decision okay so  im going to show you a potential solution to this problem and i  ok so the first thing of all whats the running time of this? linear o of n so what would be better than linear? constant time thats right so im going to show you a constant time solution to this problem and we'll talk aboout umm this choice of word in just a minute okay alright so suppose so i give you this and im going to ask you a question and tell you i want to remove that node and i give you that pointer what node would be easy to remove the next one right but then we would lose some data .. i wonder what we should do with that data store it where? somebody ssee it? does anyone see it completely do you want to tell us?
d d Suggested Delete the next node Write the code that does this.  I wanna grab hold of the next one Put a handle on it. Curr next is going to look at this and get that value. Make it more of a chain. Data constant for this MP. We can't do stuff like this Fix that problem by putting a sentinal there. Now imagine the constructor for that. Copying around data uhh yuck This should be ok functionally. It could be expensive. This class could be expensive. 
Okay! There's one other issue with this that is actually the reason I hate this, the reason I think it's very hacky, and that is that any algorithm that hap- that any piece of code that happened to depend on the identification of a node with its contents, is now broken. Right? Like... we have decoupled the data from the container that holds it, and any code that happened to have been written so as to depend on the identity between those two- now we're creating a bug. So you know that's subtle and maybe an unlikely situation, but there's one case where it absolutely does occur and I'll talk about that when we talk about iterators. Suffice to say now that this thing invalidates iterators because an iterator is a type of thing where you know its location, you know both the data and the location. We'll talk about it later. And we're decoupling those two. So this mechanism invalidates iterators. Alright and if you read the standard template library in fact there's a comment that says if you do a particular thing your iterators are invalid because the standard template library uses this kind of optimization. Yes, what should we use?  So this was an exercise because let me ask you this: is this particular function in the private or the public section of the list class? Private, right?  This is kind of a manufactured because it has got a list node in its parameter. This is kind of a manufactured situation and in fact if you were implementing remove- if you were implementing remove for the client you'd set it up so that your pointer's position is in the right place to begin with. So this situation where I give you the pointer to exactly the one you want to remove is maybe a little bit artificial. But I wanted you to have seen it because this is exactly the kind of thing that- is exactly the kind of little cultural trick question that people like to test you out with and see if you've seen it before. So I wanted you to see it here. I wanted to give you your first taste here in this class. Would this implementation cost you points on the exam is the question. Uhm no, no no no. Not, I mean.. probably what we would do is we'd ask you to implement it and then ask you to analyze it and discuss. Our point in asking it would be exactly to see if you internalized the distinction between the two. Alright whats the running time of this again? Constant time because it's all a bunch of assignment statements. Alright yes. Okay we created a pointer, so like T in that picture. Okay! Uhuh So the problem is that we don't have the pointer to the one before. We have to walk down the list to get the pointer to get the one before in a singly linked list. Okay, alright! Let's go, let's move on. Ohhh my gosh. Have we flipped the page yet today? Ohhhh my gosh! Alright. We're gonna summarize what we've talked about about list class functions. Uhmm and I'll tell you that there are two errors on this slide. There are two errors on this slide and I want you to find them. Go! You have three minutes to do it. Find the two errors on this slide.
Oh, shoot, I forgot to tell you. You are wondering what the heck is given versus arbitrary. Okay, so the location is known, it is a fixed location. Like, k is equal to three, or something, the location is equal to three. This one is parameterized. So you allow the user to input whatever they like. For the location you gotta go find it. Okay, ready? Should we talk? So where are the mistakes Where are the mistakes one this? So I guess I will start walking my pen down. Actually I'm gonna start walking my pen up from the bottom, OK? Alright, and you tell me when to stop when there is a mistake. Stop? OK? It doesn't cost you O(n) to shift in an array? Or which of these two is wrong? This one, OK? And why, why can we not do an insertion at any place in a List? 'Cause you have to walk down the list right? You cannot just get to any position that you want in a list. So this is Big O of n to find here. Just like removal. Ok, fine? Any question about that? Alright, I'm gonna keep walking up. OK, remove at a given location is OK? Right? Insert at a given location? Which one is wrong? Yeah, this one is wrong because we still have to incur the shift to open up the location, the spot, the space. OK, fine? Should I keep walking up? Okay, so you are happy with these? No?  No, this is a fixed location; I know where it is. Right? Which one? Which one are we talking about? Who I talking to? I forgot (inaudible). Okay, do you see which one you asking about? Okay, alright. Anything else? Is it good? Really? Yeah? Ohhhhhhhhhhhhh. This guy right? This is the red herring. The reason I started at the bottom. I'll make this red. So this is a red herring .
Raise your hand if that phrase isn't familiar to you. Ok, go look it up, this is a, this is a cultural  Moment for you, we are a inter cultural group here, ok, alright, it means it kind of it's led there to lead you astray effectively. Alright, so I know, I know that it's true that  you can come up with, bye, see you, have a great day I know you can come up with an implementation, they cost you O(n) to insert and remove in the front, using array to implement the list right? But, I also know that it's not very hard to come-up with  an implementation that allows for constant time, insertion and removal at the front of the list using an array. And we talked about it very briefly last time. And that is simply that we put the values backwards into the array. So the end of your list is here, and  your favorite movie of front of your list is here and you arranged them backwards, and the only thing you have to do   to make that happen, so then inserting and removing is just matter of messing with what happens at the threshold inset, remove, no big deal, and maintaining  an index that keeps track of where that front is. Ok?  Any questions about that at all? There is a little bit of discussion to be that might not make you happy. Is it Okay? What is that  What is that to do with inserting and removing at the end? makes it expensive maybe we can keep track of where the end is. True right? what about making it the middle That I have no answer for. That one expensive. so for this particular example There is more kind of a clever way of looking at this I mean it doesn't require a whole lot. Fairly clever way of looking at this allows for a constant time max Ok, I'm gonna go ahead and start on the next stop, because the next slide is very introductory anyway. Look at you flip your paper Yay! We are closing the book on abstract data type list.  And here's the deal, here's what I want you, here's what I have want you have taken from experience.  I want you to have learn the vocabulary abstract data type. And i want you to have internalize this model of talking about specific implementation of an abstract data type.  So, you understand vocabulary of abstract data type and then we kind of had discussion of whether implemented using a list or an array  That's kind of how the rest of semester going to go. I'll introduce an abstract data type and sort of let you know  what functionality we want  to accomplish and then we will argue over implementation, ok? Now, our next abstract data  type is called a stack, and I guess it looks like we'll start that on Monday.
[Video playing] Oh my gosh. It's time to work. I am sorry. I don't... It drives me crazy. Ok hmm, let's work Back rows, is that better? Feel like that's better? OK Alright, hmm. See you will have an exam this week. On Wednesday. We're still writing it. You're still studying for it. Hmm... Classes cancelled on Wednesday here. But there will be your review session in this place. So officially you don't have to come. But you know, you don't have to be here today, either. but... Here you are. And, by that point, we sort of expected we will be answering last-minute type questions. We may be announcing another review session sometime tomorrow, but I'm meeting with course staff this afternoon or this evening. So, we will let you know to make sure to advertise any additional review sessions, publicly.  Are there any questions about the exam, or the preparing for the exam, or? Yes?
Umm either or the question is what will be the form. Oh you mean Wednesday what will happen? So the intention will always be to answer student questions. Right? Thats the best case scenario. But a lot of times, we prepare to do that and student don't come with questions. So they fall back on the review papers.  No its not on the computer. The first exam will be very much like the previous exams. Though it is written by a new instructor so there is a bit more creativity involved here.  But we're on the same page. Mattics don't you say we're on the same page of what constitutes a reasonable exam. Not to put any pressure on your or anything. We can duke it out.  Oh yea right, that's right. Don't worry its ok. No thank you for asking that. So the exam is still written with the intention that it should take you that if you came in here you could take it during a single class hour.  In the old session, in the old way of doing things that is how it always was. You came and there was some high pressure moment of taking the exam during those 50 minutes and part of the score of based on if you could finish it during that time. I think those exams written for that were probably too long to being with. Probably its not true that the average student would take 50 minute to do our exam.  But I'm pretty sure we can get 90% finished in an hour and 15 minutes.  Does that make sense? But because we don't want time to be such a component of it we spread it out to three hours.  Two and a half officially but we're not going to leave until 10:30. Alright any questions  Its gonna be ok. I don't want you to feel like your life depends on this one time period.  Lets work shall we?  there is new stuff on the screen. Uhh these things, these little dotted graphs all have something in common. They have a common interface. Now raise your hand if you never felt a pez dispenser. Raise your hands if you never felt a pez dispenser. It is a cultural experience that you really should have. There is a very characteristic feel to a pez dispenser.  I should have brought more.  They usually don't yell at you! Alright, you can pass them around. I don't care. I want them back at the end of the hour but they could rotate around. Just to reinforce the idea that the pez dispenser as a candy dispenser Right? You put the candy in and you can only get the candy off the top. The top of the pez dispenser. This is a real problem if you have a multi-flavored stack of candy. It means in order to get to the purple down here, if you want the purple one you have to go through the top and pull them all off until you get down to the purple one. That make sense? The way I think of it is a constrained access structure.  Now in terms of data I'm going to describe it like this. It is a constrained access linear structure.
Where our data is going to exist in sequential positions somehow that is   there is a notion of what is the next piece of data or piece of candy there's this notion of next but we are only going to allow access to the data  where we want the end of the structure much it has dispenser any questions about that? alright so this is the kind of structure we are going to study next it is called stack and I'm going to show you quickly a couple applications that are different than the dispenser applicaiton ...sorry... okay so what application do i wanna do  well first of all i'm gonna use this as my source of diagram for how a stack is going to work in this context and as such im going to say the entrance to the structure is at the top okay?the entrance is at the top and i'll be placing data inside of it i guess there are other analogy you hear all the time the trays in the dining halls and I think the one I'm gonna do is  this sequence of function call because I find it kind of interesting ok we'll talk about other application latter  but i'm gonna start with this one so this is intended to be a sequence of functions inside a main so inside a main you study hard and you do good work but the process of studying hard means that you execute functions  MPs and Exams etc. okay? so this is a sequence of function calls  main calls study hard and do good work do good work calls these four functions in sequences is that clear how this code this pseudocode as diagram here ? okay we  we refer to the stack as stack memory  earlier long and this is what was really meant by that this is why that region of memory is called the stack okay? when function main executes when function main executes eh.. all of it's variable and parameters are set up on the stack and as they are on the stack they are entered into the stack and as they are on the stack we say that they are in scope  and execution passes then to study hard the second study hard is executed  it's variables and parameters study hard bars and params are set up on the stack on top of main effectively on top of mains in the process of executing studying hard, MPs are setup in the process of setting up MPs we have plans okay? and then right here the second the function plain completes execution  all of plains variables and parameters are removed from the stack or we say popped from the stack okay? any questions about that ? so we finished our first function here and then execution proceeds to the code function and all of  so plain is gone and now all of codes variables and parameters are put on the stack or pushed onto the stack  then code finishes execution and it is cleaned off then Mps finishes execution and they are popped from the stack and then we hit in course of execution exams  here we are  exams functions with all of it's variables and parameters are pushed on to the stack wingit ..all with good advice  pushed on the stack wingit complete execution so it is removed from the stack we finished the exam and look  we finished study hard, and now we precede to do good work DGW any questions about that? so you can see that memory is being reused as the execution transfers from one function to another  it is kind of easy to see how interpretation of memory location would get convoluted if you are not very careful to track of what your re doing
Where our data is going to exist in sequential position somehow, that is, there is a notion of what is the next piece of data or piece of candy. There's this notion of next. But we're only going to allow access to the data through one end of the structure, much like a pez dispenser. Ok any question about that? Alright So this is the kind of structure that we're going to study next called a stack. And I'm going to show you really quickly a couple applications that are that are different than the pez dispenser application. Ok so what application do I want to do? Well first of all I'm going to use this as sort of my diagram, the source of my diagram for how a stack is going to work in these contexts. And as such I'm going to say that the entrance to this structure is at the top, ok, the entrance to the structure is at the top. And I'm going to be placing data inside of it. I guess the other analogy we hear all the time is the trays in the dining hall. And I think the one I'm going to do is this sequence of function calls because I find it kind of interesting. Ok, we'll talk about maybe these other applications later, but I'm going to start with this one. So this is intended to be, this is intended to be a sequence of functions inside a main(). So inside of main() you studyHard() and you doGoodWork(), but the process of studyHard() means that you execute functions mps() and exams() etcetera. So this is the sequence of function calls. main() calls studyHard() and doGoodWork() doGoodWork() calls these four functions in sequence Is that clear how this code, this pseudocode is diagramed here? Ok, we used, we referred to the stack as stack memory earlier on, and this is what was really meant by that. This is why that region of memory is called the stack. When function main() executes, when function main() executes, all of its variables and parameters are set up on the stack. And as they are on the stack, they are entered into the stack, and as they are on the stack, we say that they are in scope. And execution passes then to studyHard(). The second that studyHard() is executed, its variables and parameters, studyHard()'s vars and params, are set up on the stack on top of main. Effectively on top of main In the process of executing studyHard(), mps()'s are set up In the process of setting up mps() we have plan() and then right here, the second that function plan() completes execution, all of plan()'s variables and parameters are removed from the stack. Or we say popped" from the stack. Any question about that? So we finished our first function here. And then execution proceeds to code(), the code() function. And all of, so plan is gone, and now all of code()'s variables and parameters are put on the stack, or pushed onto the stack. Then code() finishes execution and it's cleaned off. Then mps() finish execution, and they are popped from the stack. And then we hit in the course of execution, exams(). Oh, here we are. exams()'s function together with all of its variables and parameters are pushed onto the stack. Winging it, always good advice, pushed onto the stack. Winging it completes execution, so it's removed from the stack. We finished exams() Oh and look, we finished studyHard() And now we proceed to doGoodWork(), DGW Ok, any question about that So you can see that memory is being reused as the execution transfers from one function to another. And it's kind of easy to see how the interpretation of memory location would kind of get convoluted if you're not very careful to keep track of what you're doing.
Variables, variables and parameters, so this is main()'s variables and parameters all inside that box. Ok so the question is: what's in scope? The question is what's in scope. And the answer is everything on the stack is effectively in scope. And things go out of scope when they're removed from the stack. Ok this is just an example albeit a fairly, this is a superficial explanation of what goes on here. It's not the substance of this course to actually look at this in great detail. I believe that's a 241 topic to look at how that memory is actually used and allocated and what it looks like. This is a diagram for what happens. Alright similarly you've probably seen, you've probably noticed when you use a good editor, I'm going to change the type of my stack here, when you use a good editor, it keeps track of parenthesis for you. It keeps track of opening and closing parenthesis for you. The process of doing this goes something like this We are going to read this sequence of brackets and parenthesis left to right and you can imagine that there are other strings in between. But we're going to process this and our whole question is: is this a valid sequence of parenthesis and brackets and square brackets. Is this a valid sequence? The algorithm for checking is merely this. If you see a left bracket of any kind, push it onto the stack. If you see a right bracket of any kind, pair it with the top of the stack and pop off the left. Pop off the left. Alright lets do that really quickly here. So if you see a left bracket push it on the stack. I see a left. I see a left. If you see a right bracket pair it with the top of the stack. Do they match? Do these two match? Yes they do. So pop them off. And then we see a left. And then we see a right. They pair. Pop them off. Then we see a left. And another left, uh oh, and another left. I'm up to here. We see a left, I mean sorry, a right. It matches, so we pop. A right, it matches, so we pop. A left bracket, a left, a left, a right - it matches, etcetera. So the code for doing this is actually very very simple. If left bracket, push. If right bracket, pair and pop. About two lines, right? Lets move on here. Any questions about this? Boring? Sorry Alright. Let's write some code, that's always comforting right? Instead of talking lets write code. So stack is, we have an abstract data type that describes a stack. Here are the classic functions: push and pop. Push is our way of inserting data.
It is not called insert because it is not a generalized notion of inserting into the structure. We do not have the flexibility of putting the data wherever we want It has to go at one end of the linear structure. Similarly for pop, pop is a remove that it is not a generalized remove at all. It's going to give you a particular value from the stack that is the thing happens to be on top Now this is the interface or the abstract data types struct. You may see some modifications of this  For examples, sometimes pop does not actually return the value sometimes it just remove it sometimes there's an additional function called peek that allows you to look at the top value almost every implementations of stack i've ever seen has had a function that will tell you whether not the stack is empty and then you know possibly there are the big three depending on the implementation alright so three though are classic and part of the abstract data type now notice that that means we can use the structure now because if you write code like this you can tell at any given point what the data structure looks like so i mean this is just, i will warn you again if i go to this so i mean this is just, i will bore you of o go through this I'm going to push a three push an eight, push a four, do a pop and 4 is returned, do another pop and eight is returned  push a six, so right here the appearance of stack is like this, okay? any questions about that? alright, so do you feel like you understand how this thing works okay so know let's talk about this part, the elephant in the room how we gonna make this happen, how we gonna implement this it is a linear structure, it is the stack itself is a linear structure like I said the data there's a notion of the next one so that suggests particular implementations  what are some ideas, how could we implement this what kind of structure do we know about that we can use to support that interface  somebody raise their hands and have a conversation with me. nope? if i close my eyes and point to sombody? you 233333333 what are some ideas can we do I can use a linkedlist right very good  I can use a linkedlist  is that the only alternative? raise your hand if you were kind of wanting to suggest linkedlist  but you are glad I pointed him instead of you, okay? raise your hand if you might have another idea for implementaion could use an array right, so any time at this point anytime you have a linear structure that is a structure where your data falls right next to each other your two alternative consider  are linkedlist and array now the technical detail are yet to be discussed, we have not talked about if it is a dynamic or static array we have not talked about if it is a singly link or doubly link or crazily linkedlist? but nonetheless it is pretty easy to have a conversation about the two and in fact those are the two we gonna consider for this okay? any questions about that ? so just out of curiosity raise your hand if you think, well, if you prefer linkedlist your favorite choice is linkedlist here, raise your hand high, come on this is fun and raise your hand if your are sort of array-centric  if you'd rather use an array in this context look it is about fifty-fifty  there's no right answer here both of these are good options alright, so it turns out the first one i decided to talk about is a linkedlist and here's how we gonna implement it we are going to prepare a stack node  it should look pretty familiar to you, you've seen this before okay? and we gonna keep a hold on the stack be at the top that is we are just going to call that pointer that holds towards data on the top okay? hm.. and we are going to keep track of its size okay so just because it is a .. any questions about that part at all? okay is the constructor implemented there?  no it is not i'm going ahead and do this the stack top equals  null implements the constructor there size equals zero top equals null okay? I thinks that should leads to a question
Does that lead to a question? I didn't make a slide for the constructor of this thing. Is that ok with you? So there's the constructor. Just set the top equal to null. Is that okay? It's probably okay. Alright fine we'll talk about it in a second. Alright so I wrote the code for pushing onto the stack. It creates a new node and fixes up pointers. What I would like for you to do is write the code for pop okay? go ahead and take a couple seconds given this setup go ahead and write the code for pop. And I'm asking you to kinda get into this consecrated mode just because it's good practice. Force yourself to write a little bit of code in this contexet cause after all this is much safer than the exam moment. You don't have to check for empty. You can assume that we're not goning to let the client pop an empty stack so you don't have to check for empty here. Okay, did you write the same thing I did? Okay so what my plan was to grab hold of the top here, grab hold of the top via a temporary pointer, move the top down so that it points down to the next one, and then delete the first node. Oh oh totally screwed up right. Do you see what I aww... No problem. Okay I totally screwed up. Do you see what I screwed up? Yeah? Thats right I have to have a return value, not only that I need to grab that return value, so I better have a declaration. My very first line should be stack item type returnval. = top's data right? Oh boy. Okay. I'm not going to make it that messy so stack item type returnval = top's data should go first, I'm sorry, and then return returnval. Okay a couple different ways of doing that the second you have a hold of it you can get it. Okay sorry about that. Any other questions about it? Okay yeah? You'll need to what? I did I updated the top, I moved it forward. Okay, alright so this is fairly simple, no problem here especially if you don't have to check to see if it's empty. Yes? Oh very good. Size minus minus. Okay good. Boy.
Any other questions about it? I am so glad that you guys are here. Debug my code. Wouldn't it be good if we can code like this all the time? It's pair programming taken to the extreme. Alright. Fine. So there is one thing I wanna say about the interface. I made a simplifying statement and that is, you don't have to worry about popping an empty stack. If effectively, I mean, in fact, you probably should write code that is a little bit defensive to that. You should have an exception handled here. But we are not in a business of doing that. And moreover, in this class, and moreover, the fact that we gave the client the capability of checking to see whether there's an empty stack. The fact that we created this empty function means we can say, Ho, dude, that your responsibility." You have to check, to the client, you have to check, whether or not this is empty. I made no promises if you tried to pop an empty stack, Ok? So, providing a functionality to the client for checking for empty is kind of our way of saying that it's the client's responsibility to do so. OK And this is it. This is about the simplest guess in terms of the implementation. And I thought you would ask, don't we want to use a sentinel node?" And the answer is no, we don't need a sentinel node here because all of our insertions and deletions are happening in that first spot." Right? We don't need to worry about the general case. In this case. So sentinel node is just sort of a waste of time here. Makes for more complex code. OK. So let's take about the array-base implement for a minute. OK. So the interface is the same. We are going to be implementing push and pop and, you know, empty just returns a boolean value referencing sending whether or not the size is zero. So that's easy. Here is the constructor I don't know which order I may wanna talk about this. OK So in this case, I've gotten an item's poin... I have items which is an SIT pointer. And because we are implementing this as an array, you recognize this is just a dynamic array. Right? This is just a dynamic array. Now size here, is intended to be the number of elements in the stack. Capacity is the number that our stack can hold. So this is... Capacity is capacity. Size is size. Right? Capacity is, the number we can hold. And size is the number we are currently holding, or the number we do hold. OK. Any question about that? Yeah? Ah, do we wanna make capacity constant. So this is the moment. This is the moment where, we actually begin to discuss what it means to have a dynamic array. Because if we did not allow, for the the array to have variable size, then that would present a huge drawback over using a linked list, right? And so now it is the time we are actually going to first exploit the fact that it is a dynamic array. OK? Any question about that? So it is exactly the right comment. Alright. So this is going to be a dynamic array. Capacity is deliberately not going to be something fixed. We are going to allow it to vary. Alright. So what does the constructor do? It makes... It starts off with an array of size four. Arbitraryly chosen. Could 've been one. Probably couldn't be zero though. That would not be accepted probably? And then it allocates the memory. So now, effectively, after this thing is constructed, we are dealing with an array of size four. Any time we push onto it, we're going to check to see whether or not the size is greater than or equal to the capacity. That is, is the array full? Is the array......full? And if it is, we are going to grow the array somehow. Oh, that's new. That's what we are gonna talk about the whole rest of the day. OK, we are going to grow the array somehow. And then, we are going to enter in the element that we want and increment the size. What does the code look like? for pop? What does the code look like for pop?
yeah right we have to return the value or grab this value for returning and then decrement the size, and that is it.  so pop pieces of cake    alright now let's talk about this issue of growing the array somehow okay so this discussion we are about to have apply not just for stack but also for queue any linear structure that uses dynamic array list 2 I just obfuscated it for list.  I said we are not gonna talk about it Umm, so here is the scheme suppose your array is full and another piece of data comes along ok  the idea is going to be that we are going to allocate some new spaces copy over the data from the old spaces yeah, copy the data the data from the old spaces and then insert the new spaces in its position in the larger array and then of course, you know, free up the old space and then rename the new spaces okay? do you like this ok that whole copy the data thing Laaaa that should make you crench right? copy the data ouch that hurts so our goal is to make the copy the data something that is rare our goal is to make it rare and somehow still make it so that we can accommodate flexible data size so how do we do this resizing? let's look at three different options, ok? so for simplexity, all of these resizing schemes are going to start with an array of array of size one then go build from there. so we are always gonna start with an array of size one, after it fills, we will do copying more over in analyzing these particular resizing schemes we only really gonna care about the copying that happens the inserting new data would have to happen anyways so it is sort of the extra work that we are gonna count for alright so lets say that our resizing scheme says well if new data comes along, if your array is full, and new data comes along it supposes to look like a person, did you get that, can you tell? so if your array is full and new data comes along then what you are gonna do is to make an array just big enough just big enough, then copy and insert that is the first scheme and the question is: how does this scheme do over a sequence of say n pushes to the structure so this bottom row is supposed to be, supposed to indicate n ok, alright, lets look at this in the first case, one thing gets copied in the second case, two things get copied. in the third case, three things get copied so we can write the expression that captures the amount of copying
it is 1+2+3+ all the way up to how far  n - 1 right okay and then I don't know about you, but I prefer to write this like this: k = 1 to n -1 of k because that reminds me of the sum, that reminds me of a result what is that sum? what is that sum? the closed form is : n (n-1) / 2 right? so here is how to calibrate this. ok? here is how to calibrate this, if you miss defined, you should get your calculus book and look this up, ok? If you are like, oh yeahhhh, I known that before in my life then you should get a 3 by 5 card and write that sum and put that on your mirror so that it get into your subconscious that is where it should live for you that sum right there should live like oh yeah, like yeah, I got it, ok?  it is ok if it doesnt yet because somebody, nobody else might told you that it should live there yet but it should alright, any question about that? ok, so for us we are concerned with asymptotic results so this is your , this is your index card if you dont have it we are concerned with the asymptotic results and as you would have learned in your discrete math classes this function grows like n square the laregest degree term is n square but remember this is n square over n push to the structure so we can just divide through by n so big O of (n^2) / n pushes implies an average of big O of N per push ok, which would kind of make sense because you are doing a lot of copy every time a new piece of data come in does this make you smile or frown is this good news of bad news this is really bad news ok that is a frown face and the question is can we do better? so let's try to do better instead of just making , um instead of just making the array big enough to handle one more piece of data what we are going to do is make it big enough to handle some fixed amount more data ok, we will call this c so if three and four full fill here dont put these here if three and four fill the array and 6 comes along, then what we would do is copy three and four, insert 6 and then we get a freebie right?  one more piece of data could come along and we wouldn't have to encoure any additional copying cost, and in fact in general  if you allow a fix number, say c of additional spaces then c - 1 free copy happen in the future, free insert in the future does that make sense? so let's see how this does in term of asymptotic running time do you have an instinct how well it does? yeah this one is gonna be a sad face too, this one is also going to be n square umm, should we do the analysis? probably ok, so umm, in general we are looking at blocks of size constant, some constant in the picture it is two and the amount of copying that happenes is some constant , i mean sorry some ,  oops
I'm gonna put a little question mark up there, we'll talk about it. Is k times the size of that block. It's k times the size of that block. Once for every-- so, you know , here's where k equals one, here's where k equals two, here's where k equals three, et cetera, we have n pieces of data. Now the qeustion is, how many of these-- how many times do we have to do this copying? Yeah, n divided by c and it turns out, minus one. So the top of this sum then is n over c and then there's this nasty minus one there because we're not counting what happens in the last case. Alright, well I know how to deal with sums like this. c factors out, and then you've got k equals one to n over c minus one of k. And that's just c times n over c times n over c minus one over two, and that's still big O of n squared over n pushes. Okay. Last one. What else could we do? This time, well take a look at the picture. What's our scheme here? Double the array every time. And this is what I believe you were asked to implement in MP2, right? And this is why. I believe, was that right? In MP2 did you implement a doubling of the array? Really? Okay, nevermind, maybe I don't remember. Okay, so suppose the thing filled, and new data came along. Our scheme is to take however big it is now and double the size, okay? So here's copying and here's inserting a new one. If a new piece of data comes along, double the size, insert the new data and now we've got a freebie, right? New data can come along and no additional copying is invoked. And when you get to this level, it becomes significant. There's copying, but then look at how many free inserts you get. Now, we want to analyze this in much the same way as we did the previous example. That is, we want to look at the amount of copying per copying event and sum that up over all of the copying events, okay?  So, let's see. It looks like we're going to go from k equals zero to I don't know yet, we'll talk about it in a minute. How much copying do we do every time? How much copying do we do every time? Somebody raise their hand and tell me the expression. Yeah? Yeah, good. Uh oh. What a mess. Okay. So, it's-- Two to the k, good. And how many of them do we have? How many of these things do we have?
Here is my hint. This is n.  And effectively, if you count, you're counting the number of times you can take n and divide it by half. How do you express that yea? Log based 2^n. Log is basically log b and number of times you can divide by b. That is the piece that should be internal. It turns out that this is. Oh, Log based 2 of n there is this minus one. We're not doing this in a row. Not counting it for the last row. Ok! Here let me ask you this. K equals 0 to 2 to the n equals what? I'll make this a T to make it less confusing. Whats that back pocket sum? It is 2 to the t plus one minus 1 divided by 2 to the minus one.  Two to the log based n two of n minus 1 over one. Or N minus one good.  N minus one copying. N minus one additional work. So how does this scheme do on a sequence of n pushes? It incurs big O of n work or n pushes or big O of 1 per push.  So on average, the additional work is just a little bit. Just a constant. OK? Alright I'll see you friday. 
There is only static here the mic was not working
(no audio)
(no audio)
[No Sound]
Hello I really hope I can listen to some kind sound here But I only see an indian guy's head Sorry Hand not head
(no audio)
[Silence]
[Video Playing] Operator+() overloading [Midterm 1 Review]
Okay, let's work  Okay, I know it's October It got cold, that's right Last time I saw you it was before you had an exam Now it's after you had an exam Our intention is to return those papers to you next week in section So, go to the section that you wrote on the exam, cause that's where we're gonna be intending to return it Did we define? We didn't.. Oh, this is our flaw This is the flaw with the system Right, big news! Huge changes this semester We're actually scanning your exam There we go You'll get your scores back via email It was me, not you! Okay And our intention is to have those back to you by the time sections meet next week So that we can give you averages and discuss the exam in that context Let's see, MP3 is still due Tomorrow night Today night, I'm a mess No, I'm sorry, no, no, no, but you said! I meant tomorrow relative to yesterday
So I apologize. It's definitely due tonight, the other thing that's going on in this window of time, I don't know what window it is exactly, but if you go into Siebel Center, it is filled with people, most notably alums. So yes, it's all their companies and stuff like that, but the cool thing for me is that it's people who were sitting in your seat just a few years ago.  So they're doing the recruiting thing and you're nervous about talking to them, but they're just like you, just a couple years farther on. So, be inspired by them, enjoy talking to them, don't be nervous talking to them, because we can break the chain of nervousness. They are, really, take it from me, I've known them and I know you, they're just like you. Maybe not even quite as smart. I'm just kidding. There's a million different definitions of smart, so when I say that I don't even know what I mean. Should I stop talking? Yes, yes. Okay. Last time we were talking about a new abstract data type called a stack. We're going to finish up that discussion today, and also complete discussion of another data type called a queue, that's right. So it turns out that stacks and queues are lumped together in almost every data structures book ever written. And the reason for that is because they're both constrained access linear structures. And a lot of the implementation issues that we talk about are the same between the two of them. What's very different about the two of them is their applications. So as we go on through the semester we'll see applications of each of them and we'll be pretty careful to distinguish one from the other in those contexts. Notably, MP4 helps you see some differences between them, how they work in the different application. Alright. So we were implementing a stack with an array, and I wanted to just ask you to revisit that. I understand that this is completely warm-up, but frankly, I need a warm-up. You might not, but I do. So, um, the stack had the following public interface, or abstract data type, both of those are sort of interchangable in terms of expression The function push" which is a specialized notion of inserting into the structure and the notion of "pop" which is a specialized notion of removing something from the structure. It's a linear structure that is the data, that is, the data is all lined up, in our understanding of that data not necessarily in memory, but you know, we can sort of think of it as being lined up in memory. As such, when we insert and remove from this linear structure, we're going to take advantage of this idea of the data being next to each other. Specifically when we push onto the stack, so pretend 8 wasn't there, we're going to push it onto the stack, the notion of next is generated there. Because the next data after 8 (8 becomes the first data element then), the next data element is 6, and the next one for 6 is 3, and the next one for 3 is oh, I don't know, nothing. There is no next one for 3, 3 is the end. Okay, so this idea of a next element is what creates this linearity in the structure itself. Similarly, when we pop from the stack, or when we remove elements from the stack, we exploit this notion of next, because standing behind this 8 ready to take its place is a value just sitting there, the next value takes its place. When 8 is removed. Alright, for the details of an array-based implementation, you take a look at the data contained in the private section and you see I'm going to start at the bottom. What is this? Not literally, but what does it mean? It's a dynamic array, good, we'll talk about that in a second, what's this one, what does it communicate?
I went to San Louise in Tuesday I am sorry You have a exam Yeah I am grateful for that freedom I couldn't done this last semster I was just completely screwed up I've apologized  it is definitely due tonight  The other thing that is going on in this window time  I don't what window  is exactly but, I go over the siebel center, it is filled with people umm most notably alum so yes it's all the companies and stuff like that but the cool thing for me is that is people were sitting in your seat just a few years ago so they are actually yes they are known doing the recruiting thing and your are nervous about that talking to them but they are just like you just a couple years a around so be inspired by them   start to talk with them don't be nervous about talking to them because we can break the chain of nervous they are really, were taken for me they were known and I know you, they were just like you  maybe not even quite as smart I am just kindding There is a million of definitions of smart so when I said that I don't even know what I mean should I stop talking yes yes okay Last time, we were talking about a new abstraction data type called a stack we are gonna finish up that discussion today and also complete discussion of another abstract data type called a queue that's right it turns out that stacks and queues are longed together In almost every data structure book ever written  and the reason for that is there are both contained access linear data structure and a lot of implementation issue are the same between the two of them  what's very different about the two are their application so as we go on through this semester we will see application of each of them notably MP4 helps you see the difference  how to see the context of one application alright when we were implementing a stack with an array and I wanted to just ask you to revisit that I understand this is completely warm up Frankly, I need a warm up\ you might but i do so umm the stack has the following the public interface or abstract data type both of those are sort of interchaneble in terms of expression the function push which is a specialize notation inserting into a structure and the notion of pop()  which is specialized notion of removing something the structure  it's a linear structure that is the data is all line up  in our understanding of that data not necessarily in memory we can sort of think of it in line up in memory and as such when we insert and remoce and can take advantage of this idea of the data being next to each other specifically, when we push onto the stack so pretend it wasn't there the notation of next is generated there the next data after eight, eight becomes a first data element then the next data element  the next data element is six and the next data element for six is three and the next one for three is ohh I don't know there is no next one for three, three is the end so this idea is for next element is what create this is already in the structure  Similarly, when we pop() from the stack or when we remove elements from the stack we exploit this notion of next  because standing behind this eight ready to take its place is a value just sitting there next value takes its clicks  when eight is removed  for the details of a array based implemention  we take over the data section the data take over the private section and you see I am gonna start at the bottom   what is this not literally but it means it is dynamic array good we will talk about that in a second what about this one what does it communicate
Stacks and queues are lumped together in almost every data structure for most every written and the reason for that cause the most constrain access linear structure 
How many items are on the stack? Probably one way of saying it was this one. Size of the array. That's right. Or how many items could be on the stack. Ok, good. So we completely understand this implementation. Let's look at the function themselves. The way we have this set up, is so that the bottom of the stack in the array is at the front, or in position zero in the array. Okay, now, think about what that means. It means that,  position sizes will alwasys be one past the end of the data. Yes? Alright, so if you are gonna push something on, where are you gonna push it? In to postion size, that's where you gonna push it, and then you increment size. So size becomes an indicator for the top of the stack.  It is the location for the top of the stack or one path. So it indicates,  top of stack. Any question about that? Is that clear? Okay. That's what this push code does. Except for this part. Which is what we gonna talk about in a second. Let's talk about pop for just a second. Before we go on. Notice that pop returns the value ont he top of the stack, and then moves the top of the stack. What am I going to fill in here, the retun value, the thing that we are gonna return, lives where?  Make sure you can answer this, make sure you can answer it. Where does it live? Size minus one, that's right. The one before the sizeof() elements. What's missing there? I left the line, what's missing there? Decrementing size. Very good. Notice that simultaneously, I wrote code that says decrement the size. But what's really happenning is, I move the top of the stack down, the top of the stack is being moved down. Any question about any of that? I had quesitons for you. What's the running time of this thing? Running time of this one? Constant time? Absolutely. How about the running time of that one if you ignore the blue circle thing? The running time of this one if you ignore the blue circle thing, is also constant time Now that blue circle thing, the blue topological circle, is topologically a circle. is a source for concerns. I am gonna spend the next slide, alieviating your concerns of the cause of growing the array. So we spent a good portion of time last time. Deciding on an algorithm of growing the array. And the analysis that we did, let us to dispicture. I'm gonna remind you. Our staring position is with in a array of size one. We put data into it bacause we can and it causes us almost nothing. But we have a problem when new data comes along. At that point, the algorithm is to, I'm gonna put a little dot by it. What does that dot mean? I'll use a word allocate". You finish the sentense. Somebody raise their hand. Allocate... Please. Yes? A new array? Good. How big? Double the size. Twice as big. That's right. So we gonna allocate a new array, twice as big and then the bad news is we copy the data into it. That's right. We gonna  take this data element and copy it, and now, the cool part is now there is nice space for out new data. Hey that's our algorithm. I'm gonna pretend that we did that for a while. And look what happen when this array is full and new data comes along. Okay? The algorithm was, allocate new space, copy data. I am doing this so it reenforce that you have to wait a long time. For me to even copy that data, right?
And then we place the new data element in and now, here's the beautiful moment. Look at this. Look at how much keys we have bought ourselves. We don't have to worry about new data. We don't have to worry about new data arriving for this long. That's a super long time right? In fact, it's almost as much data as we already had in the limit. We are effectively buying our selves relaxation in proportion to this stressful copying, okay? Does it make sense to you? You know what I'm saying there? You know..bring it on, bring more data. I got no problem. I got space for a really long time. Questions about it? Yeah? I'm gonna address that in just a minute okay? I‘m gonna address that. I have a whole slide about it. Alright, we're specifically talking about an array, and how we're using an array here. Okay, so think about what this means. It means that, umm, where should I start this... Oh, I will start it here.  It means that we got fast fast fast fast fast, right? All that, no waiting, perfectly fine. And then, when something comes alone here, we've got.... Waiting time for data to be copied And then, things move fast again, right? So imagine what this means in the algorithm. It means over the course of your use of your stack, sometimes things are going great. No problem and sometimes you have to wait a little bit. Now anytime you don't have the same thing going on. Each time it becomes more complex to analyze. So what we are gonna do is to add up all the data we insert and items. We're gonna look at all the data that we insert and items. And we're also gonna look at the amount of time that we spend waiting over that time. And it turns out, if you look at the amount of time that you spend waiting, you get wait time on the order of N. Or constant time on average per push. So it's a rare long wait. So the punch line is, its order n for n pushes and the analysis of that comes from last time is a geometric sum which means O(n)/n and you can go back and look at your discrete math and homeworks for proving this, that this is O(1) per push. on average We admit some of them are gonna be long but on average. It's just like you are paying a little bit more for each one of them. Some of them are gonna go faster. Few of them are gonna go way slower. Okay any questions about that? Who else raise their hand? You are number 2 in the queue. (Can't hear) Umm it doesn't matter. I mean doubling is really easy. Oh you mean non-one? Oh it turns out that won't make a lot of difference, unless your stack is on average much shorter than the small ones you start off with. So if you have reason to believe your stack is likely to be pretty short, then yes. Any other questions?
and then we place the new data element in and now here's the beautiful moment look at this, look at how much keys we have bought ourselves we don't have to worry about new data, we don't have to worry about new data arriving for this long that's a super long time, right? in fact, it almost does much data as we already had in the limit you know, we are effectively buying ourselves relaxation in proportion to.. this, you know this stressful copy, okay? does that make sense to what i'm saying there?  that look, you know? bring it on, bring more data, I've got no problem, I've got faithful for a really long time question about it? Yeah? oh i'm gonna address that in just a minute, okay? i'm address that, I have a whole slide about it. okay? Alright, so we're specifically talking about an array and why and how we're using an array here Okay, so think about what this means, it means that... where should I start this.. oh, I'll start it here, it means that we've got fast....... right? all of that, no waiting, perfectly fine and then.. when something comes along here, we've got, waiting time for data to be copied and then, thing right? so imagine, imagine what this means in the algorithm it means over the course of your use of stack, sometime things are going green right? no problem and sometime you have to wait a little bit now, anytime, you don't have the same thing going on each time, it may becomes more complex to analyze so what we're gonna do is we're gonna add full of data we insert right and items okay, we're gonna look at all of the data that we insert and items and then we're gonna also look at the amount of time we spend waiting over that time and it turns out that if you look at the amount of time you spend waiting you get, waiting on the order of n, or constant time on average per push, okay? does that make sense to you? so it's a rare long wait alright, so the punch line is, it's order n or n pushes and the analysis of that comes from last time, was a.. geometric sum? I believe, just a little geometric sum which means big O of n over n, then you know you can you can go back and look at your discrete math homeworks for proofing this.... that this is big o of 1 per push on average.. we admit some of homework are gonna be long, but on average it's just it's like you're paying a little bit more for each one of them some of them are gonna go faster, few of them are gonna go the way slower okay? alright, any question about that? yes? who else raise their hand, you're number two in the queue yeah, go it doesn't matter, no, I mean doubling is really easy, so start off with one oh, you mean non one? oh yeah, that.. it turns out that isn't gonna make a whole lot of difference unless your stack is on average much shorter than the small one you start off with so, if you have reason to believe that your stack is likely to be pretty short then, you know, yes, that's.. okay, the other question..
And then we place the data elements in and now, here's the beautiful moment. look at this! look at how much piece we have bought ourselves.  es we don't have to worry about new data we don't have to worry about new data for this long that is a super long time,right? In fact, it is almost as much data as we already have  in the limit, you know, we are effectively buying ourselves relaxation in proportion to this, stressful copying.  Okay? does this make sense to you? see what i'm saying there? that, look, you know, bring it on,bring more data,I get no problem I've got space for it for a really long time. questions about it? yeah? Alright. oh,I'm gonna address that in just a minute. okay? I'm gonna address, I have a whole slide about it okay?alright. So we are specifically talking about an array and what, and how we're using an array here. okay. So, think about what this means. It means that, uh... where should I start this oh i would started here. It means that, we've got, fast,fast,fast,fast,fast,fast,fast right?all that.  no waiting. perfectly fine and then. when, something comes along here. we've got waiting time.... for data to be copied... and then things move fast again,right? So imagine, imagine what this mean in the algorithm. It means over the course of your use of stack. Sometimes things are going great.RIght? .no problem and sometimes you have to wait a little bit. now, anytime you don't have the same thing going on each time ,it becomes  more complex to analyze. so what we're gonna do is we're gonna add up all the data that we insert, right? n items. okay we are gonna look at all the data that we insert, n items. And then we are also gonna look at the amount of time that we spend waiting over that time and it turns out that if you look at the amount of time you spend with waiting you get,wait time on the order of n or constant time on average per push does that make sense to you? So, it's a rare long wait. alright So, the punch line is, it's order-n or n-pushes and the analysis of that comes from last time geometric sum I believe? just a little geometric sum? which means. big-O of n over n and you can go back and look at your discrete math uh, homework for proving this that is Big-O of 1 per push on average we admit some of them are gonna be long but on average it's just it's like you are paying a little bit more for each one of them. some of them are going to go faster a few of them are going to go way slower okay? alright, any questions about that? yes [joyful laughter ] who else raise their hands? you are number 2 in the queue. [students got the joke ] yeah you go uh, it doesn't matter.  no, i mean double link is really easy so, start off from  oh, you mean non-1? oh yeah, it turns out that that doesn't gonna make a whole lot of difference unless you stack is on average much shorter than the small one that you start off with. so, if you have reason to believe that your stack is likely to be pretty short,then you know, yes ok the other question
[Video Playing] And then we place the new data element in. And now here is the beautiful moment. Look at this. Look at how much piece we have bought ourselves. We don't have to worry about new data. We don't have to worry about new data arriving through this long. That is a super long time. Right? In fact, it is almost this much data as we already have in the limit. We are effectively buying ourselves relaxation in proportion to this, you know, stressful copying. Okay? Is that make sense to you what I am saying there? Look. You know. Bring it on. Bring more data. I've got no problem. I've got space for it. Questions about it? Yeah?  Oh I am gonna address that in just a minute, okay? I am gonna address that. I have a whole slide about it, okay? Alright. So we are specifically talking about an array and why and how we are using an array here. Okay. So, think about what this means. It means that, Uh, where should I start this. Oh, I will start here. It means that we've got fast, fast, fast, fast, fast, fast, fast, fast, right? All that, no waiting. Perfectly fine. And then, when something comes along here. We've got waiting time for data to be copied. And then, things move fast again, right? So imagine, imagine what this means in the algorithm. It means over the course of your use of your stack. Sometimes things are going great. Right? No problem and sometimes you have to wait a little bit. Now any time, you don't have the same thing going on each time becoming complex. So what we are gonna do, is we are gonna add up that we insert, right, n items. Okay, we are gonna also look at the amount of time that we spend waiting over that time. And it turns out, that if you at the amount of time you spend waiting. You will get wait time on the order of n. Or constant time on average per push. Okay? Is that make sense to you ? So, It is a rare long wait. Alright. So the punch line is its order n for n pushes. The analysis of that comes from last time was a geometric sum. I believe. Just a little geometric sum, which means big O over n. And you know you can go back to look at your discrete math. homework for proving this. That this is bigO of 1 per push. On average, we admit some of them are gonna be long, but on average, It is just like you are paying a little bit more for each one of them.  Some of them are gonna go faster. A few of them are gonna go way slower. Okay? Alright. Any questions about that？ Yes. Who else raise their hands? You are number 2 in the queue. Yeah, go.  It does't matter. I mean doubling is really easy. So start of looking at one. Oh you mean non-one? Oh yeah. That it turns out that it is not gonna make a whole lot of different. Unless, you stack is on average much shorter than the small one you start off with. So if you have to believe that you stack is likely to be short, then, you know, yes. Okay, the other question.
Very good, so you really really really want me to contrast to the linkedlist implementation I'm fully intending to do that but there's one more point I want to make before we get there, okay? Yes? Clear the heck out to here! Yeah? Yep That is exactly the point that I want to make Alright So imagine that we build this thing up We push a whole ton of stuff on our stack Way out to here, it's huge And all of the sudden we decide, oh, we're just gonna pull things off the stack Then we've got this array, maybe we push a few on here And, do that a while and eventually we get down here and our stack goes for ten year Just right in here, but we've allocated all this space That's a problem Is that what you're asking? That's his complaint What do you think? Yeah? Very good, exactly We're not gonna do the details of this Suffice to say, all of the same arguments hold in the process of resizing down I like the word I'll use it forever Resizing downward and in fact the accepted, the practical accepted mechanism  is to take it down when you're less that a fourth full If this array got down to here If this stack got down to about here We would resize it back to this size And, it turns out that the math involved in the analysis is exactly the same You're gonna be adding up a geometric sum and, you know what the argument you can make then is that you're never using more four times as much space as you need You're never using more four times as much space as you need and that's constant Does that answer your concern? Good, okay Good Yes? Yep Yep Yeah, very, very, good, very good That's right, so but, look what we've done We said we're gonna shrink it Down to here Right? We're gonna shrink it down to here The next thing we're gonna do when this thing... no, sorry We're gonna shrink this array, I'm talking about this example We're gonna shrink it when the data gets down to here So that means all of this Is available for your back and fourthiness Right? Because I'm not gonna resize up to this one again Until I get to this one Does that make sense? Am I pointing to the right things to make that clear? Yeah? And it turns out in the analysis, we did it carefully Allowing for that much of a slosh is good enough to prevent the behavior you're observing So in practice this is what we do Alright, any other questions about this? Actually the analyses hold whether you double it, triple it, go down by thirds, etc. But you have to use constant fractions or constant factors every time Alright, questions?  You good? Okay So lets talk about this, the elephant in the room Why are we even discussing an array based implementation when we can make the argument directly That we get constant time push and pop Remember, push and pop can occur in front of a linked list in constant time Just allocate a little bit of memeory Update some pointers, and we're good to go Oh, maybe I'm just lying to them, maybe I really should go test this out So I implemented, I did it in the context of a queue So I implemented a queue instead and added a whole bunch of data to it And did about a million operations on it And compared that with the same interface, the same test case, implemented using linked memory and  the queue, the array based implementation...
Despite the copying was ten times faster so, that right there is the benefit of using arrays assuming that they don't have poor cache-ing behavior which we learn about it in different class arrays win every single time if you can think of a clever way of implementing something using an array, do it. Alright, but the analysis here is array based implementation of stack to constant time pop it's a constant time push if capacity the cost over n pushes is big O of n for an average of big O of one per push when you take the algorithms course, cs 374, instead of calling this average, they are going to call it amortise analysis just an issue of, they have a different use of the word average" they are taking an average over different probability space it's okay for us to call this average in this context. So why consider an array? it's faster, duh That's just because of the way system handles memory allocation. Alright, any questions about it? Let's talk about Queue, YAYYY So this is a Stack, it's linear, constrained access. Often times people will refer to a Stack as a Last In First Out. Linear structure They might even refer to it as Last in First out Queue we're not gonna be so ambiguous about this. For us, we're going to say the term Queue, for a First In First Out structure. Now I cannot go forward without making this point I can never remember whether this is first in first out like whether the colloquial description of a Queue is first in first out, or last in last out.  And I like this form better, I don't know why But I think that the world imagines that you'll say this one, I don't know. Doesn't matter. So how does a Queue work? It's profoundly fair it's the way you line up in the dining halls are your dining halls cafeteria style or buffet style? Buffet? Oh maybe you still have to line up for buffet. We don't have to talk about this very much. Probably more interesting use of the Queue is to line up events in some time-driven application like a video game for example and there is an explicit event Queue in math case, so that means probably a little more useful if you are not hungry. What is the Queue ADT? There are different ways of specifying it, the language we are gonna use is Enqueue. We are gonna enqueue an item. Dequeue will return an item of some kind, and then we're gonna have this boolean function that allows client to detect whether or not the Queue is empty. There by freeing us of the responsibility including that code. Any question about it?
...was ten times faster. So that right there is the benefit of using arrays, assuming they all are going, you know, they don't have poor hashing behavior which you'll learn about in a different class. Arrays win every single time. If you can think of a clever way of implementing something using an array, do it. Okay? All right! Uh, but the analysis here is array-based implementation of a stack is a constant time pop, is a constant time push if there's capacity. Uh, the cost over n pushes is big O of n for an average of big O of one per push. When you take the, um, algorithms course, uh, CS 374, instead of calling this average, they're going to call it amortized analysis. Um, it's just an issue of, they have a different use of the word 'average'. They're taking an average over a different probability space. It's okay for us to call this average in this context. All right! So why consider an array? Heh. It's faster, duh. And, um, and that's just because the way the system handles memory allocation. All right! Any question about it? Okay, let's talk about a queue. Yea! Uh, so this is a stack. Um, it's cons- it's linear constrained access. Often times people will refer to a stack as a last-in-first-out linear structure, linear structure. Okay. They might even refer to it as a last-in-first-out queue. Ah! Okay, we're not going to be so ambiguous about this. For us, we're going to say the term queue for a first-in-first-out structure. Now I cannot- I can't go forward without making this point. I can never remember whether this is first-in-first-out, like whether the colloquial, um, the colloquial description of a queue is first-in-first-out or last-in-last-out. And I like this one better. I don't know why. LILO, right? Um, but I-I think that the world imagines you'll say this one. I don't know. It doesn't matter, right? They're the same. Okay! So how does the queue work? It's fair. It's profoundly fair. It's the way you line up in the dining halls, right? Oh wait. Do you- are your dining halls cafeteria style or buffet style? Buffet? Oh, maybe you'll still have to line up for a buffet. We don't have to talk about this very much. Uh, probably a more interesting use of a queue is to line up events in some time-driven application like a video game for example. Um, and if- and there is an explicit event queue in that case. So that means probably a little more, uh, useful if you're not hungry. Okay! So what is the queue ADT? There are different ways of specifying it. The language we are going to use is enqueue and we're going to enqueue an item. Dequeue will return an item of some kind. And then we're going to have this boolean function that allows the client to detect whether or not, uh, the queue is empty, thereby freeing us of the responsibility of including that code. Okay? Any question about it?
What do you think the next thing what we will going to do? We talked about the abstract data type. What is the next thing what we will going to do? We are talking about the implementation that's right. So how think our choices are for implementing a queue. We are implementing using a .... an array...or...a linked list. It feels deja vu. Right ok. We used an array or linked list to see how it plays out. Its a surprise for me for the first things what are we talking about. Oh yeah I love it. (Queue) So we are going to set up a linked memory base implementation and I am playing a game with you. I assert that we only need a linked list to do this because after all you keep blowing in one away for a queue.  In addition to the head, holding on to the linked list. I am giving you another pointer at the tail. And that tail is going to point directly to the last element. We are not going to mess with sentimals in this content.  The tail is going to point directly to the last element.  I want to know from you is which of these pointers first is entry to the queue and which of them is exit from the queue? Which of them is entry to the queue and which of them is exit?  I am asking you which one is the head. I will be question you about where is entry or exit from the queue? Ok.  When are you ready with your answer, put your head in your head. Ok. Right.  Alright. So raise your hand if you think that is the entry to the queue. The head of entry is the queue. Ok...Everybody see. And raise your hand if you think the head is the exit from the queue. Ok. Good. So there is a bit of disagreement here. Right.  The disagreement arises because of way the arrow is making you think. Ok. Because you think Oh look, those arrows tell the person where to go through this process. But think about it. Let's think about what we will have to do if this is the exit. Ok.  If that last element is the exit, how are we going to do it. What is that code look like? What is the code look like? You got to get the hold of this guy right. You need a pointer to that know right before. How much does it cost you? Big O of n. Ok so, um that's too expensive. You can do better. Ok. Let me summarize it first. Um so a tail exit is a induces-I think is right word-a linear time Big O of n a reset of the tail pointer. Ok. Can we do better? Removing this one taking that in the front. Sure. So, the exit needs to be the head all this means the head is the exit.
all right any questions about it oh yeah this only apply to a singly list I know. I just want to think okay plus who wants to keep track of all those the extra pointers when we don't have to  just gonna meaning you have bugs ok ?all right  let's see so what's running time of enqueue then constant time if we set it up wisely oh no it's dequeue either way so constant time either way wants running time of dequeue constant time if we are careful all right and that all I am going to say about the link list implementation of a queue. It's that ok I am assuming in this point you can write that code because it just about like insert that front Right? Yes? so this is a queue so the entry point is the opposite of what you chose for exit so we have to be careful with exit and entry is the other one now what you might asking about or what is an relevant question is what if you have some structure that allows entry and exit at either end and that called a deck or double ended queue and it's a real thing I mean it's like I think this is a perfect test question because it something that we don't spend a lot of time on but is perfectly with in your grass in terms of reasoning about how you should implementd so that issue that you bring up even through you didn't intended is actually dreaming. all right any other questions about this yes I am in the through that the quad ok? cause it a great question ok so the question is if we all command our structure if we all command our structure and the choice of ink color is a glue if we all command our structure with a tail before tail yeah we love thursday not thursday  if we all command with that do we limit the problem we have having to ret the tail pointer well we do but then we have a problem because we have  to reset the through by thursday pointer right? so so yeah it's also went a problem that it create another all right any questions about it ok let's see so the array based implementation of the queue given touch with the array based implementation of the queue I do know what I was gonna to say about it okay any question about the set up here, any question about the set up okay you can look at oh she must copy and paste it right? this slide looks a lot like that the stack in a face that has all the thing data associated with this  the question is what might we be talking about here so let's spend a few minutes kind of speculating on  kind of speculating on how we might use an array for the queue now just like we did for the link list implementation we need to decide where is going to be the entry and where is going to be the exit for our data okay? uh.. let me make sure I don't do something stupid here
All right any question about it yeah oh yeah this only implies to a singly linked list I know I just want you to think Plus to one simple keep trackable all those extra pointers when we don't have to Just gonna mean you are gonna have bugs All right let's see so what's the running time of enqueue then constant time if we set it up wisely oh no it's dequeue  Either way so constant time either way so what's the running time of dequeue constant time if we are careful All right and that's all I'm going to say about the linked list implementation of a queue is that okay I'm assuming at this point that you could write that code because it's just about like insert at front right So this is the queue so the entry point is gonna be the opposite of what you choose for exit. So we have to be careful with the exit and then entry is the other one Now what you might be asking about or what is a relevant question is that what if you have some structure that allows entry and exit at either end And that's called a deck or double ended queue and it's a real thing I mean it's like I think of it as kind of a perfect test question because it's something we don't spend a lot of time on but it's perfectly with in you grasp in terms of reasoning about how you should implement it So that issue that you bring up even though you didn't intended is actually germane All right any other questions about it  Yes I'm gonna throw that to the crowd cause it's a great question so the question is if we augment our structure and the choice of ink color here is the clue if we augment of our structure with a tail before tail  If we augment it with that do we eliminate the problem of having to reset the tail pointer Well we do but then we have a problem because we have to reset the throwback Thursday pointers So it solves one problem but it creates another All right any question about it Let's see so the array based implementation of a queue I don't know what else can say about this just absorb it meditate for a second give a touch with the array based implementation of a queue I do know what I was gonna say about it any questions about the set up here You can look at it and go oh she must have copied and then pasted it This slide looks a lot like the stack inner face it has all the same data associated with it  the question is what might we be talking about here so let's spend a few minutes kind of speculating on how we might use an array for the queue Now just like we did for the linked list implementation We need to decide where is going to be the entry and where is going to be the exit for our data
Alright Any question about it, yeah? Oh, yeah, this only applies to singly linked list, I know. I just wanted you to think.  Okay? Plus, who wants to keep track of all those extra pointers when we don't have to? Just gonna mean you're gonna have bugs, okay? Alright! Let's see.  So what's the running time of the onqueue then? Constant time if we set it up wisely. Oh no, it's dequeue. Either way, so constant time either way. And what's the running time of dequeue? Constant time. If we are careful. Alright!  And, that's all I'm going to say about the linked list implementation of the queues, is that okay? I'm assuming at this point that you can write that code because it's just about like insert at front, right? Yes? [Student Questioning] So this is the queue, so the entry point is gonna be the opposite of what you choose for exit. So we have to be careful with exit and then entry is the other one. Now, what you might be asking about or what is a relevant question is what if you have some structure that allows entry and exit at either end? And that's called a deck, it's called a deck or double ended queue. And it's real thing. I mean it's like I think it of as kind of a perfect test question because it's something that we don't spend a lot of time on but it's perfectly within your, your grasp in terms of reasoning about how you should implement it, okay? So, that issue that you bring up even though you didn't intend it is actually germane, okay? Alright, any other question about this? Yes? [Student Questioning] I'm gonna throw that to the crowd, okay? 'Cause it's a great question. Okay. So the question is if we all comment our structure, if we all comment our structure and the choice ink color here the clue, if we augment our structure with a... tail before tail Yeah. Thursday a throwback Thursday, it's not Thursday! Ha... Hahaha If we augment it with that, do we eliminate the problem of having to reset the tail pointer? Well, we do but then we have a problem because we have to? Reset the throw back Thursday pointer, right? So, so, yeah it solves one problem and creates another, okay. Alright, any question about it? Okay. Let's see. So, the array based implementation of the queue [Silence] I don't know what I was gonna say about this, just absorb it. Meditate for seconds. Get in touch with the array based implementation of the queue. I do know what I was gonna say about it, okay. Any question about the set up here? Any question about the set up? Okay, you can look at it and go oh she must have copied and pasted it" right? This slide looks a lot like the stack interface. It has all the same data associated with it. And the question is, what might we be talking about here? So we've spent a few minutes, kind of speculating on... Kind of speculating on how we might use an array for the queue. Now, just like we did for the linked list implementation, we need to decided where is going to be the entry and where is going to be the exit for our data, okay? Let me make sure I don't do something stupid here.
Well, I will let you vote. it's not gonna matter all that much. I'm gonna put e here and I'm gonna put an e" here, the other end.  And I wanna know,if I should write an x" next or "n" Okay? So raise your hand if I should write a x" next. So the exiting from the structure will happen here   Or n" next. Because the entrance into the queue should happen here, ok? You guys are voting. It's democratic, okay? All right, so raise your hand if you think I should write an x" Raise your hand if you think I should write n" All right, fine. It's all right. Raise your hand if you want vote again? Ok. Raise the hand if you think I should write x" Then raise your hand if you think I should write n" Ok, n" still wins. I tried "x"s. I tried.   All right. So the entry into the structure is going to be at the front of the data. And the exit from is going to be here. Okay?  Let's see how this goes. We are going to enqueue value 3 And you are telling me that should go right there. Yeah? Cause that's the entry enqueue(8)  Where should that go? At the entry, right? There's no room at the entry  You like it? You want me to write x" there instead?  All right. Fine. Startover.So I've got bunch of these Put the exit there and put the entry here Ok? You are not gonna like this one either  I got three of them. Can't you tell. Ok. Enqueue three.  Enqueue eight. Maybe you do like it better. Maybe I've just forgot how to do this class Enqueue 4. Oh this is easy. Dequeue.   So three comes marching off And I gotta do that. So what are you telling me Who said that Move the exit. How am I gonna do that? Yeah, ok. I'm gonna change what you said Change the index, right? What is the entry? It's just the location. It's just the index of the array, right?  So go ahead and move it. Who cares where it is. Just some small integers. That's what we gonna do This empty space here is going to be used to keep track of where the entry and the exit are to our contiguous collection of data  So I'm gonna have a integer exit and a integer entry And enqueue occurs at the entry and they start off both at zero I guess. Now let's play this out a little bit. Ok any questions about that? Do you see what are we gonna do?  So at this moment where I say dequeue for the first time, exit is just gonna be moved over and I just always keep track of where it is And in fact, where's the entry going to be? What does entry mean?  It's always gonna be, I'm gonna keep it is actually one pass. Sort of like size in previous example. So entry is just the index  showing that location and exit is just going to be the thing that leaves okay? Any questions about it at all? All right. So lets carry this out a little bit I’m gonna carry it out on this slide. It's gonna be a mess. Be ready for a mess? Take a deep breath and think of your dorm room. It's a mess. I never really moved out of my dorm room you should see my car. All right,  All right, enqueue seven. I'm gonna put seven in there and move entry. Dequeue becomes a matter of moving the exit and returning the a and it's very much like the whole pop. Dequeue again. You are gonna return four. Enqueue two. This is gone and this is gone, sorry. Enqueue two moves entry here. The entry ones are on the top and they are moving to the right. See what I did there? To the right  I did enqueue two. I'm gonna do enqueue one. I'm gonna do enqueue three. I'm gonna do enqueue five. Uh-oh
well I'll let you vote, it's not gonna matter that much... I'm gonna put an E here I'm gonna put an E here, another end. And I wanna know if I want to write an x and store in...ok so raise your hand if I should write x next, so the exiting from the structure will happen here, or an next because the entrance into the queue should happen here...ok can you guys vote it, it's democratic. OK, all right, so raise your hand if I should write an x raise your hand if you think I should write an n... all right fine... all right. raise your hand if you want to vote again? ok, raise your hand if you think I should write x... raise your hand if you think I should write x?... x still win  I tried access, I tried.  All right, so the entry into the structure is going to be at the front of the data. and the exit from it is going to be here, ok? let's see how this goes we are going to unqueue value 3 and you're telling me that should go right there, cause that's the entry onqueue 8 where should that go at the entry right? there a room in the entry yeah you like it? you meet the next room instead all right fine start over, that's why we got bunch of this ok... the exit there....put the entry here ok ....em... I grab three of them... can't tell ok unqueue 3. unqueue 8 oh.. maybe you do like it better. Maybe I just forgot how to do this class unqueue 4 oh this is easy, dequeue so 3 comes matching off...and am I gonna do that, so are you telling me... this said thaty move the exit... how am I gonna do that yeah..ok, I'm gonna change what you said.. change the index, right? what is the entry? it's the location, it's just the index of the array...right? so... go ahead and move it, who cares where it is, it just some small integers. so that's what we gonna do ok this ... this empty space here, is to be used to keep track of where the entry and exit are to our continuous collection of data. so... I'm gonna have an integer....em...exit and an integer...entry and unqueue occurs at the entry, and they start off both at zero I guess now let's play this out a little bit ok, any question about that, do you see what we gonna do? so at this moment, where I say dequeue for the first time exit is just gonna be moved over and I just keep track where it is. and in fact, where is the entry going to be, what does entry means. it's always gonna be I am gonna keep it as actually one path, sort of like size and previous sample ok...so entry is just an index and em... showing that location and exit is just going to be the thing that leaves ok... any question about it all? all right so let's carry this out a little bit I am carry it out this slides... it's gonna be a math, ok? you ready for a mess? take a deep breath and think of your dorm room. it's a mess ok  and I really moved out my dorm room maybe you should see my car...all right... all right ...unqueue 7, I'm gonna put 7 in there move entry  dequeue... becomes a matter of moving the exit ...yeah and returning the 8 is very much like the whole pop  dequeue agian... gonna return 4... on queue 2 ok so this is gone and this is gone, sorry. unqueue 2, moves entry here ok, the entry wants on the top, and moving to the right see what I've did ther to the right very hard ok um...I did on queue 2, I'm gonna do  ...  I'm gonna do unqueue 1, I'm gonna do unqueue 3  I I'm gonna do unqueue 5...
comments                                               i can resize the array right? then what should i do? why not? cuz I could dequeue all of this and resize the puppy to one day element  right? so resizing is what we want to do here what you wanna observe is the look it theres all the empty space over here there is all the empty space in the front of the array and so effectively what you are gonna do is wrapping the array around, if you are gonna wrap the array around and move entry to its new spot okay and I'll make it a double way to kind of see okay any questions about it? and how do I do that functionally? mod is your friend the mod operator is your friend  here okay yeah? oh very good. So just a second. Let's get there. Okay. So is it clear where we are here and then I'm gonna dequeue that moves this guy down here and then I'm gonna enqueue nine nine goes here and in fact what we end up with is this okay I think entry's on the top. This thing should be on the botton okay alright. Any questions about it? Yeah?  You can figure out where entry goes by taking incrementing it mod tablefies and it will always just put it in the right place okay yeah so in fact in my code, my index is a mod index. So I know that I will never go outside of the bounds of that array because I'm always going to take mod the array size. Okay Alright! So lets do this a little bit more. Any questions about it so far? Yeah? un-huh un-huh I'm not quite with you yet. okay? Hold on just a sec. I wanna just get us there for a sec okay so you guys are really bothered by the fact that we are kind of screwing up where the start of the array is. Okay? Alright! Fine. Let's do a couple more enqueue y, moves this, enqueue i, moves it again, enqueue s, moves it again. right? so now entry is here, exit is here. so that becomes a task when you enqueue right? Are they in the same spot? Has there been data, is there data in the array and are they in the same spot? then you can argue that the array is full. Okay? Alright! and of course, the next thing is dequeue so that doesn't actually happen at that moment  but happen in a couple more a bit. We are going to keep going okay? Alright! So. What are you gonna do? I've got this sort of gap here I got this sort of gap between what's in the start and what's in the rear what should I do?  I'll give you a hint. The hard answer, the complex answer, the one that makes you go like huh? is not the right one I know haha right? I would set a.. okay, well, lets fix this first and then I'll tell you my stories , so let's see okay. Alright! so all you do is totally easy. All you do is you just reset.  you take the exit an you put it here and you increment. Exit increment forward size number of things, items, sub, you know, k  where k is in the element of exit up to entry mod table size  and those go in the position 0, 1, 2, 3 up to k capacity. those go up to capacity minus one okay. Does that make sense? So don't worry about like Oh there's yeah. there are overlapping here and just start over. give yourself a clean slate feels great Alright! Any questions about it? is it good? I'll tell you my stories some other times, it's cute. Alright that's all I have. Look at that we did it. Yay!
Umm So let's see Mp4 is out If you are going any extra credit all term This is the one, this is the one to go for 4.1 is - who's done it. Who's already done 4.1? How many lines of code did you have to write? 10-ish on the order of 10-ish But There's a cognitive leap that happens There's a cognitive leap that happens Umm For those particular 10 lines of code So you guys all saw - Raise your hands if you are done with 4.1. So then, put your arms down. Okay that's maybe 20% of you tops. Now Among you who are done, raise your hand if you were surprised by how it all turned out Raise your hand if you are kinda surprised by what that code ended up looking like And raise your hand if you were surprised in a good way with how that code ended up looking It's really - really? That's all you want us to do? Okay Fine\ Okay Especially for the queue class The stack class is little bit more Alright So There was apparently someone posted in Piazza that 4.1 was due tomorrow night I don't know where they got that idea. It's actually due Friday night. So you have some time here. Alright Are there any other administrative questions or issues you want to address before we start working? Your exams are being graded. I don't know the status because I couldn't look at the Google docs.. They told the status this morning. So I don't know the status. We'll all find out together. I have some code for you. It's my little Monday gift. And here's what I want you to do: I want you to figure out this code and put a little dot beside everything that surprises you So for about the first 10 minutes or so of today We are going dissect this code And talk about all the things that surprise you about it. Nothing surpises me anymore But we're gonna talk about the things that surprise you about this code So scrutinize it Talk about it with a friend  I'm gonna take a break [Silence] [Silence]
  walk my pen down the edge of the code and you yell at me or raise your hand and start dancing or something and tell me when there is something you would like to discuss. In the code or it doesnt even have to be something that you think is interesting. let me know if you see something that you think someone else in this room will think is interesting So you don't even have to commit to being interested just if you think somebody else is interested. speak for the crowd here. intertesting yet? yea okay guess what our converstion about adstract data type list was unneccessary.  we didnt have to have it because the standard template library provides a list for us. a list class for us We didnt have to define our own interface So the point is that there is already a list abstract data type defined for you and implented for you in the standard temple library and the only thing you have to do to access it is you use angle brackets And its also very well documented so i am not going to spend a lot of time in theis class tlaking about the differences between our list class and their list class. but suffice to stay that most of those differences aris ein the interface between the user and the clss itself so the functions they have for oyu are slightly differnet but larglerly the purpose to fthe thin gis the same  Sequentail ordering of objects That is true for a lot of different container classes so going forward it will be true that we will look at some abstract data types that are in fact also avlabile to you via the standrd temple librayr but we will be discussing here is what they look like under the ood so just beyound the interface I am going to keep walking down the screen then  tell me when to stop i am going to stop  because okay fine somebody who didnt want me to sotp You didnt want me to stop so im going to ask you what is that thing and if you dont want to answer than you can name somebody else we dont have to stop on structs anymore because they are just classes where the default of everything is public  so those are exactly equlvant to what i have just odne there keep wlaking down the screen stop first of all what is that line 
its a constructor.  oh you snuck in two lines there, you snuck in two lines.  its a constructor, very good, with an initializer line.   good. so he snuck in two, did you see that, the constructor,  and then everything after this colon is used to initialize the members of the Animal class, I mean struct.  OK?Any question about that? can I keep going?  no, I can't keep going, i can't keep going, are you kidding me?  there's some new syntax here. Let me tell.. (crying and laughing..)  Sorry, well, this is, I'm like blushing, I'm sorry.  I did! I saw you running outta the building!  Oh they are having so much fun! OK, no more giggles, there shall be no more giggling, ok, for me.  Alright, take a look at the constructor for a second.  It's not just one constructor.  It's a whole bunch of different constructors because it allows you to give default values in the absence of specifications.  So in the absence of specified parameters, this construct allows you to give default values.  Now, I do have a hard question for you related to this.  And that is how many constructors is it?  six is one answer. four might be another answer.  Take a look.  eight might be another answer. one it's not one, I'll tell you right now it's not one, it's a whole bunch.  OK, so think about all the different choices here, think about all the different choices.  What you might think you can do, this is a reasonable thing to think , you might think that inside each of these locations, you can either specify a name or not,  specify a food or not, specify a big or not.  If that were the case, this would be like eight constructors, right?  This would be like eight constructors because it's 2 to the 3rd for the different options there,  but in fact, in fact it doesn't work that way.  It doesn't work that way.  If you choose to make, let's see how does this go, what's the best way to.  If you choose to specify one, you must start specifing them from the left.  So, the defaults are allowed from the right, so you can leave off the big or not , you can leave off the food and the big,  but not the food and then specify the big.  Make sense? and you can leave off all three if you like,  but you can't just pick and choose, you can't say ok I'll specify the name and the size"  you can't do that. OK?  not even with clever use of commas. The fact of the matter is that the grammar that describes the language doesn't allow you to do this.  Any question about that? That will become clear, I'll talk about that a little bit more as we actually declare some of these things.  OK, so that said, how many constructors is this?  four constructors, that's right. There's a no argument constructor. x What's the no argument initialize things to?  a big blob that eats, yes, big blob that eats you.  The default animal is a big blob that eats you, and that's you specify no parameters,  or you can specify, uh, wait. Or you can have one parameter, or two parameters, or three parameters.  Alright, let's see. OK, yes?  that's right, you cannot just initialize the boolean value.  If you are gonna initialize one thing, if you are gonna pass one parameter to your constructor,  So, if you're gonna pass one value to the constructor, it's gonna be the name of the animal.  OK? That make sense? If you're gonna pass two, it's gonna be the name and the food.  If you're gonna pass three it's gonna be all three. Yes?
Yeah, exactly. Right.   Yup. Yup. Yup. Okay, any other questions about the animal class? The animal struct, whatever? Ok, it is worth noting that this semicolon is necessary. Just because it's such a common bug we don't want you to deal with it. Alright, so now let's use this class a little bit. These are a sequence of valid declarations. These are a sequence of valid declarations invoking each of the constructors that we just talked about except the no argument constructor So, here we are declaring a giraffe that eats leaves. Is it big or not? It is big. Giraffes are big, duh! Ok, this one is a penguin who eats fish and its not big. Right? Okay, and b is a big bear that eats you, that's right. So blobs and bears eat you. All right. Ok, fine, and now I'm gonna walk down just a little bit farther here and ask you about this one. What's going on here? What is it? You might want to use a D-word in describing this.  Yeah?  Yeah good. Its name is... So you're declaring a list of animals named zoo". So zoo" is a list of animals. So this is using the STL List class. Now it's a quick Google search away to find out what the interface to the List class looks like, but I'll tell you that the insert... what we could call insert at end"... if we were to make a function, we would probably call it "insert at end" The standard template library uses push_back". So, we're adding our giraffe to the zoo. How many things does it have in it, right here? One, so it's a list of length 1, by here. Then we add another thing to the zoo. And then we add another thing to the zoo. Ok? Any questions about that at all?  Ok, let's take a break then, or take another couple minutes... ...and do the same thing with this code. This is gonna take a little bit more untangling. You should see something entirely new here, so go on a quest, and try to figure out this code. And up till here it's the same. So up till there, this is just a continuation of the code on the previous page.  Take a couple minutes, and figure it out
Yeah exactly right yes Okay all right any other questions about the animal class,the animal struct whatever It is worth noting that this semicolon is necessary  just because it's such a common but we don't want you to have to deal with it All right  so now let's use this class a little bit These are a sequence of valid declarations invoking each of the constructors that we just talked about except the no argument constructor So here we are declaring a giraffe that eats leaves is it big or not it is big, giraffes are big This one is a penguin who eats fish and is not big, right, false and b is a big bear that eats you that's right so blob and bears eat you Fine and now I'm gonna walk down just a little bit farther here and ask you about this one What's going on here What is it? You might want to use a d-word in describing this Yeah good So you are declaring a list of animals named zoo so zoo is a list of animals  So this is using the STL List class Now it's a quick google search away to find out what the inner face to the list class looks like But I'll tell you that what we would call insert at end if we were to make a function we would probably call it insert at end the standard template library uses push_back   We are adding our giraffe to the zoo How many things does it have in it right here One so it's a list of length one by here Then we add another thing to the zoo and then we add another thing to the zoo Any questions about that at all Let's take a break then or take another couple minutes And do the same thing with this code this is gonna take a little bit more untangling You should see something entirely new here so go on and quest and try to figure out this code And the only thing up till here is the same As this is just a continuation of the code in the previous page Take a couple minutes and figure it out
yeah yeap yelp,exactly right yes? yelp yelp~ yelp okay uh,alright Any other question about the struct the animal class? animal struct,whatever? ok.It's worth noting that this semicolon is necessary because it's such a common bug,we don't want you to deal with it  alright so now let's use this class a little bit these are  uh these are a sequence of valid declaration these are a sequence of valid declarations invoking each of the constructors that we just talked about except the no argument constructor  except the no argument constructor so,here we are declaring a giraffe that eats leaves, is it big or not it's big,giraffes are big okay this one is a penguin who eats fish and is not big right? and b is a.... big bear that eats you that's right so block and bears eat you alright ok fine. and now now i am going to walk down just a little further here and ask you about this one. what's going on here? what is it? you might want to use a D word in describing this yeah? yeah good whose name is, good so you're declaring a list of animals named zoo" so zoo is a list of animals so this is using the STL list class now it's a quick google search away to find out what the interface to the list class look like  but i'll tell you that uh, the insert well, we will call insert at n,we would, if we were to make a function we would probably call it insert at n uh, the standard template library uses push back okay?so,uh we're adding the giraffe to the zoo. how many things does it have in it right here? one,so is a list of length one by here then we add another thing to the zoo and then we add another thing to the zoo any question about that at all okay. let's take a break then or take another couple minutes and do the same thing with this code this is gonna take a little bit more untangling. you should see something entirely new here so go on a quest and try to figure out this code and the only thing, it mean, up to here, it's the same okay, so up to here this is just a continuation of the code on the previous page take a couple minutes and figure it out.
[Talking about the football game.  Nothing related to the lecture.] All right. Should we work? Let's work. All right. So I have a for loop for you. I have a for loop for you. OK. What you normally see if this were a for loop like those you had seen before most frequently?    What would you see right following the letters F, O, R ? What would you see there?  An integer right? Integer i = 0, right? That's what for expect. That's what the for function expects to see right? It expects to see a type of thing that can be initialized to a start value. Now. In this instance what we have is not an integer. It's a generalized notion of something that can be incremented. And we refer to it as an iterator. Okay. If you look at the role that the integer i plays in that place. It is something to use to iterate through some structure right? It is incremented incremently. Umm... It is incremented as by virtual for loop. And  that's what you should expect to have happened here for this new type of thing that we happened to be calling an iterator. OK. All right. So yes. Just as you normally expect to see an int there. In this case we have another kind of thing called an iterator. Hold on.I'm gonna make this right. So this replaces the int kind of thing okay? But it's just an iterator. All right. Fine. What is IT? The name of it right? It's like i. The name we happen to choose . All right. And in stead of setting it to zero which happens to be rather arbitrary really as our place where we normally start counting.  We're gonna use this abstract notion of this starting place called begin(). OK? What normally goes here? It usually goes like i is less than size or something right? OK. All right. And so now instead of that, we say okay.  I'm gonna take this generalized notion up to the end of whatever it is. So we go from the begin to the end okay? Uh... What is this ?What is begin()? It's a function. Very good. It's a function in our class . Does it dwell? well list class... The standard template library list class gives us this function  calledd begin().What's begin()'s return types? What is  begin()'s return type? Iterator. Right? It's return type is an iterator. How do I know that?
Because of the assignment statement. That's right. So, zoo is a list class thing. It must have.. oh is begin public or private? Public.That's right! This is a client code where we are using that function. So, begin is a public function in the list class returns something of type iterator. Where the heck did that come from? Where did iterator come from? It's a type. Where does it live? Also in the list class, that's right, it's a new type of thing, lives in a list class. Is it public or private? Public. Has to be. We are using it, right?  So the standard template library's list class is actually much*4 more sophisticated than ours. because it's got all these sexual stuff. It has this iterator class that we get to use if we want, and these other functions that help us set up our iterators, OK? Alright. Fine Just as if IT were an integer, will allow ourselves within the for loop to increment our iterator,  so we can increment the iterator just like we would if it were a integer. But there are other things we can do within an iterator. Take a look the next row. What on earth is going on here. what on earth is going on here. We dereferenced an iterator. What do you expect that to get you? If we are asking for a name, what do you expect to come out of here. An animal, right? An animal.  Who's animal? Where was it? It's in the list class. It's in the list, right? OK. So what is an iterator It's something that is stepping through the list. It allows us to move it, and allows us to deference it. It allows us to ask for its value. OK. That's cool. Yeah? So is an iterator an address or something? Any other...Raise your hands if you agree with that question, if you are like what the heck. about this. OK. So here is the thing, you don't get to ask. You don't get to ask how it is implemented You are asking me You're asking me.... Think about this for a second. He is asking for on behalf of all of you, it's not just him, he's asking about the implementation And I'm saying: you don't get to know how it is implemented. Why? What principle allows me to do that Encapsulation. That's right. The implementation of that iterator is encapsulated away. All we know is how to use it, OK?  So swallow that pill. Swallow it. Go ahead and ask. Yes, Yes There is this notion of next. Now in the list class you have this adjacency but, and you kind of  have this notion of first and second and third. But, you know, we will see structures where the ideal of next  is a little more ambiguous. I don't know. Should I go left to right? I don't know. which one is the next one? And an iterator promises it will give you your stuff back out of your structure in some order. OK. For list, it promises to step through from beginning to end in a predictable order. Alright. Yes. OK! So let's talk  implementation for just a second. How do you think this happens? What do you think this implementation kind of looks like?
It does this and it does this. so what are you thinking, it kinda looks like? it's got. yes? yes! exactly those operators are overloaded inside the iterator class. that's what the iterator class does, it overloads those operators so that you can do, can work this magic. now the question was, why don't you do this instead and the answer is that that would require that to be overloaded and i'm not sure if it actually is for this standard template library list class. i just don't know ok. um iterators promise that the plus plus will be overloaded and that the asterisk will be overloaded so you can both move this thing and look inside your structure. that is a promise from an iterator k? this is a good time to say uhh where that promise came from like it's a promise but who said, who said thats a promise? So an iterator is a notion that was added onto the language later because it was so frequently deployed, it's called the design pattern. It's not fundamentally part of the language but it is a part of the cultural experience of the language to know what it is. So what is an iterator, anybody you talk to about c++ will know what an iterator is. And it is formally described but only functionally not as an inherent part of the language it self. so there is this conventional agreement that iterators will always implement something that increments and something that gives you its value. Nathan? Yeah? right. So how do you know you're overloading dereference, or multiplication and the answer is in the number of arguments, so when you dereference, so remember that a function is in part declared by its parameters, i can have two functions of the same name but if they are parameterized differently, then they are different functions, and the same thing is true for dereference operators. it has one and in fact in this case, effectively there are no arguments, it is just the thing. K. and instead of the binary operator. Yeah? could i accomplish this same thing with primitive types? not nearly so elegantly right? So i could do this if i implemented my own list class with a dynamic array and made it but so i could do this in C is sort of what you're asking me basically right? but i wouldn't want to. i wouldn't want to, this is one of the elegances,  elegancies from having C++ ok? Alright any other questions about this right now? ok alright. so uhh, my question is for you, is what is printed out? this is cout, this is the contents of our list, what is printed out? k so the names so we get giraffe, and leaves, and then the next time through we get penguin, and fish and then... do you? 
find the end implementation of structure container overloading
Then the standard template library container classes, usually will have a forward iterator, a backward iterator, a bidirectiional iterator, it can go forward and backward, and const versions of each. Which means you can look at your data, but you cannot change your data. Any question about all that? Okay, how do you think we achieve this reverse iterator? Going backward through the list. Minus minus. it overloads minus minus Any questions about it?  Okay, alright so lets talk. Oh. Here's what I want for you. I want you to be able to leave this room and feel confident using iterators Get the right google search and find the appropriate iterator to write code that traverses any kind of container class. Also, if your employer or your advisor ever says bring me somebody to implement a new iterator, I want your to be the one that goes oh Ill do that So we are going to pull back the hood a little bit and look and speculate about exactly how these things are implemented. So that you see what kinds of decisions your would have to make if you were actually to do an implementation. So, We agree I think that we're going to need for if say a linked list were the thng that was encapsulated, we would need some private member to keep track of where we were To keep track of the fact that your iterator is pointing to that one instead of to any other one. Were going to do that via some private member It means private member so if you were a linked list and you want to keep track of where you were. What kind of thing would you do. What kind of thing would you keep track of if you were trying to keep track of where you were if you were a linked list. In a linked list, you have a listnode pointer, you might call it curr and it might sit there until somebody did this plus plus If somebody said iterator, what would happen to that curr Plus plus is implemented like curr = curr->next And how would you look at the value inside how would you dereference How would you look at the value inside of that pointer You would look at curr's data you return curr data Look your have almost implemented an iterator for a linked list class What would a reverse iterator for a singly linked list look like
And then, uhh, the standard template library container classes usually will have a forward iterator, a backward iterator, a bidirectional iterator... ...so you can go forward and backward... and const versions of each. Which means, you can look at your data but you cannot change your data, okay? Any questions about all of that? Your world changed today, huh? You did know these existed. Okay. How do you think we achieve this reverse iterator? Going backward through the list... minus minus It overloads minus minus Alright, any questions about it? You doing good? Okay? Alright. So let's talk... oh... lets go... lets move... so, here's the thing. Here's what I want from you. I want you to leave this room and feel confident using iterators. Like, ughh, I need an iterator for this, and get the right google search and find the appropriate iterator to write code that traverses any kind of container class. That's what I want from you. But I also... if your employer or your advisor ever says, I need somebody to implement a new iterator," I want you to be the one to go "Oh! I'll do that!" So we are going to pull back the hood a little bit and look and speculate about how exactly these things are implemented, okay, so that you see what kind of decisions you would have to make if you were actually to do an implementation. Am I in the way? I'm not in the way, right? Okay. Alright, so, ummm, we agree... we agree, I think, that we're going to need, for... if say a linked list was the thing being encapsulated... we would need some private member to keep track of where we were. To save the state inside the object of the class.  To keep track of the fact that your iterator is pointing to you know that one instead of any other one. Okay. And we are going to do that via some private member, that's what this PM... PM does not meet message me... it means private member. Okay, it doesn't mean afternoon either. It doesn't mean nap-time. No yawning. Alright, so if you're a linked list and you wanted to say keep track of where you were, what kind of thing would you do? What kind of thing would you keep track of if you were trying to keep track of where you were in a linked list? Curr pointer, good. So in a linked list, you'd have a listnode pointer. You might call it curr. And it would just sit there until somebody did this plus plus. Now, if somebody said plus plus to an iterator, what would happen to that curr? Yeah? Yeah, good. So plus plus is implemented like curr = curr->next. Okay. And how would you look at the value inside? How would you dereference? How would you look at the value inside that pointer? You'd look at curr's... what did we call it? Data. We called it curr's data. So you would return curr->data. And look, you have just implemented... you have almost implemented an iterator for a linked list class. Okay, what would a reverse iterator... what would a reverse iterator for a singly linked list look like?
Oh. Going backwards you'd have to come forward and find the next one by coming through the forward. Okay fine.  What if your encapsulating an array? You're iterator helps you step through an array. How would you keep track of where you were? Just an integer right? An integer index. I'll call it k. How do you move forward? You increment it and lets pretend your array was named 'a' How would you get your data out? Your overloaded operator would return a k right? What if your.. Oh boy. What if your memory were arranged like this. Into some hyper cube. These are still the questions you'd have to ask. You'd say okay. How do I keep track of state? How do I determine what the next one is? How is my data represented inside? Those are the exact same questions you would have to answer in designing this thing. Alright any questions? You good? Okay! We already talked about a lot of this, but we're gonna go through it again so that you have it all in one place. I have made a list out of the things that you need to implement an iterator. I have made a list of the things that you need to implement an iterator. And I wanna remind myself what do they return here? Here's what I want to know. Where does the iterator class go? You remember? Where am I going to define there is gonna be this class iterator. Where does it go? Public or private? Yeah everybody agree? I heard public is that true? Yes! Because in fact we are writing it for the client to use. That's the whole point! So... class iterator is going to be an inner class. We call it an inner class to in the public section. Kinda like list nodes but not private. We may also have list nodes here who knows. Okay. Where are begin and end defined and what is their return type? They are public.  Begin has no parameters. What does it return? It returns something of type iterator. That's right! Where a re these operator++ and Operator* overloaded? Inside the iterator class and are they public or private? Public good! Public inside here you have operator ++ and operator * etc. And where is the private member associated with the iterator? Where is the private member that helps you keep track of where you are? Oh it's private. Duh. Inside what class? Think you keep it here. Yeah. Right? You wanna keep track of where you are in whatever is defined in this structure. So you got a list like this. Like this and you got something that you're gonna keep track of one of those. Might as well store it there. Yeah? No. It's an inner class. This is an inner class. Alright. Yes?
The representation of what?  So this has to be in order to keep track of this, you have to do it in terms of the way the data structure is defined, right? Like, its pointers if it's a pointer based structure. Integers if it's an integer based structure, etc. Does that make sense? Yeah?  No, you can have many iterators at a time.  You'd have different ones for different iterators You'd have different...   So the client doesn't know that They don't know what you're doing Right? They only know  What you're referring to by your individual one so you'd have This would be cur forward iterator You'd have cur backward iterator Cur  Yeah, I see what you're saying. I get it. Lemme think about it, ok? I'm not gonna be able to able to do it this way. But I think you may be right. About, about what you're worried about. But lemme think about it, ok?
[Pre-lecture]  Alright lets get started. Sorry about that. I have a couple announcements in addition to the mp4 announcement. A couple days ago you should have received an email from me about Class Transcribe and I want to tell you a little bit about it. So wouldn't it be nice if the lecture videos were searchable, yes. Wouldn't it be nice so you could just enter search term and have it find for you a list of videos where say I talk about pointers or whatever you would like. Well we can do that if you guys will work together to do so. So a few students have created a system whereby we can crowdsource video transcriptions. and the deal is that for any one person video transcription is an overwhelming task. But if all of us, if each of us contributes to getting this done then the burden is not to extreme on any one person. In fact, in fact, if each of you give 15 to 20 minutes to this task then we will actually have triple, we'll have fault tolerant transcriptions. So we'll have three different English translations, captions of all the lecture videos. So, I would like for you, we would all benefit from you going back to my email, the mass mail. Clicking on the links, signing up for task, doing a task. Once the videos are approximately half covered then they will open it up for search. So you have to get a few of them done before it is worth while actually providing them for search. Lets see, any questions about it. [Silence]
So the organizers of this, say that I need to incentivize this. Now we go, Notice how we held that off until the very end.  What I'm thinking is that it's 20 minutes of your time right?  I'm thinking about this on-the-fly, just so you know. I don't know I'm thinking about a point of extra credit. If you actually do it, one point towards your grade. No, don't even negotiate with me. Alright, We’ll let you know what the actual incentive is, we probably will send you an email on how to do this and I'll let you know what the incentive is other than the goodwill of the community, come on!  All right so class transcribe is one announcement and the other announcement is that the honors class is going to start on October 20th. If you have not yet registered for it and think you would like to do so, we’ll help you do the late add form. Post on Piazza for more instructions on how to register for the honors course.  Okay and that's all I have for announcements. I would like to remind you where we were last time.  We had basically gone through this code and we had become fluent users of iterators, yes? And we had talked a little bit about how they might be implemented we didn't implement our own but we talked a little bit about how they might be implemented.  So that should anyone ever ask you to do so, you know kind of where to start with the process. Well I have some code for you to look at today that's sort of starts right here it comes after this it employs some of the concepts that you have used and it's probably different than anything you've seen before. So I have this function up here, it's a templated function, and what I want you to do is to write a short description of this function.  Now when I say, “Write a short description” it means I want to know it's name, Its inputs and outputs, this function has no return type anyway, and then a very short one sentence description of what the function does, it's almost like you're writing the comment for this function. So take a couple minutes, untangle the template, and see if you can figure out what it does and once you write that sentence, I want you to describe to yourself what printer is, you might want to write it down as well. Would anybody like to come write their response on my tablet up here, it's not wireless today. Its not wireless today. You want to come?  Would you come if I incentivized it?  Anybody want my pen? You can have my pen but not my tablet. No way? What if I threw it?  It would be helpful if you put some errors in there. Like miss spellings or things like that.  The rest of you could do it too because most of you have pencils I think. [Wait for student to finish writing on the tablet]
So, the organizers, the organizers of it, hold on, the organizers of this say that I need to incentivize it. Now, we go, yeah yeah, noticed how I kinda held that off for the very end. And so what I'm thinking is that you know it's twenty minutes of your time, right? And normally I'm thinking about this on a fly, just so you know. Uh, I don't know, I'm thinking like a point of credit. You actually do it, one point towards your grade. We can, no, don't even negotiate with me. [Crowd laughing] Alright, we'll let you know what the incentive is. I'll probably send another e-mail to remind you how to do this and. I'll let you know what the incentive is other than the good will of the community, come on! God! Alright. So class transcribe is one announcement. Um Oh, see this is gonna be bad today. Hmm, traffic fixed. Okay. My wireless thing isn't working so... The other announcement is that the honors class is going to start October 20th. And if you not yet registered for it and you think you would like to do so, we'll help you do the late add form, okay? Um... Yea, you'll have to contact us to, actually post it to the Piazza asking for instructions on how to do that. Okay!  And that's all I have for announcements. I wanna remind you where we were last time. We had basically gone through this code and we had become a fluent users of iterators, yes? And, and, we talked a little bit about how they might be implemented. We didn't implement our own, but we talked a little bit about, we reasoned about how they might be implemented. So that should anybody ever ask you to do so, you know kind of where to start with the process, okay? Well, I have some codes for you to look at today. That sort of, you know, starts right here. It comes after this. It employs some of the concepts that you've used and well but it's probably different than anything you've seen before. Okay? So, I have this function up here. It's a templated function. And what I want you to do is to write a short description of this function. Now when I say write a short description, it means I wanna know its name, its inputs and outputs, this one has no return type anyway. And then, a very short one sentence description of what the function does. It's almost like you are writing the comment for this function. So take a couple minutes, untangle the template, and see if you can figure out what it does. And once you write that sentence, I want you to describe to yourself what printer is. You might wanna write it down as well. And then, oh I can't hand off my, oh would anybody like to come write their response on my tablet up here? It's not wireless today. You wanna come? Would you have if I incentivized it? [Laughter] Anybody want my pen? You can't have my tablet but you can have my pen. Anybody want it? No way? What if I threw it? [Crowd making sound] Did you want it? You are looking at me. Okay, did you want it? Thank you! No, in fact, it would be helpful if you put some errors in there. Like, misspellings, you know, things like that. Okay, the rest of you can do it though, cause you mostly have pencils, I think. [Silence]
You're late. This is mean to put the hand up in front isn't it? hahaha. Uh oh. OH. Ok. Ok excellent, any questions for him. I will facilitate discussion. Any questions for him? alright. thank you very much. yeah. *claps* that is the cheapest applause you're ever gonna get. ok alright fine, um did anybody have any other speculation on what this function does or any other description they'd like to add to it? so what i want to know next is what what is printer? what is printer? now yeah? it's a functor what the heck is that that's a new word. that's a new word, he said its a functor, i just wanna say it a few times because its so fun to say. try it. functor. that's right. good. ok. in fact that's correct, in fact that's correct, ok. now. but, there's a little bit of ambiguity but i asked the question for a reason. what is printer look like in a the middle of the function there? what is it look like, it looks like a function right? it is applied to some parameters right? with parenthesis so it looks like a function but where did it come from. it came in as an object, it came in as a parameter to the function so in fact, printer is what we call a function object. AKA say it, thank you. also known as a functor ok? alright any questions about that. alright fine well all of that is quite abstract, right? all of it is quite abstract so lets make it a little bit more in the context of this function, so lets make it a bit more concrete. the question is how do we make a functor? what is a functor? well take a look at this code right here, take a look at this code what does it do? overloads the parentheses operator, very good and that's it. that's all it does. it overloads the parentheses operator to do a little tricky function, a little cute function, ok? fine. now but it's a class so we can declare something of that type so the first thing i want you to do is remember the previous example declare something of type animal. anybody want to come up here and do this on my tablet for me? ok how about verbally tell me what to do. how do i declare something of type animal? you remember ? from last time. you know the struct is behind here, you can almost see, oh look look look, right here, you can see it. k? alright who wants to do this, raise your hand. somebody raise their hand, ok close your eyes and raise your hand. close your eyes and now raise your hand. chickens, you bunch of chickens. animals c is a chicken and if you remember its a big chicken that eats you. you right k. ok! so i declared an animal, now printigbig is a class, which means i can declare something of that type right? yes? right i can cover over all of this and it says class printifbig, it's not templatized or anything so i can say, printifbig 
emm, what's we call it frog hey cause is doesn't matter ok, just a variable, now frog is a type printiIfBig now using your answer for one and two invoke some member function of the printIfBig class  will what member function do we have only the overloaded operators so how does it work, oh I know just tell you go frog.operator() para parameters the c, so I will put one parameters so i will put c in there yeah, how do we invoked member function right ohhhh that is exactly equivalent to saying frog of c ok, that's how that overloaded principle operator look ok, any question about that, you good? so now, now what we can do is  we can do clear this functor, this functional object passing around in two functions, right, like we did a of there ok any question about it so far, you good? so ok, yeah? aha yeah so the question is why do I choice more intelligent names for the type parameter and templet statement and the answer is because I what to give you a hint as to what they do what kind of thing yes  but it could be told, could be tea, could be icecream, etc no, iter is not the key word ok, but it is carefully choosing to give you kind of glimpse to how we were going to use it right, like iter is a short for...indeed, is there another word start with iter" iter internet, not internet is how you see of code internet ok, interrupt it even funny, alright, fine your next task, your next task is to decode this, ok so take a couple minutes, you will want draw some circle on you page, decode, figure out what's going on  here oh yeah you can touch the screen while you are working
What should we call it  frog because it doest matter okay just a variable now frog is of type printifibig now using your answers for one and two invoke some member function of the printifbig class. well what member function do we have.  only the overloadded operators so how does that work oh i know just how you go frog.operator() and that takes one parmater so i am goiing to put c in there  thats how we invoke member functions right oooooohhhh ooooohhhhh that is exactly equivalent to saying frog(c); thats how that overloadded parthensis operator works  any questions so now what we can do is declare these functors, these function objects and pass them around into functions like we did up there alright any questions the question is why did i chose more intelligent names for the type paramters in the template statment and the answer is because i wanted to give you a hint as to what they do it could be t it could be ice cream with no space iter is not a keyword but it is carefully chose to give you kind of a glimpde into how we are oging to use it. like iter as in short for iterate alright fine.  your next task your next task is to decode this Take a couple minutes. draw some circles on your page  decode, figure out whats going on here  -nothing-  turns out you cant touch the touch screen while youre working 
Hi! What's going on? Yeah? Yeaaaaaah. Very good! So the output of this is to print only the animals in the zoo that are big So from the example of the last time that would be  the giraffe and the bear giraffe and the bear Penguin will no be printing Ok. So should we untangle it? Alright, so, print big Oh wrong pen printIfBig is called myFun so the name of the function that we're gonna pass around is called myFun Last time it was Frog, but here we're gonna use myFun as my fuctor Ok. Then we're gonna call, simply call function print, okay? so that the top function of their Now what does print mean? It means two types and three parameters Two types and three parameters Here are the two types, oh It's an animal iterator and a type of the functor okay? And now I need three parameters What is the first parameter? Oh, it better be of this tupe and the intention is that the processes going to go from one to the other so it make sense that we are gonna walk forward through the zoo. so make sence that we would choose zoo begin, which is just a member function of the zoo class that returns an iterator one of these right? something of that type zoo end, and then whatever i called that fuction name for that function ok! so what does it do? it applies this function to every element of the zoo between these two iterators. and print it out if it is big here, ok? any question about that? yes? oh, so we are printing out the very last element, because it's going to go while the first is not equal to the second so it's gonna keep going until it becomes the same as the second. ok? and then oh, end is one pass for last end is one passable last from that time, that's the key point there. ok any other questions either question about this? ok, so, you know i am not as eduminded probably as you are but i will tell you how i respond to this and maybe, maybe you will be a little born mentally flexable every time I don't have a mechanism for remembering exactly how this goes every time. i had to think very hard and very carefully about how to set this up but what's important is that you know it can be done. that is you know you can define a function that you can pass around and apply to members of the container. ok, that's what is important tha you know, ok? and untangling exactly how to do that every time is a matter of practice you had to do that everyday you realize that oh yeah all you gotta do is declear a couple of iterators .etc
Alright, so whats going on yeah? yeahhhh, very good, so the output of this, is to print only those animals in the zoo that are big alright? So from the example of last time that would be the giraffe and the bear ok, the giraffe and the bear and the penguin will not be printed Ok! Ok, so should we untangle it? Alright, so, printifbig (Oh, wrong pen), printifbig is called myFun So the name of the function we gonna pass around is called myFun Last time it was frog but here we gonna use myFun As in my functor Ok, then I'm gonna call, simply call funtion print Ok, so that's the top function up there Now what does print needs? It needs two types and three parameters Two types and threeparameters Here are the two types Ohhhh, it's an animal list iterator And the type of the functor Ok? and now it needs three parameters, what is the first parameter? Oh it better be of this tupe and the intention is that the processes going to go from one to the other So it make sence that we are gonna walk forward through the zoo. So make sence that we would choose zoo begin, which is just a member function of the zoo class that returns an iterator One of these Right? Something of that type Zoo end, and then whatever I called that fuction Name for that fuction. Ok! So what does it do?  It applies this function to every element of the zoo between these two iterators. And print it out if it is big Ok? Any question about that? Yes? Oh, so we are printing out the very last element, because it's going to go while the first is not equal to the second So it's gonna keep going until it becomes the same as the second.  Ok? and then Oh, end is one pass for last End is one passable last from that time, that's the key point there. Ok any other questions Either question about this? Ok, so, you know I am not as eduminded probably as you are but I will tell you how I respond to this And maybe, maybe you will be a little born mentally flexable Every time I dont have a mechanism for remembering exactly how this goes every time. I had to think very hard and very carefully about how to set this up But what's important is that you know it can be done. That is you know you can define a function that you can pass around and apply to members of the container. Ok, that's what is important tha you know, Ok?  And untangling exactly how to do that every time is a matter of practice You had to do that everyday you realize that Oh yeah all you gotta do is declear a couple of iterators .etc
sure yeah we can pass something different here if we had a different thing. yes yes ok? yes.  so the question is can you do more than one function with a functor? so you can imagine class functors. and the problem with that is i only know how to overload  parenthesis one time and that ended depends on that function. so the thing is that what you probably can do and I haven't tested this we are in open water here for me what you probably can do is have a different one with a different parameter here yes yes I am pretty sure you can do that. you can overload operator parenthesis with different parameterization. in the same class pretty sure that will works I don't see why it wouldn't ok yes steven?  complie well I will throw back at you if it can't find that function it will say: yo you didn't define the function so that the compiler will tell you that ok any other questions about this?  oh the question is: the question is a really good one  do you only overload the parenthesis operator or can you have other stuff too?  can you answer that? based on your experience on this class?  yeah you can certainly you can probably do anything  but based on the  experience on this class I assert that you actually has used a class of this type   where was it? right. so it 's actually the PNG class right？ yeah the PNG class has its parenthesis overloaded and it is the function that will look up that that position in the table yes?   right tell me where it is to stop. right here?  a value? so if it is a value  up here. so I am not ganna say no because maybe I have maybe I am imagining something different than you  but what has to be true up there its has to be completely generic there can be no expectation of any particular type. but it could be something of you could parameterize it to be something of type animal  in the template and pass one of those an element of  and then stop when you find so that will be like a find right? find an elephant for example  oh you can to change that code completely instead of comparing first and second would have to be compare the value of first with whatever the second parameter was so you can do what you are talking about different funcionality but its fine thats a nice little adaption of it  sure inside here  sure like the PNG class has a lots methods right for example and an overloaded parenthesis operator
sure yeah we can pass something different here if we had a different thing. Yes, yes yes ok? Yes? Em, so the care so the question is can you do more than one function with a functor? so you can imagine class functors. and the problem with that is i only know how to overload parenthesis one time and that ended depends on that function. so the thing is that what you probably can do and i haven't tested this we are in open water here for me Em, what you probably can do is have a different one with a different parameter here yes yes i am pretty sure you can do that. you can overload operator parenthesis with different parameterization. in the same class pretty sure that will works i don't see why it wouldn't Ok yes Steven? complie well i will throw back at you if it can't find that function it will say: yo you didn't define the function so that the compiler will tell you that ok? Alright, any other questions about this? Yeah? oh so the question is, the question is a really good one, ok? Em, can, do you only overload the parenthesis operator or can you have other stuff too? can you answer that? based on your experience on this class? yeah you can certainly you can probably do anything but based on the experience on this class i assert that you actually has used a class of this type where was it? Yeah? What? right. so it 's actually the png class right? yeah the png class has its parenthesis overloaded and it is the function that will look up that that position in the table, ok? Yes? Right Tell me where it is to stop. Right here? and a, and a value? so if it is a value up here so i am not ganna say no because maybe i have maybe i am imagining something different than you but what has to be true up there its has to be completely generic there can be no expectation of any particular type. Ok? but it could be something of you could parameterize it to be something of type animal in the template and pass one of those an element of and then stop when you find so that will be like a find right? find an elephant for example oh you can to change that code completely instead of comparing first and second would have to be compare the value of first with whatever the second parameter was Ok so yes, you can do what you are talking about different funcionality but it's fine thats a nice little adaption of it Yes Sure! inside here? sure Sure, like the png class has a lots methods right? for example and an overloaded parenthesis operator
And you can even save state, you can even save data associated with it if you want.   Alright, we need to kind of keep going because this is the end- this is the last I'm going to say about C++ specifically. So this is our last moment of talking about C++.   I threw it in here after linear structures so that we would have talked about lists in a lot of detail before we did this lecture.  And so, we're moving into data structures proper.   This is the data structures portion of the course.   And it makes me excited!!  Alright, we're going to start with trees.   Donald Knuth says it's the most important nonlinear structure in computer science."   DUN DUN DUNNN!   Okay, so I have drawn you a picture of a tree here.    If you notice a tree is simply a collection of vertices and edges, but it's a special collection of vertices and edges And I want you to meditate for a second and then remember a way of characterizing trees from CS173 Okay so think back to your discrete math experience I know there are lots of different ways of characterizing trees, but I'm looking for one in particular  Bye Tim, I'm sorry I hope you feel better Alright, so I'm looking for one particular way of characterizing trees.  So think back, what was the definition of a tree from CS173 A definition From your discrete math experience I love this because, you know, there's this word on the street, this meme that says ohh you don't need 173 for 225"  Like oh yeah? This moment right here. Hey, characterize a tree for me.  What would I do if nobody- yeah? [Student speaking] An undirected graph with no loops Okay good So, we're going to go with the undirected part as a given So I forgot to actually say that. So yes, we're going to start with an undirected graph. I'm going to reinterpret the no loops part I'm going to reinterpret the no loops part to say that it's acyclic  So a tree is an undirected graph. We'll usually assume undirected here.  That is acyclic and there's another key word Is every acyclic graph a tree? What other characteristics must it have? What, who's talking to me?[Student speaking]  Connected, that's right So, a tree is a connected acyclic graph Any question about that? Alright, there it is Here's an example of one Now, this is a little bit premature.  We're not actually going to study general trees yet Later we will, but we're not going to study general trees yet. Rather, we're going to further specify the kind of trees we're going to talk about first. To do so, we're going to pull out a special node, and call it the root. And the trees we're going to study are rooted trees Furthermore, we're going to make it so that every path from the root is a directed path So these are rooted, directed trees The directed path away from the root And furthermore, we are going to differentiate our trees based on order That is if I redraw this tree so that it looks like this 4, and then 1, 2, 3, 5, 6 If I draw this tree like this 1, 2, 3, 5, 6,  That tree is different than this tree 4, 1, 3, 2, 5, 6 So it's rooted, directed, ordered
And I don't know how to draw attention to the fact that I  switch this. Now by convention, we are always going to draw these trees hierarchically. We wouldn't have to. right? Like we could draw like this and  say oh you know there you started  travel clock in their orders determined by a uh...clockwise rotation around the root.  But we are not getting to do that. We are always going to draw them with the root at the top. As backwards. The root at the top. And we won't draw these arrows either, because they are always directed away from the root. So we won't actually draw them in most of the pictures.  Ok. Any questions about all that? Ok. So today is not tree day, it's actually rooted directed ordered tree day.  Ok? All right. Any questions? You good?  Alright. So here's the problem.  A classic course in a discrete data structure would spend a whole day on definitions. And I can't do that because it will put you to sleep. You will be asleep at the end of it. So what I'm gonna do instead is ask you to infer and to create your own definitions in your brains  probably review should be reviewed at this point. Of all of these terms, based on the...based on this example tree,  right here, and I wanna point out as you answer these questions that the first two intend for this not be interpreted as a rooted tree.  And then the rest of them do intend for this to be interpreted as a rooted tree. So the first two, no root no direction nothing special, uh but then the rest of the exercises assume tree as rooted. OK? Alright, and directed, and ordered. Ok, any questions about all that?  So spend a few minutes doing these questions, uh, I think you can use about three minutes for this. Go fast.  And you can do in pairs. You can do it socially if you like.  Anybody wanna come up here and do them? Here? I want a pair of people like a commonly routine. Like a...like the oscars, right?  The academy awards to people could come up and share. All right. What's the longest English word you can make using the vertex labels in the tree? What?  Alphabets? No. There is no F. Oh wait there is an F. There is no P, H.  No. No just use the vertex labels and make a word. Like I could make high", h-i-g-h, right? I could make high" like "high", but I could also make h-i-g-h as an example, ok? Sure. Because I'm allowing for re.... It doesn't have to follow any connectivity, just using the vertex labels. Ok? Yeah, it doesn't have to.......That's the longest word you could make, could those letters? Yeah? Yeah. So wait! So read the question carefully. It says, using the vertex labels in the tree.  Ok? It doesn't say that you have to honor the connectivity.  Ok? I don't care where you walk around on this structure. It's fine. Just use these labels and come up with the long word. Or not. 
Anybody have longer than baggage? Oh, haha. Alright, fine. Debaggaged. Ohhhhhh. Now there's no 'R'. Okay. Alright, the only lesson we need is to read the questions carefully And make sure, you know, what's being asked at all, you know. Not being entirely here, so, fair, fair point Find an edge that is not on the longest path in the tree. Now we are talking about connectivity. Now we care a path is defined on edges that exists. So what's an edge not on the longest path in the tree. And I understand that's not unique, but the edge is unique. What edge? Yah. A to B, very good. How should I write that? How should I represent this edge? So I can draw very easily right?  Oh look, here's the edge. How should I label it? What's a good name for that edge? AB right? There's a lots of way to do this, I'm going to do this right now. OK? Since it's undirected. Since it's graphic is undirected, I'm going to say that that is equivalent to edge BA. Alright, for the rest of the exercises, assume the tree is really one of the vertices is called the root. Guess which one is this? Everybody say it? Good. Make an English word containing the names of vertices that have a parent but no sibling, or brother. Well the words are those. So B, G, H. Think of word that have those three letters. Huggable. Okay. Yah, containing, here we go.  How many parents does each vertex have? One except for (root), okay. And I pointed that out because programmatically, it has implications. Right? It makes special case in that respect.  If you're writing code that refers to its parent. It makes a special case of the root only in this structure. Right? Alright, which vertex has the fewest children it's a tie between E, F, I, J. So I'm going to make a little set of them. Which vertex has the most ancestors? I and J, it's tie. Good.  Which vertex has the most descendants? That will always be the root of the rooted structure. List all the vertices in b's left subtree. So there's a lot of vocabulary there, and when we talk about left, we referring to the conventional notion of left, okay? It means, this, it's not as b adds a standing on b's left, okay. Very confusing. It's b's left as you're looking at B. So all vertices in b's left subtree, E, C, F, in no particular order. All the leaves we're asking about that set again, E, F, I, J. Okay. any questions about it? Good? No surprises? Yah What's the longest path? It's the path with the most edges on it. Path link? Okay I'm not going to say this now. I'll so more formally later. Path link is determine by how far you walk, if you're walking on a graph. Which means the number of steps you take, or the number of edges that you traverse. So path link is the number of edges, not the number of vertices. Okay? Alright, any questions about any of this? Alright, let's keep going here. Oh good we got time. This is my favorite tree. It's my favorite tree. No it's not Pokemon. Pokemon would be a good one too. Can you tell what it is? Mario
Yeah, so these are the, these are all the Mario Games.  I said, I describe this as the Mario family tree, but it isn't really that. It's family is not that big, but there are, this is the set of games as of 2007, so I actually don't know what happen after 2007. But I'll bet you can tell me what this is. You know what this is? Super Galaxy I believe. Mario Galaxy. Sorry, I am not actually as well birth as I am pretending to be here, OK. Not as cool as that. Amm..  but here is why, here is why I love this tree. This is why I love, so first of all, raise your hand if in your household you have had one of the games on this chart. OK, or you have played it. Or, yes, so I am thinking 90%. Tell me what this game is. All the way to top No, you can't read it, it's Donkey Kong. And Donkey Kong like was That's from my childhood, right? So this thing here connects us in a very unexpected way, right? Like it's one of very few things that like spends the ages and, so I love this cuz it connects me to you. I also love it because Donkey Kong itself is the substance of a painfully fantastic movie called 'KING OF KONG'.  Did you not.. 8.4 user rating I think? I'm not sure. Maybe only 8.2, but 'Fistful of Quarters' is the subtitle. 'King of Kong' is a documentary about professional 'Donkey Kong' players. And..  and.. I say it's painfully fantastic because we know people like this. We might even be some of us probably, people like this. So anyway, that's my recommendation for Friday night. Am.. maybe we should screen it in Siebel. I'm not sure. Or here, we can screen it here to get permission. Alright, anyway what I really wanna know is, what I really wanna know is if you were making this into an application  into an application on an iPhone Apple whatever, that is if you were allowing for electronic navigation and manipulation how would you configure memory, so as to ah.. how would you configure memory that is what structures would you use, how would you do this so as to store all of this things. What would you do? If this is a tree, probably worth figuring out where are the vertices cease and where are the edges. Where are the vertices cease? The, the games themselves, right? And where are the edges? Yeah, so I think that instead of you know, instead of these edges that they are actually drawn, maybe what is really going on here is like is. You know that this is a sub-structure that would be meaningful to us. OK. So know what I'm asking you is what does the node look like? What does a node in this structure look like? What does a game look like? Is the same question, right? Games are nodes, what does it look like? What information does it have?
Yeah, so there are all the Mario games.  I describe this as the Mario family tree, but it isn't really that.  It's family is not that big, but this is the set of games as of 2007.  So I actually don't know what happened after 2007, but I will bet you can tell me what this is.  You know what this is? Super galaxy I believe. Mario galaxy, sorry. I'm not actually as well birthed as I'm pretending to be here, okey?  Not as cool as that. But, here is why I love this tree.  So first of all, raise your hand if in your household, you have had one of the games on this chart.  Okey, or you have played it, or... yeah.  So, I'm thinking 90%.  Tell me what this game is. All way to top. No, you can't read it, it's donkey con.  And, donkey com, like was that's for my childhood, right?  So this thing here connects us in a very unexpected way, right?  Like it's one of very few things that like spends the ages.  So I love this cause it connects me to you.  I also love it because donkey com itself is the substance of a painfully fantastic movie called King of com".  Did you node? 8.4 user rating I think, I'm not sure. Maybe only 8.2, but.  A fistful of quarters is the subtitle.  King of Kong is a documentary about professional donkey kong players.  And, I say it's painfully fantastic because we know people like this.  We might even be, some of us proudly people like this.  So, so anyway, that's my recommendation for Friday night. Maybe we should screen it in Siebel, or here. We could screen it here, to get permission.  Alright, anyway, what I really know is, what I really know is, if you were making this into an applicaiton, undefined Into an application on iPhone or Apple whatever.  That is if you were allowing for electronic navigation and manipulation, how would you configure memory?  So as to eh... How would you configure memory that is what structure would you use.  How would you do this so as to store all of these things?  What would you do?  If this is the tree, probably were figuring out where are the vertexes and where are the edges.  What are the vertexes?  The games themselves, right? And where are the edges?  Yeah, so I think that instead of, you know serves there edges as they are actually draw, maybe what is really going on here is like this.  You know, that this is the substructure that will be meaningful to us.  Okey, so now what I'm asking you is, what is the node look like?  What does a node in this structure look like? What does game look like?  It's the same question, right? Games are node, what does it look like? What information does it have? 
Ya, so these are all the Mario games. I said I described this as the Mario family tree but this isn't really that. Family is not that big. But there are... this is the set of games as 2007 so I actually do not know what happened after 2007 But all that you can tell me what this is. You know what this is? Super Galaxy I believe. Mario Galaxy, sorry. I am not actually as well versed as I am pretending to be here, OK? Not as cool as that. But, here is why I love this tree. First of all, raise your hand if in your household you have one of these games on this tree. I am thinking of ninety percent? Tell me what this game is. All the way of the top, no you can not read it. It is donkey kong.  And donkey kong like was from my childhood, right? So this thing here connects us in a very unexpected way. Right? Like it's one of very few things that like spends the ages so I love this cause it connects me to you. I also love this because donkey kong itself is the substance of a painfully fantastic movie. Called king of kong. Did you know 8.4 user rating I think I am not sure. May be only 8.2. But it is full of quarters. It is this subtitle, king of kong. It is a documentary about professional donkey kong clears. And I say it is painfully fantastic because we know people like this. We might even be. Some of us probably are people like this. So anyway, that is my recommendation for Friday night.  Maybe we should skirmish in Siebel or here. We could skirmish here to get permission. All right. Anyway what I really want to know is if you were making this into an application.  An application, an iphone app or whatever. That is pure allowing for electronic navigation and manipulation. How would you configure memory? So as to... How would you configure memory that is what structures would you use, how would you do this?  So as to store all of the things, what would you do? If this is a tree, probably worth figuring out where are the vertexes and where are the edges. Where are the vertexes? The games themselves right? And where are the edges? Yeah, so I think that instead of insert these edges that they are actually drawn. Maybe what is really going on here is like this. You know this is the substructure that would be meaningful to us. So now what I am asking you is that what is the node look like?  What does a node in this structure look like? What does the game look like? It is the same question, right? Games are nodes. What does it look like? What information does it have?
it needs a name it needs a picture what else? it needs.... it's.... it's children right? How are we going to store it's children? inside it and an array maybe. right? maybe an array? this question this design moment is relevant and but yet just a little beyond us at this second because it's not really true that what we're going to study is rooted, directed, ordered trees rather we're going to study rooted, directed, ordered, binary trees so rooted, directed, ordered, binary trees what is binary mean? aka binary trees and i'm not gonna say the rooted, directed, ordered part ever again i'll just refer to binary trees so what does that mean? it means that every node doesn't have a million children like the mario structure did but rather has only two and they are specified as left and right we specify them and refer to them as left child and right child ok any questions about that so far? so we will start on friday  maddox are you listening? we will start on friday with a recursive definition of a binary tree
binary trees
everything else has a child, so 18 has one child, 20 has two children 20 is called the root node it is the only node in the tree that has no parent so everything has one... every node has exactly one parent now, a little bit trivia there will be, if there are 4 pieces of data in the tree there will be 5 null pointers if you think that through like you have one piece of data you have two null pointers you have two pieces of data you'll have 3 null pointers because one of the one of the null pointers gets used up to point to the other thing, the new thing you add adds two, right so you're always leaving one null and adding two new ones every time you add so here we have 1, 2, 3, 4 , 5 for the 4 pieces of data the other thing that's really interesting all the leaf nodes you take them all together that's called the fronteir of the tree in a binary tree, half of your data is gonna be in there so you can imagine if you wanna do something to this tree you have a pointer to this you're gonna have to descend down, go looking around to find your data half of it is gonna be as far away as possible as it can get from the orot which is not very far, usually but that's something to think about now try to imagine in your mind how you're gonna implement this thing you're at the console, you've opened up vim, cursor's blinking at you, what are you gonna type? try to imagine that, you can look at your handouts i printed something there i shouldn't have done that, okay a little typo that should be class <T> but the slides are very forgiving compilers in that they don't complain if there's an error so this is just a standard we have a wrapper class i'm gonna call binaryTree today and then inside that wrapper class is gonna be the node which actually contains the data so the wrapper class handles things like maybe keeping track of the size, it needs to keep the root pointer so it knows where to enter the data structure and then the node class is where all these all these pretty diagrams come from so how's this looking for you guys? do you like this? it's making sense? alright now this is a recursive data structure, so almost every function you write on these things is going to be recursive you could use a for loop or a while loop but it's actually not as natural uh, how do you guys feel about recursion? how many of you think you know it'd be nice if you reviewed that just a little bit before moving on?" yeah? alright i mean like no way man i'm sick of recursion" well really, the only thing you have to do to know recursion is to understand recursion alright well let's talk about it i actually want to draw a recursion i know cinda's talked about it i wanna talk about it again because recursion is the second most powerful concept in all of computer science abstraction if you know abstraction, you know recursion, you are a computer scientist so you don't even need a computer hahahahaha it helps but you don't really need one alright, so i wanna talk about proof by induction how many of you are familiar with proof by induction, how many of you feel like yeah i got proof by induction and i'm okay with it"? how many of you feel like ehh" i hope it's not on the test alright so proof by induction, this is the wonderful thing about computer science we have turned being lazy into an art form and we've tricked people into paying us dearly for it so here's how it works, proof by induction we have a property, i'm going to call it P(n) so some property P we just give it a name cause i don't wanna think about a specific one right now n is some thing, maybe it's integers, maybe it's trees, doesnt matter uh, as long as you have some idea that there can be... if you have n you have some concept of what a smaller version of that n might look like, so for an integer, it's easy to make a smaller one, just subtract one right? for a tree you have this tree, how can you make a smaller tree? you go to the left or right side now you've got a smaller tree now this gonna turn out to be very important that you can do this the other thing you need is the idea that you have the smallest version of a tree, the smallest tree is a leaf or maybe null depending on how you're thinking about it, so what you do with induction is you say that for n=1 or whatever the smallest thing is, you prove that your property is true for that and that's usually really really easy, almost trivial, right? and the induction case, what you do is you want to prove p(n) now some places they'll say you wanna prove p(n+1), doesn't matter it turns out to be the same now you just assume that p(n-1) is true, you pretend that you have some grad student go off and do all the work for you, you come back with it and you take all their credit, okay? so uh, don't tell the grad student union i said that the uhh so what do you do with this? you use this fact to prove this fact you say if this is true then with a little bit more work, then you can prove that this is true also now here's the beauty of it, you did not pick a specific n
Therefore, it's like you prove all of them simultaneously. Now, this whole n minus one thing, the only reason this works is because you prove the base case. Now have you even those camping cups, where they kind of open up. They're like  inside of other rings. I don't know may not seen it. Or maybe set up a bunch of dominoes, you have to be able to knock the first one over. That's what the base case does for you. Now, let me go over a concrete example to illustrate this Now you may not have known this but if you take the first n odd numbers and add them all together, you actually get n squared. So next time youre at a party you can tell people this. They'll look at you the way they always do when you talk at parties Hey we're all geeks here, we're used to this. Right? You go to a party and say yeah, I'm studying CS yeah I;m learning all these theories and these data structures and they look at you I have this problem with my word processor you know? That's gonna be your life. Alright so, base case, n = 1 right? This just 1 all by itself, 1 squared is one, so Base case is true. Got it.  Now what you do is for the induction case, you want to show the P(n) is true but you assume that p of n minus one has already been proven true. What's p of n minus one, you take the n - 1 odd numbers and just assume that they're equal the minus 1 squared assume that that worked out, now what do we do? We add the nth odd number to both sides and theres this huge huge cloud of algebra and when the dust settles you got n squared that's how proof by incuction works is this making sense?  I'm not gonna make you reproduce this, but looking at this like okay I get what's going on are there any questions? there's a nice geometric proof odd this too if you take a square and you go down the south and east ends keep layering more squares you get a nice geometric proof too. Now the reason why im showing you induction is that recursion is actually the same thing. a recursive function is really just a computational proof by induction because what you have is just some input you have two cases, you have a base case, and you ahve a recursive case so when I teach I will often use recursive case and incuctive case interchangeably beacuse it's really the same thing right? so here's a cfunction that can computes n square it's not very efficient but it uses the same algorithm so this is the base case y is 0 this time if i should have wanted to set n = 1 and returns 1 but then when i return i take n square of n  -1 and just assume that it gives you the right answer, dont think about it too much and then what are you going to do with that? youre' gonna add the nth odd number to that and that gives you the recursive function the recursion and proof by induction are really the same thing now uhhhhh one thing about recursion that you need know that this is about CS culture. have you heard the story about the little kid who asks his  dad what's holding up the world. the dad says well it's an elephant. so the little kid goes away happy and the day later he's thinking about this and comes back and asks, dad what's holding up the elephant? A Hippopotamus. Oh okay kid goes away this time and hour passes. he comes back and goes so what's holding up the Hippopotamus? a turtle. come on dad whats holding up the turtle, he says son its turtles all the way down. okay if you forget this thing that check for the base case, you're gonna get turles all the way down youre gonna get an infinite loop and so you'll hear people talk about this. when they talk about recursions if a recursion goes or if you get an infinite loop or something like that youll hear someone say oh it's turtles all the way down. That's what they mean. That is where it is come from.  this is really just the same thing to say so what do i dofor my base case , what do i do for my recursion case, the only thing different is you have to tell the computer how to tell the difference so you have an if statement Hows this? is this good? is this helpful? If it's not well too bad sigh.... alright uhh I actually like recursion far far better than for loops and while loops uh they take a little bit of getting used to but once youre used to them they actually tend to be far more reliable and uh when you take cs421 with me I'll tell you all about that but alright lets see lets go on so here's what a recursive function on a tree will look like so the base case for a tree usually its a null you wanna know what happens if there is a null tree node coming at uh so youll do your base case here and the recursive case what will happen is you'll call two recursions one you go down the left side one you'll go down the right side and you'll take the data and youll do something to combine them all together and that's it, that's really all there is to it alright lets look at an example now try to think about how would you define the height of a tree?
You sitting down there's an exam and says ok, write a function that computes a tree. How would you do that? Go to web browser www.google.com? Better not do that on my exam. Alright yah.  Yeah. So it's longest path from root to the leaf. So to do this recursively, you're gonna have to think about ok, what's my base case?  Well if you get a NULL, that's a zero height tree. Now, what's your recursive case is gonna look like. You have a node that's not NULL, you go down the left side take its height, go down the rightside take its height.  What are you gonna do with that information? Come on, yell it. Yah compare them. And you're gonna take the biggest one right?  SO just take the max, and add one for the root that's your holding onto now, the nodes you're holding onto now and that's it. So, you return zero for the NULL, you take one plus max of the heights of the two children. How's that? Does this make sense to you everyone? Any questions?  You probably noticed by now, my lecture sounds very different than Cinda's. I like to do life codings, so if you have any questions or wanna see an example, we can just type it up and run it and see what happens. Ugh, so here move it down little more. So here's a tree, so 10 is the root, then 20 is one child then 15 and 25s. We want height.  Let's do this. Take this, paste it in. It's fun showing off. Come on. Actually I'm not gonna be very good at showing off. I haven't programmed the C++ since I was undergrad here. So I actually don't remember half of this stuff that we used to do. I don't even remember there's actually a max function. There it is, that's good. It'll look something like this. So, if we have something in here, we're just gonna return one plus max of the two things. Otherwise, we'll just return 0.  Let's see if it compiles. It compiled, that means it works, right? uhm... well, let's move on actually. Oh you want me to run it?  That said three, uhm... that's right this time. Looks like it worked. Let's hook it to the space shuttle. Alright now how about the sum of a tree? Pretty similar, right? Though, here it's NULL. That we'll wanna do for the NULL? No, you'll get a seg fault right? Null, you probably wanna return 0. Uhm.. Otherwise, you return a data + sum of the left and sum of the right.  Good so far. Alright, your turn. On your handout, there's this crazy function that asks you to write.  So here's what we'll do. Spend maybe 2,3 minutes. Don't feel like that you gotta get every bit of syntax just right, but try to figure how to do it in about two minutes three minutes, I'll say something and then turn to your neighbor, compare your solution. Then after that we'll talk.
 it said binary trees but really there functions are nodes i wil fixed that to  hows that going? yes? yes?  you wanna call some of your own funcion? sure  well so the idea is that you will call calc on the left subtree and the calc on the right subtree thats gonna give you a value and the way it ganna combine those is determined by the current node you have so if it say if it is a minus one you add them if it is minus two you multiply  so positive numbers should only come to leaves otherwise  you ganna chunk it a lot of data I mean really that what we are computing is that important. the whole idea is ok can you think recursively what we are doing that's the point  alright why not you turn to your neightbour and just outline what you had in mind I am not really looking for you to write down the full code and have it compiled or  the reason I do that is  it turns out if you actually expanded thoughts trained  work with this your brain figures out that its important it will keep the data longer. you just watching a lecture and nodding: oh yeah, thats cool! I got it!\ it turns out that after you leave 5 minutes later you know what happens its all gone right? you ever had the feeling that taking an exam that you took out every information out of your head you put it on the paper you give it back to the professor we try to avoid the situation here so I want you to turn to some one show them what you have in minds see if you agree
[Video Playing] Alright Let's talk about this, so we're gonna call this calc  [Video Playing] What's my code [Video Playing] Is there an else if? [Video Playing] Else space if alright fine [Video Playing] Alright so [Video Playing] n data is what? [Video Playing] You want to do the greater than equals zero? Ok [Video playing] And just return the data right? [Video Playing] What are we going to return now? [Video Playing] Never type something twice if you can avoid it Cut and paste and then modify it [Video Playing] Alright, lets see if this thing works now. [Video Playing] So we have this population. So this was a minus two,  this was a minus one This a two, this is a one, this a minus one this is a six and a eight [Video Playing] And so what we want to do is we populate, we calculate it's height and then we'll calc it [Video Playing]  Alright it said forty-two So the code's right even if the math might not be Let's bring that back up So any questions on this code? Does everyone get this? [Video Playing] Is there any other fun thing with a tree you might want to see recursively? Anyone want to see an example? [Video Playing] Don't worry tree functions will get a little more complicated later on What's gonna come next is something called a binary search tree Where there's a lot more constraints. Right now we just have these nodes and the top nodes connected to the bottom nodes So the recursions tend to be a little simple cause we don't have to worry, we're just traversing [Video Playing] Alright, last call. Any questions? [Video playing] Do you feel like you could write this now? Ok good  [Video playing] Alright, so there's one really interesting recursion Looks kinda like this You have three lines, you print the node and then you preorder the left, you preorder the right and you really should have an if in there to check if it's null but im just showing you the outline
[Waiting] Let's talk about this, so we are gonna call this calc() What's my code Is there a else if .... else [space] if alright So... in n->data is what.... You wanna do the >=0"? OK And just trying to return data, right? What are we gonna return now? Never type something twice if you can avoid it. Cut, paste and modify it Alright, let's see if this thing works now So we have this population... this is a -2, this is a -1 ...this is a 2, this is a 1... this is a -1, this is ..6 ...8 Then what we want to do is we populate, we calculate its height and we calc() it Alright it said 42 So the code it's right even if the math might not be So any questions on this code? Everyone get this? Or is there any other fun thing about a tree that you might want to do recursively; you'd like to see it in an example? Don't worry, tree functions will get a little more complicated later on What's gonna come next is Binary Search Tree Where there're lots more constrains Right now we just have these nodes, top nodes connected to the bottom nodes So recursion seems to be a little simple because we don't need to be worry, we just traversing  Last call, any questions? You feel like you can write this now? OK, good There's one really interesting recursion: kinda like this You have 3 lines, you print the node, then preoreder the left and preorder the right. You really should have put an if to check if it's NULL but I'm just showing the outline
What this is gonna do, is, it's gonna visit every single node in the tree but in a certain order.  It will look at the current node, it will print out it's data, and then it will visit everything on the left side, and visit everything on the right side. This is called a pre-order traversal, and it has an interesting property.  So, this particular node, how many times is this function going to be active, while this node...while it's thinking about this node. It actually will happen three times.  You'll come, you'll call this function on a node, and you'll say okay, print out this data", so it's one visit.  Then you’ll go down here, go down the left side, and do whatever, and then you’re going to return.  So that’s the second time this function has control over the node.  After that the function is going to call the right side, do all that recursion, that’s gonna return, and so then the third time, this function has control over the node. So this kind of traversal pattern you have three opportunities to do something with the tree, the data of the tree at that particular location. So, I made an animation for you. So, here’s a tree, and I want to traverse it.  So, I call pre-order on the root, which is a 12 here, and I’m gonna put one dot for every time, the function has examined the node.   And down here, I’m gonna print out, the nodes in the order that I visit them.  Okay, because, in the order that they’re printed. So, I do twelve, then eighty one, then seventy three, so, because it keeps calling, and it calls print, then it calls on the left side.  Now when it hits the seventy three it’s going to go down the left side, and that’s a null  And it’s gonna come back and go down the right side, that’s also a null. So now it’s gonna return back to the eighty one.  So what’s gonna happen now? It’s gonna go the eighty four, right?  So it goes there, left is null, right is null, it’s gonna go back to eighty one, and it’s gonna go back to twelve.   And then it’s gonna go to seventy three. Is this pattern working working for you?  So, to speed things up... then finally we return all the way back to the root.  So, this is called preorder traversal. There are languages which use this exclusively.  All the Lisp dialogue languages, so Clojure, Lisp, Scheme, Bracket, they all use preorder notation for everything.  So if you take the honors section, you get tons of preorder goodness.  Uhh, so…we can also take…what happened here?  Yes, this is what I want. So I call the preorder yet, it’s actually post order. Right, because now, I’m printing at the very end. So on my third visit of a node, I do the printing out.  So, here, twelve…because after I visit all the children, then I come back, that’s when I print the thing out.  Fifty three, then twenty nine, then seventy three, and twelve. This is post order.  Now, when I was a student, everyone in engineering had an HP calculator that used reverse polish notation, is that still true? Or have they gone soft and switched algebraic? They’ve gone soft?  Oh, that’s disappointing. Alright, so this reverse polish notation, its called.   It’s because you type in the roots first, then you type in the parent. And there are languages which use this, so if you ever get the chance to learn a language called Fourth, pick it up and play with it.   Spend an hour with it, it’s kinda cool, because to add something, you have two numbers, you’ll type the first number, so ten plus twelve, you type ten hit enter, you type twelve hit enter, then type plus.  So basically, it’s using a stack. You push the two numbers on the stack, and plus pops two numbers off, adds them, pushes it back on. So it has this kind of traversal pattern. Alright. Why did it double all of these traversals? This is weird. Part three. 
d Slides are wrong. This slides show preorder instead. Explaining inorder traversal (slides are wrong) You can reconstruct the original tree if given the preor You can reconstruct the original tree if given the preorder, postorder, or inorder printout Preorder traversal: + * 2 4 - 9 3 Postorder traversal: 2 4 * 9 3 - + Inorder traversal:  2 * 4 + 9 - 3 Explaining process of traversing tree See powerpoint slide for the example
Professor is figuring out why the slides are messed up Going over the example First you want to build the original tree. Did everyone get that tree? What's the preorder for this: yell it out [student answers] I will post the pdf of the slides to piazza. I will post the code and the slides to piazza answer: 2 3 * 9 9 * * This lecture had over a hund this lecture had over a hundred slides, i'm crazy
[Video playing] Alright, we'll see ya monday!
Try to go to, how do you register online as a grad student? normally, umm... Okay, and the link didn't work? Okay, What link do you use when you sign up for courses? So you're a grad student, right? So whatever link you use to sign up for courses as a graduate student, try that one? Do you have a my cs account? Do you have a webpage my.cs.illinois.edu. Does that work for grad students? okay um,  oh, okay okay alright um You can audit if you want. here's what you need to do to. Go to the academic office in Siebel Center Tell them that you're a graduate student in statistics You need a paper form because you're not in the engineering college. Siebel, the first floor there's a big office called academic office, yeah go in there and they can help you. they're very nice people What's your name? Hi
[Video Playing]W What's your name Nova I am Cinda. You got it. Oh, that make me uncomfortable. Ok, Nova said is time to work.  Time to play school. You guys had nothing back there right? Can you hear? My laptop is connected, everything is connected. OK, how about this one? This one is going. Ok, I apparently can't the volume or anything. And, this is one had not bug at all. You know, there are could have many million ways the day could had gone wrong. Given how prepared it was. I was't expecting this one. So, here is the deal. You have a guess lecture, and I heard went very well. And so grateful. I got to spread the day on the lake in the mid of fall in northern of Wisconsin. It was the trees, you know what? The trees were not upside down. It's a bad joke, I don't even know. I'm just going to like use all the mics. Ok, Alright, here is the deal. Mattox what he cover would have been cover what I cover today Mattox what I am going to cover today was we would had done in last Friday. So, the topic are little bit switch in order. But I don't think it matters. In fact, if you could in fact you could argue that there are benefits to have not seen the implementation haven't seen these thing in action. And then returning to something of the sort of the mathematical notion and representation of them.
We'll see...You can let me know afterwards it did work for you. Let us know because it's our class. All right. So ..um.. I don't know. I don't know what's gonna happen with the MIC. All right !Oh..not that. I have no packets.It's not funny.I'm not...I really... OK.Here's what I need. I'm gonna send really close . What I want you to try to do is take this class out of here and put it on that one, okay? Oh but wait a second. If this makes you uncomfortable you can pass the test to..... Okay. All right so we're gonna talk about binary trees. I'll catch up later if you want.  Remember we're not talking about binary trees, we're talking about rooted, directed, ordered binary trees. And I'm never gonna say that again I'm just gonna say binary tree. Because most of the, actually it's the equivalent facts that most of the function we're going to write are on this structure because this structure is recursively defined. So I want to give you some of the symbolism that typically used with recursively defined structure. Thank you. And that can be turned off. All right. So the question is how is this thing recursively described? Okay, now I'm not writing code. But the way I described this thing is going to inform the way that I write code about it. OK. So binary tree T is either empty ...... please things work....Oh no.... I cannot believe this. Okay. It's either empty and the way we're gonna represent the symbolically is to say T equal empty dragon brackets. Or, it is a root together with two subtrees. Or T is a root together with subtrees and I'm call this root r subtrees Tl and Tr. What's the L and R stand for? Very good. And the way that I'm gonna write it symbolically is T is equal to R with Tl and Tr. So I'm gonna make a tuple out of this. And write it like that. Okay. Any question about that? While the first thing means a root, the first thing has type root, and the second two things are binary trees. And that's the recursive part of this definition. So we say and Tl and Tr are also binary trees. Okay. Any questions about that at all. Now notice how this shapes the code that we write for any function on binary trees. What is the base case? What's the base case of any recursive function we write on binary trees? It's empty! right? Or however we represent that empty tree. We think it might be NULL. Good idea. Then we're gonna do some action on the root and then call the function itself on Tl and Tr. So this definition informs how we write code for this structure. Any question about it ? Now I have a question for you that is does this definition work? Think about the right subtree here. Think about the right subtree. It kind of unroll the recursive definition in your mind. Does it work? Yeah, okay. How that right subtree... is it empty?  No. So we say root together with..
The trees, TL and TR, and are they binary trees? Yes! Because they are empty, right? Look. It's there's like an empty tree there and an empty tree there. So this recursion sorta feel sane to us. What if I erased um..This leg. If I erased 5, and asked you to consider this binary tree. Do you like it? Is it ok? Does it feel like a binary tree? Sure, it's a root together with left and right subtrees. The left subtree has some substance and the right subtree is...is empty. So we're OK. Alright, any questions about that recursive definition? OK, well...Uh...Let's see. So we're going to write functions on these structures and these functions can come in lots of different forms and in fact the data contained in this...The data contained in this particular example tells you about one of the functions you can write on binary trees. What does that data look like? What does that data remind you of? Can you imagine? Computation, right. Evaluation of an expression, that's right. So, in fact, you can imagine that every subtree is like a parenthesized phrase, right. So this triangle has parenthesis around it, this one has parenthesis around it. The whole thing has parenthesis. So this is an example of an expression tree and if we know how to get around on this structure, using say...Traversal. Then we may have a good way of evaluating such a structure. But we're not doing that right now. Okay. Alright, so let's write some functions on this structure. The first one we're going to write is height. Now, you guys talked about height last time, right? What's wrong? We didn't...Mattox and I didn't get a chance to talk beforehand and so the definition that he used is a different one then we're going to use. Okay? So, the definition of height that we're going to use in our class is the length of the longest path from the root to a leaf. Okay? So what does that mean about the height of that tree? What's the height of that tree? Height here is 3, good. 1, 2, 3. Okay? Path length is number of steps or number of edges. Okay, that's all good and fine. Uh, what is the height of here's this example. What is the height of this tree? What's the height of that tree? Zero, very good. And what's the height of five's left subtree? This is where there's a problem. We should all be going gulp I don't know. gulp I don't know. Alright, let's talk about it a minute. Alright, so given a height, given a tree T a recursive definition of the height of T. Alright, so this is what I think is true. The height of T is one plus the maximum height. This is what you did last time. H E I G H T of TL and height of TR. Right? Nothing's different than last time. The problem is...The problem is what's the height of an empty tree? So if I draw you a picture of an empty tree, what's it's height? I drew you a picture of an empty tree, see it? It's lovely isn't it, it is both the most beautiful and the ugliest tree you've ever seen. Right? It's an empty tree. So what's the height of the longest path from the root to a leaf? Uh...uhh...What path? What path? OK. So there is no root, there is no leaf, there is no path. It's completely indetermenant. So we can choose any height we want. Now. Because we can have empty trees it makes sense to choose a height for that empty-ness, the absence, to be something that makes sense. Okay? Does something that helps us out mathematically. Well, you were already whispering what helps us out mathematically. It is the solution that gives us a zero for a single node tree. And it is, what is it? Negative one, that's right. So the height of an empty tree is negative one. tree? What's the height of that tree? Height here is 3, good. 1, 2, 3. Okay? Path length is number of steps or number of edges. Okay, that's all good and fine. Uh, what is the height of her
I'm making a little table here here's my empty tree I can't draw anything there. The model doesn't allow me to draw anything there Now make sure that you believe that it works. which case applies to that tree which case applies to the node containing 5 there? recursive case or base case? recursive case that's right tempting to say that's just one base case but no the recursive case applies so we're going to look at the height of the subtrees take the maximum one of those and add one to it what are the heights of the subtrees? negative one we add one and we get zero so that works out for us any questions about that? Now what gets us that freedom the freedom to ascribe whatever height we want is the fact of the defiinition the english definition is actually indeterminate on an empty tree so we can choose anything that makes our live convient maybe it was negative 42 but that would screw things up completely any other questions about this? who's yawing? oh did you get it done? i was up late last night driving back from green bay full binary tree i'm gonna tell you some things that are gonna confuse you there are three words that used to describe trees they are full, complete, and perfect three definitions they mean completely different things so this is the problem this is the problem with the language that we choose to describe these things moreover, moreover not unlike height they might have slightly different definitions depending on who you talk to. mathematicians would call what I call perfect trees a complete tree and they don't have this separate notion of a perfect tree in this context it pays when you're having a conversation with somebody about the vocabulary associated with the tree to make sure your definitions are clear i want to point that out before we do the definitions so that you can be confused going into it clarify it in your own way ok so i'll tell you an english definition for a full binary tree it is simply one in which every node has either two or zero children so is this one a full tree? sure is that one a full tree? no of course not that's what the example is for so every node has two or zero children now what i wanted to do is write a recursive definition for this this is sorta to prove that not every recursive definition is elegant unfortunately they are not i will start though with the fact that f is a binary tree which means it's probably going to be the case that we're going to use empty and not empty as the cases for our definition and indeed an empty tree is a full tree now the recursive case is what's interesting so let's talk about this and note that we have Tl and Tr to use in our definition of this full tree so what does that definition look like? what is true about Tl and Tr? right they're either  i'm gonna switch it around a bit he said that both valid or both empty say the empty part first and valid is a term i haven't given a definition to so i'm just gonna say either both empty or both not empty how bout that? so the emphasis is on both right? if i came to you and said 'huh this tree is either empty or not empty' you'll go 'yeah'  but in this case what we're saying is that they are either both empty or both not empty and my definition is not complete
Is this a full binary tree? NO. Ok.  ou agree that it is full but it satisfies my condition, TL and TR are, see? Here is T. Here is TL, it’s not empty. Here is TR, it’s not empty. And, what must I say about TL and TR. T They are both full binary trees. This is a recursive part. Ok?  So,if you think you are writing a definition about trees and you haven’t use the vocabulary in the recursive definition then you are not finished.  Ok, any question about it. So I need to put like a big red.  This one is not a full binary tree.  Any questions? Ok. Let’s work on perfect.  I give you the definition here I believe… And I want you to build for me the first couple of perfect binary trees.Ok? So I’m defining this thing to be P sub h that is parameterized by the height. Structure is parameterized by the height.  So what’s P0.  Perfect tree of height zero. What does it look like? Single node. Very good. Now, draw me a perfect tree of height one.   Ok good. Now draw me a perfect tree of height two. Pressures on.   On the fly,  look at that. Good work.  Very good. Ok, any questions about it?  This is just a tree of height H with all the nodes.  All the nodes are there. Any questions about it.  As I say before a mathematician may call this complete tree. Ok, I have a question for you how many nodes in a tree are height h. Think about 30 seconds speculating on it.  There isn’t two in the answer. So when I refer to how many nodes I’m gonna use the vertical bars here  and represent size…to represent size.  So these vertical bars are gonna represent the size of the trees are going to be number of nodes. So what is it. Ok, wait, say it again.  It’s two to…I think it’s two to the h+1 -1. Is that work?  Ok. Ok. Fine. I don’t know if that is right or not.  But what I do know is true is that the size of Ph is definitely  s all the nodes in each of sub trees plus the root. Oh and the number of nodes in the tree of height oh I don’t know.  Zero is one started there.  This doesn’t really matter.
Wait a minute, so... she said this and I can argue combinatorially this, right.  The total number of nodes in the tree is all the nodes in the left subtree + all the nodes in the right subtree + the root. Okay, what is this thing right here?... It's the recurrence. Are these two different things?  No they're different expressions for the same idea. But how do we prove it, using induction. We have a recurrence which is easy to write down and a hypothesized solution and in order to make agreement between the two we could do arduous arithmetic like from calc 1, or we could simply prove that they are the same inductively.  fffh    We're going to do an inductive proof today, just not here though. K, so prove that these two are the same Via induction, and I'll warn you that I didn't really check this, is it actually h+1 or is it h?  It's h+1. Alright, how about another question, lets talk about a complete binary tree. If you read that english definition it stinks, it isn't recursive, it's like a perfect binary tree except not all the nodes on the bottom level are there, and moreover all the one's that are there are pushed to the left?  What Kind of definition is that? it turns out, that to be extremely useful to us, we're going to pursue making an elegant decision, but first I want to make sure that everyone can draw a picture of a complete binary tree, so please draw me a complete binary tree with one more node than I have, so one with 13 nodes. This is a complete binary tree with 12 nodes, so node #13 has to go right here, otherwise you either mess up the height or you you add a vertex so that everything isn't pushed to the left, leaving one spot for the node, right ... here. Any questions about that?  Now because we like recursive definitions, we are going to solve the puzzle of expressing this kind of tree recursively.  In this definition you can use your definition for a perfect tree as well. What I want you to do is to figure out what this definition looks like.  My hint is to use the example to craft one of your cases and to think what would happen if this were a tree with ten nodes for the OTHER case, take a few minutes coming up with this definition.
Wait a minute So she says this and I can argue combinatorioally this right? Do you see that? I can argue this combinatorioally  The total number of nodes in the tree is all the nodes in the left subtree  plus all the nodes in the right subtree oh and they are the same plus the root yes? ok what is this thing right here? How do you describe it? What is it? The recurrence? This is a recurrence are these two different? things same they are different expressions for the same idea different expressions for the same thing oh yeah prove it how would you prove it using induction That discussion that we just had there was a total conversion like dinner conversation We have a recurrsion recurrence which is easy to write down and a hypothesized solution and in order to make agreement between the two we could do ardous arithmetic like you did when you took calc 1 or we can simply prove that they are the same inductively we are not gonna do it here but i just wanted to bring that in this moment ok any question about it>? We are going to do an inductive proof today just not here this ones almost too trivial this should have come from the discrete math alright any questions about it? k so, prove these two are the same via induction and i'll warn you i didn't really check this is it h+1 here or is it just h ok alright fine the other way you can prove it is by asking the class any questions? got another one for you lets talk about a complete binary tree shakin my head, shaking my head i'm shaking my head  if you read that english definition, it stinks it's not recursive, it doesn't evoke recursiveness i mean listen to this it's like a perfect binary tree except not all the nodes on are the bottom level there and moreover the nodes that are there they're all pushed to the left the heck? the heck what kind of definition is that well it turns out it's extremely usefull to us and so we're going to pursue so we're going to actually pursue making an elegant definition of it but before we do so I wanna make sure that you could draw a picture of a complete binary tree so please very quickly draw me a complete binary tree with one more node than i have 7,8,9,10 than i have 13 nodes and you shouldn't start from scratch yeaah right look this is a complete binary tree with 12 nodes where did that 13th one have to go? it has to go right here right? it has to go here otherwise you either mess up the height either mess up the height so you have leaves on a bunch of different levels or you add a vertex so that you that you don't have everything pushed to the left there is really only one place where that 13th node can go and i'll put in here really quickly like this ok any question about that? alright fine now because we like recursive definitions so much we are going to solve the puzzle of expressing this kind of tree recursively in this definition you can use uhh your definition for a perfect tree as well ok and what you want you to do is figure out what this definition looks likew my hint here my hint here is to use the example to craft one of the cases and to think what would happen if this were a, a tree with 10 nodes for the other case the other piece of the definition this part k and go ahead spend a couple of minutes coming up with this definiton the recursive case
Wait a minute, so she said this, and I can argue combinatorially this, right? You see that I can argue this combina You see that I can argue this combinatorially? The total number of nodes in the tree is all the nodes in the left subtree plus all the nodes in the right subtree, oh and they're the same, plus the root, yes? Ok. What is this thing right here? How do you describe it? What is it? The recurrence. This is the recurrence. Are these two different things? Same! They're different expressions for the same idea. Different expressions for the same thing. Oh yeah? Prove it. How would you prove it? Using induction. Ok? That discussion we just had there, that discussion we just had there was the total conversation, ok? Like dinner conversation, right? Do we have it a recursion, recurrence, which is easy to write down. And hypothesized solution, and in order to make agreement between the two, we could do arduous arithmetic like you did when you took calc 1, or we can simply prove that they're the same inductively. We're not gonna do it here, but I just wanted to bring that up in this moment, ok? Any question about it? We're gonna do an inductive proof today, just not here. This one's almost too trivial. Oh, sorry. This should've come from discrete math. Alright, any question about it. K. So, prove these two are the same. via induction. And, I'll warn you you know what? I didn't really, I didn't really check this. Is it h plus 1 here, or is it just h? Ok. Alright, fine. The other way you can prove it is by asking the class. Alright, any questions about it? Alright. Got another one for you. Let's talk about a complete binary tree. I'm just shaking my head. I'm just shaking my head. Because if you read that English definition, it stinks. It's not a recursive, it doesn't evoke recursiveness. It's, I mean listen to this, it's like a perfect binary tree except not all the nodes on the bottom level are there. And moreover, the nodes that are there, they're all pushed to the left. The heck. The heck, what kind of definition is that? Well it turns out to be extremely useful to us and so we're going to pursue. we're gonna actually pursue, making an elegant definition of it, but before we do so, I wanna make sure that you could draw a picture of a complete binary tree, so please very quickly, draw me a complete binary tree with one more node than I have 7,8,9,10,11,12.. thirteen nodes. Complete binary tree of thirteen node, and you shouldn't start from scratch. Yeah. Right. Look, this is complete binary tree 12 nodes. Where does that 13th one have to go? It has to go right here, right? It has to go here. Otherwise, you either mess up the height I believe bunch of different levels, or you add a vertex of the, you don't have everything pushed to the left. Cuz there's really only one place that thirteenth node can go. And I'll put it in here really quickly like this. Okay. Any question about that? Alright, fine. Now, because we like recurrence, recursive definition so much, we're going to solve the puzzle of expressing this kind of tree recursively. In this definition, you can use ahh.. your definition for a perfect tree as well. Okay? And what I want you to do is figure out what this definition looks like. My hint here, my hint here is to use the example to craft one of the cases.  And to think what would happen if this were a tree with ten nodes for the other case, the other piece of the definition. This part. Okay? And go ahead and spend couple minutes coming up with definition, please The recursive case.
Anybody want to write it on my tablet? I will walk around and if you seem to have it I will give it to you. In case you are having a hard getting start it, I am going to ask you a question. What does the left subtree of this example looks like? The left subtree looks like something you seem before, rather than recently. What is it? Anybody want to write it?  um, if somebody over there wants to write I will throw this PC like a frisbee . That is inceptive right there.  No way? Alright, tell me what letter I am going to write next. What does this looks like? What letter I am going to write next? If I am filling in this blank. No. p right? I am going to write p. I have a symbol to represent perfect. P and how tall is it? How tall is it? P of h minus one good and what does the right subtree look like? C of it's height is also h minus one, good. Okay, any question about it? Okay, fine. What if these node doesn't exist? Then the left subtree will look like what? C of , good. How tall? H minus one, good. And then right subtree looks like what? I will give you the h minus two there C or P? Raise your hand if you think c. Raise your hand if you think p. Okay P of h minus two, that's right. There can't be anything there Alright, any question about it? Good. So now, now, if you're trying to do some computation on complete binary tree, this is one way you could arrange your computation if you want. Writing a recursive function on complete binary trees, you just have to defined that function on perfect tree and make a bunch of recursive calls. Okay, alright. So, I wanted to verify for you that my English definitions were even say all nodes are pushed to the left is actually something official.  That is what is this link is about. It comes from nist, the National Institute of Standards and Technology. So, this is nist.gov um, and, I believe the ds here is for data structures. So this is the official defition. What? I know, isn't that sweet? Dev All kind of data structure something, and this is their definition in complete binary tree. There is one vocabulary word in the definition that we have not t talked about.
What word is in my English definition that we have not talked about? Level, very good Level is not defined But suffice to say, here's level 0 There's level 1 There's level 2 There's, in general, is level h Sorry, it's just an index for the path length, effectively From the root, any question about it? This part right here? Okay, so the question is, What the heck am I talking about there? So in this recursive definition, we are admitting that this jump from the bottom level up to the previous level, has to happen somewhere Now, case one is the situation where that jump up happens in the right sub tree And case two here is the case where the jump up to the previous level happens in the left subtree Now, for any opportunity or example where you jump up in the left subtree, that means that the left subtree itself has all the nodes pushed to the left, right? And so it is complete How tall is it? h-1, very good Now, the right subtree in that case has no nodes on the bottom level, so? it's perfect How tall is it? h-2 Any other questions? If you added 3 nodes to the original tree? I see what you're doing Are you asking which of those recursive cases applies? I believe it is this one (circles first case) Applies because both subtrees are height h-1, in that case What does that say about a perfect tree of height h-1 It's also complete, that's right You can untangle it, I believe it will work So the question is, so I gave this teaser, right, I said  Complete binary trees turn out to be very useful It's gonna be about two weeks before I give the punchline to that one This is a two week cliffhanger I want you to be watching for it Alright, any other questions about it? We good? Okay, is every full tree complete/ No way! No! The one we drew was an example of a full tree that was not complete Is every complete tree full? No! Really? You're right, push on it Is every complete tree full? I'm gonna erase everything here
Is the example a complete tree? Yes it's complete that's what we're talking about. is it full? No, okay because of this guy so no Every complete tree is not full Here's one, that one's complete but not full There's one if I erase all of that Okay, Alright any questions. So now you have working definitions of  Full and perfect and complete If I were you I would make flashcards maybe, I don't know, I know I wouldn't because I would be too disorganized, but you know Alright, so let's touch base for a second with what um Maddix showed you uh last time about implementation of this structure So I believe he did something like I believe he did something like create a tree Uh he might have called it binary tree Uh but, it had an internal structure that we called a node Notice just for a second , step back and look at this. Where have you seen something like this before Besides Friday, where have you seen something like this before A doubly linked list, right, previous, next who cares what they're called The structure is the same, the only thing that's different is how we link things up How we connect things Okay, um so, uh, Maddix gave me his slides where he had hooked things up Kinda like his, kinda like this, is this tree full? Perfect? Complete? Yes okay alright fine And I looked at his drawing and I got all worried I was worried that there were too many null pointers Because we're implementing this thing in such a way that all of the term, all the leaves All of the terminating nodes have null pointers associated with them Now, this is kind of fine if there aren't too many of them How many null pointers would be Well, first of all let me start with a doubly linked list Why was I not worried about this at all in a doubly linkedlist How many null pointers did we have essentially? Essentially two right? If we, yeah  Right, essentially two, one at each end okay So, we had a constant number okay How many null pointers would make me upset How many null pointers would make me go oh that is too much memory" We're using too much memory for n-data items Exponentially would be too many, two to the n would be too many, how many uh anything else? Would log(n) be too many? No? not bad at all because that's fewer than n right? Log(n) smaller than n, it lives in the world smaller than n.  And all that means is that every piece of data is just a little bit fatter Right it has a little bit more actually dwindling amount more Of stuff, memory associated with it. So log(n) wouldn't bother us at all How about linear? A linear number of pointers. Would that bother us?  On the edge right?  It doesn't , a linear number of pointers some constant factor of n number of null pointers would not bother us Because again, it just means we got some overhead associated with our data We're just a little less efficient  Representing the integer contained in the data node  Okay So, no big deal to have a linear number How about a quadratic number of null pointers Quadratic number of null pointers , yeah that's bad I have a little picture for that, what that would mean is that our  What that would mean if we had n pieces of data Then we would have this much memory associated just with the null pointers Right, that's too much. Right n squared of nothing so as a support linear of data that's bad Alright fine, I want you to complete that theorem for me as accurately as you can
I want you to complete that theorem. The theorem itself not to prove, that whole blank page. That's the prove. Hahaha You can do this. Anybody have it? Wanna tell me? Did you raise your hand back there? Or were you waving at me? Gray shirt. Either one. What? Say it together, coordinated. Very good, okay. Good. Do you guys here that? Do it again. Encore, encore. This is what they said. N+1 Null Pointers. That to many nodes it's fine, it just means every piece of data have a little bit more memory associated with this. Okay? No problem. There's big blank splits. Page there. And everyone comfortable doing this? Because that means I'm going to do a lot of the talking. So, well, we'll plunge in.  So I need to prove this. This is a theorem, theorem that's bad for prove. And I'm going to do it by induction on the number of nodes. Which corresponds to the number of data elements. Alright Consider an arbitrary binary tree. with N nodes We'll prove that it has N+1 Null Pointers, okay? And I'm gonna call it T. So this is just set up, right? This is just set up. It's giving us labels to placed on our arguments.  Our labels now are T and N, that's all we've got. There are two cases to consider. Case one, T is empty. The base case of the induction, okay. Well, let's argue it. We represent the empty tree how... how did we represent the empty tree? How do we program it. You guys did it last time. Yah, we represent it in the empty tree with one Null Pointer. So the theorem holds. Yes? Any question about it? Okay let's do case two. T is not empty. So it is a root together with TL and TR. Okay. We'll going to make this argument by counting Null Pointers.
Ok. By an inductive hypothesis that says  for any number less than n,  a tree of size, that size, j, has how many node pointers for any j less than n, a binary tree  of j nodes has how many node pointers? j+1 node pointers. Ok? By, we know T(L) has how many node pointers? And I'll give you a hint.  The size of T(L) is that.  How many node pointers does T(L) have?  T(L) has how many?   this many? Does it have this many node pointers? This many plus one.  And how many does T(R) have? The number of nodes in T(R) plus one.  So, T has the size of T(L) plus one plus the size of T(R) plus one nodes. Tell me something interesting about this.  Some of time to.......Oh it is time to go. I need only one more thing. Tell me something interesting about this sum.  Yes? It's the size of T. Look at this. This is the number of nodes in the left subtree, the number of nodes in the right subtree,  and the root, right? This is n. So this is n plus one. Done. Magical. Ok. Bye. Sorry keep you over. 
Um... back row, can you hear me? You guys are not in back row... OK... OK...UM... Let's see I have an announcement. Guess what it is...Midterms coming back in sections this week  It's coming back in your section, yeah I know I'm sorry. We try something new. Shame on us. Haven't forbid we actually make some changes. um...okay, so um... your midterms are coming back to you in section this week. Um.. I have here... the data, on the midterm, you can kinda see the... it's a normal curve...sort of which I like to see, um.. the median is 75, it's a perfect exam! It's a perfect exam. OMG and the average is 72 so...a perfect exam will have them be the same, but what I'm thinking is that there were few of you just sort of hunting. They got exam and they said Oh yeah I have to drop this class...  and that's what brings typically brings the average down lower than the median. ok.. so I should've write all that down... I think...um... mean of your exam was 75,.... no no no...72, median was 75. YES!!! PERFECT!!! One life is perfect ok... can you tell what happens really... alright umm what that mean so there unlikely to be a curve umm... a curve on this exam, or any kind of accommodation for .. ummmm.... the difficulty of the exam...yes?
So what I warm the lab TA will happen is the few people will have to come up to my office and get the exam from my office. You could probably get them to bring it to in that lab section if you let you let them know I had the time.  But, if it is all possible I guess I would like to ask your cooperation in actually going to your lab for your are register just for this week. Because that's where your exam will be. Here is real motivation, ok? So yes, the Lab TA will help you get your exam. ok yes, the Lab TA will help you get your exam. but after the class, if you go to the different lab section, but it will be grumpy about it and they will know who you are because you have to ask them for your exam So if you want course assistant are happy with you, don't make them make that the extra trip to my office. We ask you, ask your kindly. Okay, let's see. Don't think I haven't......Oh yeah. So if your score, this is not too many people, but if your score is below  So if your score, this is not too many people, but if your score is below 52, I think it is about 51, you probably want to consider what you need from the class. It is the way I gonna say it, so if your midterm score didn't make you happy, and it was below a certain score you might wanna think carefully what you want from the class. We are going to offer, we are going to be sending out invitations to the people whose score is low on the test to participate in, and to drop CS225 to participate in auxiliary course that will be a programing fluency course. With the intention of getting people up to speed, ready to go, and confident for CS225 next semester. So that opportunity will be afforded to people who are particularly unhappy with their score.  And if I m unhappy, if you got above 50, I think you know, there are other thing you can do to get yourself ready for future exam.  Yes, speaking  a future exam, when it is the second midterm. I believe it is schedule for November 2. We will going to, yeah, so here is the thing. We will be going to get rid of the second exam and instead of asking to do a bunch of little exams But we hear mixed messages on the testing center, we don't have the class time to do these little class, the little exams in class like they do in 173. And I am afraid now of doing anything differently than we ever done before because you know, this exam took two weeks to get back to you. which I am not, I just on a custom to. So I think we are not gonna make that that sort of  (moderate) change this semester, we are going to instead a exam like we always have. I think of it as tree exam, so it will largely be focused on trees, the topics that related to tree, dictionary. And there you go, is that okay with you? This kind of keep you normal. It is in November 3, did I... You know why, because 2 sounds like 2 and Tuseday sounds like two, and then it did that. But I didn't write it down, so you have no proof. Oh wait, there is whole transcription thing. Okay, globe substitute Tuseday with, I mean no, 2 with 3. I don't know. Alright, let's work. Let's play school. Any other administrated question, so I don't wanna cut you off. As it is a good touch point. Alright, when I was gone last Friday.... So I actually have a confession. I was kind of (b..) yesterday, cause I only have like half a cup of coffee. And I think people in my life recognize that because this is actually the second coffee gifts I've gotten today. So thank you so much .. So when I was gone on Friday, you guys wrote code for traversal. I wanna step back and have conversations about traversal. En… and you will notice in the absence of code. So what I want you to do is to write down for me. And you know it, in the absence of code. So, what I want you to do is to write down for me.
Youre guessing right. A traversal. But heres what I want you think about What I think about if you had this structure in front of you And your're talking on the phone to somebody How could you tell them the data, not the connectivity, necessarily, but how you would tell them the data that is arranged in the structure in front of you? Okay? So, write down a traversal of this data In a way that you would tell it, tell that data to someone who was sitting on the other line I know nobody talks on the phone okay. The order you would put it in a text message Does that make sense? You have to tell you aunt rosie about this super cool set of data contained in this tree How would you do it? After all, that's what a traversal is. Right? Go ahead and write it down Write down some traversal of this tree  Oh and do it in silence Oh you already are  Its very polite of you to let me drink my coffee  Okay, got it done? Raise your hand if you have it done Some traversal of the structure take a couple more seconds then  No just write down these nodes in some order. I dont care what order Not the code. Just write the data in some order I'm sorry Write down the data in some order No code This is not a code day Until later No no code! Write down the data. The order in which you are going to tell it to your aunt Okay got it? In some orde Now what I want you to do is turn to the person next to you Hi.  Turn to the person next to you and share your traversal of yours and raise your hands if theyre the same Oh now youre talking to each other Pair of you Raise your hands if theyre the same I wish I had a prize. You guys did the same one   Okay Okay. Lets pull it in So, the pairs of you that had the same ones raise your hand Raise your hands so Imma have littler conversations with you You had the same ones as yourself Very good Alright what traversal did you use What name would you put on the name of traversal that you used? Post order traversal? You both happened to use a post order traversal Raise you hand if you both happened to use a post order traversal and tell me what that order is here is a post order traversal of this tree Tell me those entries 
Good Very good Ok Any question about it? Ok, this is the reason we were doing this in exhaustion to its limit. So you can go back and check and make sure that mechanically you can see how these trees traversal go. There is a pair up here. You guys have same one, what kind of traversal did you do? you did a level order traversal, what the hack is that mean? Anybody want to guess what the hack they are talking about? Do you want to say it, you say what you think is on their pages. yes, yes... no way? no, it doesn't matter. do it really quickly, we don't expect you to get this one right? This is golden here, what is it? oh you want, ok which way? you said c, b, d, e slash  Do you see what I am doing? I am saying from what you saying in opposite order, alright Then, what you going to say? star, minus  plus Alright, yes, so a level order traversal you know what? if I would talking to my grandme, this is the order which I just describe the data. because, it is so easy to look and go the level by level and explain what data is there, alright. Now, do we need an algorithm to this yet? NOO, wonder what we are doing today. ok, another pair that had the same one. another pair? Which kind did you guys use? You have a name for it? a pre-order my power and my machines is out, so I can't carry around with me. so I'm going to be running with coffee. How do you do a pre-order? dash, slash, b, c star, d, e is that right? plus slash, b, c, star, d, plus, e Good alright, and there is one last, what's it? It's there any pair did it in order, any pair pair did it in order? You guys didn't? no pair that did it in order. ok, fine, I'm going to leave it. You can go figure what that is. here what I want to, you guys did it? you have one? you want to tell me? fine what is an in-order traversal? b, slash, c, plus, d, star, e good alright, there is that in reference for you ask you going back just another example of traversal to make sure you have the mechanic of it. I have a reason that believe you do. now, the next question is how expense is a traversal in term of time that is what the running time of a traversal. what would be in term of the amount data it containing? what would be if somebody came to you and said, I have traversal code that run in constant. what would you do? you are out of the street and there is an algorithm truck. and they sell algorithms and they have one in there menu constant traversal algorithm, eight bucks. what do you said? it's a scam, why it is a scam? it can't exist, if you have any piece of data and your objective is to look at all of them? you can't do it in constant time for any constant time algorithm there is an example of data size that will run long than its you just kind of increase the data sizes until it bigger. it just can't happen so, the time it take print it out takes longer that constant, what ever they said it is. Do you all see that? that's a reasonable to thing thing about every single time everybody tells you the running time of an algorithm, is that even make sense? what if you went to a different truck? so, this is. I'm in a different algorithm truck, this is rock and algorithm. the other is crack, clearly, crack algorithm. and they have to assign that said i'm totally.. here you guys is not right? I don't what I am talking about. they had assign this said traversal algorithm that run in quadratic time, five dollar. what would you said? ording n square what would you said?
Not worth it right? At that point you i'm opening up my own truck.  I'm going to go get a truck. okay? alright so, what would be reasonable. what would be a reasonable -- okay I'll buy that algorithm. running time of that algorithm for a traversal.  That's right, Big O of n You've got n pieces of data. all you're doing is writing it down. so if a traversal algorithm runs in time n.  That's good. that's what you want to have happen.  Okay let's see. I have some other questions about this.  So, I'm gonna do kind of a traversal that mimics the code for the traversal. This traversal is going to really be a walk around the outside of the structure. A walk around the outside of the structure. How much time did that take me?  How much time did that walk around the outside of the structure take me in terms of the data size?  How much time did it take me in terms of the data size?  All the way around. How are we going to think about this, okay.  So the magnitude, so the magnitude of the structure is order n.  There are order n nodes.  How many edges are there? There are not 16 edges, no way. how many edges are there in general? Big O of...?  N. edges. it's a tree. This is a discrete math result. There are big o of N edges My walk around spends a constant amount of time,  adjacent to each edge and a constant  and do you see what i'm doing here? so i'm adjacent   to each edge twice. right? so it spends a constant amount of time adjacent to each edge. So the amount of time I'm spending kind of going between vertices is big o of N and notice how much time do i spend at each vertex?  How much time do I spend at each vertex? How many visits are there, essentially? Three, right? There is the first time. wait where is a good one to do.  There is the first time I'm close to a vertex, there is the second time i'm close to a vertex and there is the third time i'm close to a vertex. right? now in a vertex like this,  the first and the second times kind of occur simultaneously and the third time is way out here. But that isn't really what matters. But certainly there are no more than three visits per vertex, right? we never go back to one or anything.  Now let's count this up in terms of the amount of work that is done. Big O of N for the edges because there are N of them. Big O of N for the vertices. Right? Big o of N for the vertices because there are N of them  and we visit them each three times. Okay so now let's look at the code and see if that understand of what we have done.  That understanding fits with the code that we wrote. Geez it feels really different here.  There are two things that represent edge activity here.  There is the. 
The reference to a parameter for the recursive call, right that's like the start of an edge in this picture. The passing of a parameter is like the path past this edge going forward. Yes, do you buy it? So when I do cRoot->right, it's like I'm walking down that edge, kind of. And the actual visit of a vertex corresponds to this moment or this moment or this moment. So those three red dots correspond to actually being inside this program code here or here or here.  The evaluation of this conditional is constant time. So we're actually not going to worry about it very much. But now what we observe, is thinking about the vertices and the edges actually corresponds to exactly the code that sits here. It corresponds to at least accounting for what happens in the code that sits here. I forgot the other side of the edge. I forgot this part of my little walkaround. That corresponds to passing control back to the call function. What's the punch line here? The punch line is that the amount of work that we do per data element is constant. It's three little visits, a function call, a return, a function call, a return. That's it, that's constant. But we do that for every vertex. If it's constant per vertex, then what's the running time? Linear. So constant O(1) per node implies O(n) for the algorithm. Ok, any question about that? Now notice that this is different than the way we evaluate running times for a iterative algorithm. Usually, when you see a for loop, you think oh that's a factor of n. At least that's where you start in your reasoning. When you evaluate things recursively, things get very messy. Especially when you don't know the size of the recursive call. It's easy if you know the size of the recursive call is n-1, right. That makes it easy. But the problem setting up a recurrence here, is we don't really even know how big to make this. We don't know what the size of the recursive call is here. Because we don't know the size of the other one was. Another way of evaluating how this algorithm works is to look at what happens for each vertex. Similarly, if you had a vertex, and for every vertex, you travelled to the root and back. For each one, a good place to start the analysis, is woah, at every vertex I go all the way back up the tree. that would be one way of approaching it. Alright, any questions about all that? The punch line is, traversals run in linear time. If they don't, something else is going on. And it's not good. Traversals should run in time proportional to the size of the data. It fits your instinct. And anything that smells really does smell for a reason. OK, I have one more question about this. So, all traversals should run in size proportional to the data. Is this piece of code which I believe was similar to what you wrote last Friday, is it public or private in the binary tree class?
Is it public? Did you guys make your subclass tree node public or private? Hey Mattox, was the tree node class public or private? The node class. Ok. Ahaha. Ahaoh. Gotcha. Meheheheheh. Gotcha. Alright, so, because the tree node class was private this cannot be a public function alright? So what you do if you have reason to believe that the user of your class is going to need to preorder, um, that is, if their going to need to say T dot preorder of where T is binary tree, then, you just make a public wrapper. Ok, and what I mean by that is a public version of preorder, that simply calls this private version with parameters... root. Which is private inside the class. I want to give you an application So suppose I give you binary tree and I want you to make a copy of it for me. The copy constructor the assignment operator So we're going to make a copy of the binary tree and notice again that for this one again we're making a private helper function So copy constructor and assignment operator are going to use this If I want to make a copy of this tree, then what am I going to do for an empty tree? Just return NULL right? And otherwise my algorithm is going to do what? Otherwise, I'm going to make a new node and who's left subtree is a copy of that one's  And whose right subtree is a copy of that one Th If this is A then this is a copy of A if this is B this is a copy of B Any questions about that Kinda makes sense right? Okay, so lets do everything that I just said We admit no matter what that we are going to need to return a tree node pointer thats what this thing is asking for  returns a tree node pointer so I'm going to declare that thing from the start  treeNode * t and I'm going to give it a default value that makes my life easy I'm going to give it default value NULL because the next thing I'm going to do is check to see whether my parameters is NULL Going to use next moment to differentiate between the base case and the recursive case of this recursively defined structure So what does that mean?  It means the next letter I'm going to write is an 'I' if (croot !  if (croot != NULL) then I'm going to do some stuff What did we do? We built a root so tee equals new tree node 
T's data should become what? Croot's data, good. And if I'm building that root node I have to do the data, I have to do the left subtree and the right subtree and then the node is built. What is the left subtree? T left is what? Copy of croot's left. Okay I' Okay I'll race you for the last line.  And then what I'm gonna do is return T. You like it? Seems okay, right? What's the running time? Waitwhat? What's the running time of that algorithm? Big O of N You did that fast! How did you do that? Okay so I'm going to write running time right here. How do you know it's big o of n anything else would make you mad anything else would be like ridiculous or ridiulous Either way Alright if you squint your eyes It looks a lot like what? Pre order traversal That's right It's an if statement it's a fat if statement there's a constant amount of decoration around it but it's an if statement with a constant amount of work and 2 recursive calls so it's just like preorder so I'm gonna say that the running time is big o of n teh same as preorder by analogu Can yo ualwayus just make a guess like that? Big o of n by analogy to traversal The same amount of work this is just a traversal where instead of yellling out your data you do something else you make a new node and copy some data okay any questions about that/ okay fine so it probably doesn't suprise yuou taht the next application of traversal that we are gonna see is the clear function I I've got a tree and want to clear out its memeory so take a look and see if the code does this What i think the code should do is clear out the left, clear out the right, and free the memory associated with the root so i think it should do this then this and then this okay does the code dod taht? oh, yeah i forgot this is the buggy slide I could fix it the other wayu the other way would be a little bit better in terms of you know in my binary tree class the root is called really this is the root something okay so now does the code dodthat? sorta this code has a big bug waht is it? Nope Here's the root r this one uses root as r What's the bug?
So if the root is equal to NULL, we do nothing there's nothing to be done, there's no memory associated with the thing So that seems to be OK Otherwise we clear out....Oh wait I'm doing something wrong already. What is root here Yea Root is a copy of r. It's a parameter. It's a copy of the original root. k? So what this code does is it clears out the left it clear out the right. It frees this memory. Right? That's what this delete does. And then it says this guy equal to null. Is that what we wanted? No. So how do we fix it? Pass by reference is the answer, that's right. So we need to pass by reference there and then this code works fine. And what is the running time of it? Big O of n. Which traversal does it happen to look most like... post order, that's right. To recursive calls and then a little bit of work. So by analogy, to post order traversal. OK, good? Alright, let's keep going. Alright, here we go. This is ...Grammy moment... Alright, something totally different. I think level order traversal is a perfectly reasonable way of expressing the content of a tree like this. The problem is that level order traversal does not use the connectivity of the structure in any way.  You jump from sub-tree to sub-tree. And so the approach to writing this algorithm is not a recursive  approach. Because we can't express the lever order of the main tree elegantly using recursive expression of the level orders of their sub-tree. Ok? Alright. So here's how the algorithm goes for a level order traversal. So the first thing we're gonna do is we going to create a queue and put the root on it. And here's my queue I'm gonna put the root on it. Root node. Probably root node, probably root node pointer.OK? Alright, so this is make a queue and add root. K? And then until the queue is empty,  do the following, remove elements from the queue yell the value and add it's children on queue OK So that means I remove plus from the queue, yell it's value and Onqueue its children, by conventionally do that left to right. By convention I'm going to add minus and asterisk to the queue. Ok? Can I keep going here? I'm going to take queue, yell, and add children It's an empty tree and the slash. Would you rather I put a NULL there? I don't know what does a NULL looks like. It's a little box with a slash in it, right?
We'll do that Alright, and then I'm going to remove asterisk yell it's value onto its children: d, e I'm going to dequeue the null Oh, if it's null, I'm not going to do anything, so just fly it away Let it go away Alright, dequeue, yell the value, enqueue the children: b, c Dequeue, yell the value, oh I hope this is working right You'll tell me in the end Enqueue the children: null, null Haha, yeah I know you don't like it, but you'll be okay Okay, dequeue, yell the value, enqueue the children I don't know what I'm doing wrong here No you're not Dequeue, yell the value, enqueue the children Oh boy I really have a point Dequeue, yell the value, enqueue the children And then dequeue, dequeue, dequeue, dequeue, dequeue, dequeue, dequeue, dequeue Done And there is a level ordered traversal, did it work?  Oh yes, it did. Yay, fine. Okay Let's write the code that does that And then talk about why you hate it so much Let's write the code that does that and then talk about why you hate it Alright So, I want to declare queue. I'm going to assume the existence of a queue class at this point. And into that queue, I'm going to put tree node pointers I'm going to call it Q Like the archvillain in the next generation Q.enqueue(root) And now I've done step one Alright, while it's not the case that Q is empty, notice I know that I can check that I'm going to do the following. I'm going to dequeue, so I need to grab the value, treeNode pointer t equals q,dequeue() I'm going to yell the data associated with t And then I'm going to Q.enqueue t's left, and Q.enqueue t's right Any questions about that? And then I'm done So, this code exactly reflects the English description of what we do I assert that you have actually written this code before, or if you haven't done it yet, you will do it very soon  What does this look like? It looks exactly like MP 4.2, that's right especially the breadth first part of it So using the queue to do this, this is what gets us this sort of breadth first thing This is going to be a reoccurring theme So you see it here You see it in MP4 and you will see it again when we talk about graphs Yes? Yeah okay let's do that point So, I assert that that should not bother you That putting all of these Nulls up there should not bother you Why can I say that? Why can I say it shouldn't bother you And the answer lies in how many of them there are There are order n of them There are n+1 of them we proved it We proved there are n+1 of those things Which means that burden of dealing with the nulls is no worse than the burden of dealing with the data So, in a traversal, that's not going to affect the running time per data element It's just like each piece of data is a data plus a null kind of, okay? So, we're not going to let it bother us Now, why did I do it this way? Why did I enqueue Nulls at all? And the answer is because if I did so, I would have to make a special case out of the original thing being Null, and I just didn't want to do that I didn't want an additional if statement here and an if statement here [Student talking] Oh yeah, there's a problem here, I'll fix it next time Yeah, this is broken Right here is broken [Student speaking]
[Video Playing] Happy friday! Barndance! Alright let's work. Okay you're not going to the barndance because you have an mp due tonight And I'm not going to the barndance because I don' have my boots on Okay so let's see Your mP is due tonight. Is that too loud? You good people in the back? Alright so last time we talked about level order traversal and i wrote a bunch of code for you and i did it wrong  do you remember this? It was bad in lots of different ways oh no it's gonna be one of those days okay so the execution of the algorithm on the tree was fine. I am going to consider this partial subtree only and pretend like it is the example of the day. So level order works like this. You can trace the code that we wrote and understand the algorithm it matches the steps in the algorithm except when I wrote that code I made a mistake. Okay let's see, so I have this queue that's what this line is intended to be. And I am going to enqueue the root, so this is review this should be reiview And I will try to do it quikcly. Ok so I enqueued the root remember now this is the root croot i believe it is called. Alright then now the queue is not empty we have already put something on it now while the queue is not empty we are going to grab hold of the dequeued value so i'm going todequque the minus the node containing the minus and then this is where I made the mistake If it is not null, so if T is not equal to null, then I am going to do the following. 
 The reason that broke before was because if it was equal to NULL, I get a segfault. That's right. OK?  So I have to check for NULL in that case. Umm...I have to check for NULL anyway in order to protect myself from dereferencing a NULL pointer. And moreover, you know, this things I really want to do if it's not NULL, it doesn't make any sense to try to enqueue a chlid when it does not exist. OK? So then, if we continue that execution, it looks like this. T was not equal to NULL, so we yelled T's data, that's a minus, and then we enqueue T's left, which is a NULL. I think I will write NULL like this because it looks confusing. OK? And enqueue T's right, which looks like this. But no containing the slash, OK? Now do you like that? Do you like it? Now you already don't like it, I know it. Getting in touch with your inner feeling about this. Why don't you like it? Somebody who doesn't like it raise their hands. Why? What's right exactly? What's the point was putting the NULL on the queue, right? That feels like a waste of time. It feels like a waste of time I'm going to articulate the difference in the code in just a minute. But I wanna continue this way just to finish the example for those of you who happened not to be here last time. And then we'll talk about what the alternative code would look like, OK? What the alternative code would look like. OK! So I'm enqueueing T's left, enqueuing T's right, and then I iterate. I moved the next iteration of the while loop Queue is not empty, so I dequeue. My dequeued value is NULL so I ignore it. And so the next iteration says dequeue again. Yell the value, enqueue the children. And just in case you missed it, by convention we enqueue left to right. OK. and Then continues Queue NULL know it's not so we dequeue it's not NULL so we yell its value, enqueue the children. Oh you hate that! The children... OK? Dequeue,  yells the value, enqueue the children, And then we dequeue*4 And we what we end up with is a level order traversal of the example subtree. OK? Alright. So let's talk about all those NULLs Let's have a conversation about nothing. Raise your hands if you get the reference. OK. If you don't get the reference, you should go to watch Sci-field, all the old episodes. Show about nothing, right? OK So we need to have a conversation about nothing. So what's the alternative here? How could we protect against this process of populating our queue with all these NULLs Yeah? Right. So you want me. I'm gonna put it in red. Does that look scary, or it's just too scary? OK I wanna put it in red. It's not that it's wrong. It's just scary So maybe orange is better because we're close to Halloween. I should really just stop talking and work. OK So if T left is not equal to NULL, then do that, and I better do it  for the next one, too. Right? If T right is not equal to NULL, OK Do you guys remember how I feel if statements. you remember that? So I don't them right? Because it increases the number of test cases that I need to make and I hate writing test cases. you might love it I hate it So, if I put these if statements here in addition to what already exists, then it mean that I have to write a test case for if T left is NULL and T left is not equal to NULL Similarly, for right. That seems sort of silly to me. Moreover, in terms of the the running time of this function. Think about what happens as you process it These two lines of code First of all, how much time does it take to enqueue something? constant time, right? it takes constant time Let's say 4. I don't know for what, but it takes 4 this just adds to that value, say 6 ,right? Whatever, it adds some constant value to the time it takes to enqueue. Right? So what ends up being faster, if we add these. If we add these, what ends up being faster in the end. The...what ends up.. how do we save time. How do we save time in the end.
Fewer iterations the while loop, right. Because we don't put as many things on the queue. So you're all worried about the number of iterations in the while loop. Ok now, I argue that as it is, and you're willing to pay for fewer iterations of the while loop, you're willing to pay a little bit of time here to decrease the total number of iterations in the while loop. That's dollar, this is your currency. Time is your currency. Now, I argue it just doesn't matter. Why? How many fewer iterations do you get? How many few iterations do you get? n+1, that's right You don't put nulls on. so the total number of fewer iterations you get is constant per data element. So you are, order in total, which implies constant per data element. So that means you are willing to pay constant per element in order to save constant per element. So it's a wash. And it's a wash in terms of running time. Overall in terms of asymptotic running time. I fully intended to go implement it both ways, with the conditionals there, and without them. But I just never did. Now, I also want to point out that actually putting these here mean you don't need this one, right? You see that? You actually do save a little bit there, but it just makes the code uglier, and increases the number of test cases. So the upshot is kind of you want to push your if statement up, so that lots of work is done in either case. It's more of a software engineering class type question. Ok, let's see. Oh! The other complexity is that when you start the algorithm you have to be careful. This as it's written, with these red guys here doesn't work on an initially empty tree. So what you have to do is that you adopt the principle that every time you ever do an enqueue in this algorithm you check first, and that means you also have to check here. [Writing]. I have a question for you, so I'm going to blurr my eyes so it's not personal. But i'm just kind of curious how you feel about this. I want to know whether you're sold on my story. I think it's very intuitive that putting those nulls on there bugs you. Bugs us. So I want to know if my argument has been convincing, and the way I want to judge whether it's been convincing is whether you feel like if you went to implement this code yourself, whether you would use the blue or red stategy. So I'm trying to tap into your inner feeling about code writing. Are you prepared to answer? Raise your hand if you would chose the blue strategy for writing this code, and raise your hand if you're not buying it, you would prefer the red strategy. Because it just makes sense. They're asymptotically the same, it's almost an issue of elegance. Is it black and blue or gold and white? Why you need the if statement on the top? The question is about the if statement on the top Oh well it's not empty so I'm lying you're telling me? Because it is empty already. I'm wrong, good catch. You don't need this.
Because this works, because we.  This that right? Yes, we didn't do a dereference there, yeah, yeah, sorry.  Yes we do, yes we do. Oh, no we don't.  No, cause it is not empty, we didn't change...Oh, yes we do, absolutely we do.  I'm confusing my empties with my NULLs. We absolutely do need it, because what you are thinking what I was thinking is that by putting a NULL there, the tree is still empty.  But it is not.  So, on that, oh...on that first iteration, on that first iteration here, the queue is not empty, right?  It's not, it has a NULL on it, cause we put it there. Croot, yeah that's true.  Right, right, right, right, right, that's the right correction.  You still need to do it, it's just the wrong test case, sorry. Okey, have I completely wrong with it?  You can save for like first 10 minutes of the next hour and then it will be like all smooth, but there will be no jokes, because when I like accidentally make a joke in here and try to tell it in the second hour, total flat.  Like the whole algorithm's track thing, I thought that was kind of cute, right?  Second hour? Totally fell flat, totally.  Alright, I'm done.  So the question is about how quickly these things evaluate?  How do you know that enqueue and dequeue doesn't happen super quickly?  Right? So we are talking about the difference between constant factors here, and asymptotic analysis.  Eh, the actual difference between running time on these thing depends on you know, whether you are running this in a cloud, whether you have implemented your queue as an array or linkedlist, it depends on lots of different things.  But what we are arguing over is constant factors.  So I'm saying that the inherit value of the algorithm which we measure ignoring constant factors is not different one way or the other.  It's always reasonable when you have two asymptotically equivalent algorithms, it's always reasonable to gave them a head-to-head run, simulated run in your context if it real matters how fast, how concretely fast they are.  Okey, if you are, em... yes, right.  But here, we are mostly talking about asymptotic performance.  Okey, does that, is that good? Okey.  Alright, any questions about this?  Did I clarify that first thing, so you do have to have a conditional, and the conditional should be around whatever you put in the queue, and I just leave an auto pilot, sorry.  Alright, any question about it? Okey, em... I don't remember what comes next, let's see.  Oh! The conversation we just had about binary trees and about traversals, was really more one of implementing an algorithm.  We are going step back for a second and talk about an abstract data type.  I think I am coming to believe, or coming to feel perhaps, that this abstract data type is the most important one that we use as sort of day-to-day programmers.  And the genesis of my feeling about this dictionary comes from my affection for python in getting things done, okey?  So I can not say necessarily that it will be apparent how powerful these things are in the context to be applications we do, but there is classic understanding that we will play into it that when you are programming in other languages, you will go oh, I'm so glad I know this staff", okey?  Alright, so the abstract data type that we are going to be interested in is a dictionary, okey?  The interface to a dictionary is at the bottom, we are gonna insert, remove and find by a unique identifier called that we commonly refer to as a key, okey?  So, the abstract data type itself is consists of these, the data looks like key value pairs, and the interface, the functionality of the ADT is insert, remove and find by the unique identifier, okey?  So, I want to speculate for a second just cause it's kind of fun to do so on if I have the following data, how would be, how would seem reasonable to implement a dictionary?  Okey, so my data here is a locker number, this is my ops, you don't have to be afraid of it anymore.  This is my key, and the values that I'm going to put into the dictionary or attach to each identifier, I'm gonna refer to here as my data though it's commonly refer to it's value. 
Because this works. Because, is that right? Yes, we didn't do a dereference there. Sorry.  Yes, we do. Yes, we do. Oh no we don't. No cause it's while it's not empty we didn't change, Oh yes we do, and absolutely do.  I'm confusing my empties with my NULLs We absolutely do need it. Because, what you are thinking what I was thinking is it by putting in NULL there, the trees still empty but it's not  So, on that first iteration here the Q is not empty, right? It's not. It has a NULL on it. Cause we put it there. croot, yeah that's true. Right, that's the right correction.  You still need to do it. It just wrong test case. Sorry. Okay. Have I completely wrong wrote it? You can stay for like first ten minutes of the next hour and then there will be like all smooth. But there will be no jokes. Because when I, like accidentally make a joke here and try to tell it in the second hour, total flat The whole algorithm truck thing, I thought that was kind of cute, right? Second hour, totally fall flat Totally. All right,  So the question is about how quickly this things evaluated. How do you know it that enqueuing and dequeuing doesn't happen super quickly Right? So we are talking about the difference between constant factors here and the asymptotic analysis   Um, the actual difference between empirical running time on this thing, depends on, you know, whether you run this in the cloud, whether you've implement your clue, Q,     your clue, as an array or a link list. It depends on lots of difference things But what are we arguing over is constant factors and so, I'm saying that the inhering value of the algorithm, which we measure, ignoring constant factors, is not different oneway or the other   It's always reasonable. When you have two equivalent asymptoticly equivalent algorithms   It's always reasonable to give them a head to head run, simulated run in your context If it really matters. How fast, how concretely fast they are. Okay? If your, um, yes, right. But here we are mostly talking about asymptotic performance. Okay, it that good?  All right, any questions about this? Did I clarify that the first thing, so, you do have to have a conditional and the conditional should be around whatever you put in the Q and I just, was on autopilot. Sorry All right, any questions about it? Okay, I don't remember what comes next. Let's see. Oh, uh, the conversation we just had about binary trees and about traversals    was really more one of implementing in algorithm. We are gonna step back for a second and talk about an abstract data type  I think, I'm coming to believe, or coming to feel perhaps, that this abstract data type is the most important one  that we use as sort of day to day programmers. And the genesis of my feeling about these dictionaries comes from my affection for Python and getting things done   Okay? So I cannot say necessarily that it will be readily apparent how powerful these things are and contacts to be applications, we do. But there is classic understanding it will play into it  that, when you are programming in other languages, you will go, Oh I'm so glad I know this stuff. Okay? All right, so the abstract data type we are going to be interested in, is a dictionary. The interface to a dictionary is the bottom. We are gonna insert, remove and find by a unique identifier. Call that we commonly refer to as a key. Okay? So the abstract data type itself is consist of these.    The data looks like, key/value pairs and the interface, the functionality of the ADT is insert, remove and find. By the unique identifier. Okay?  So I want to speculate for a second, just because it's kind of fun to do so.  On, if I have the following data, how would it be, how would it seem reasonable to implement a dictionary. So, uh, my data here, is a locker number. This is my, oops, this is my key.  And the values I'm going to put into the dictionary, or attach to each identifier I'm gonna refer to here as my data, though it's commonly refer to as value
Um.. is going to be the people who's stuff is in the locker. ok? Now, I have a question for you. Given data that looks like this, what would be kinda of a reasonable implementaion for a dictionary What would be a reasonable implementaion for a dictionary And I'll give you a hint ... That the, uh, particular example suggests an implementation The particular example suggests an implementation What did you say? No? Suggestion was string and I said no? Yeah? A list of pairs no? Yeah? An array why? (silence) Because, say it louder Nathan. Yeah, very good, so we're indexing by an integer value moreover these values are pretty small And do not even tell me that you didn't walk through your high school locker room and go.. Oh look I'm inside and array! (disappointing laughter) You didn't? Ugh... You will now! Next time you're in the locker room Ok, so, perfectly reasonable, perfectly reasonable, implementation of the dictionary Think how easy it would be to implement insert  If we had a private member called a" you could say a[k] equales The name Right? D here For example, whoo hoo, that's cool The problem is we're not always so lucky We're not always so lucky that our keys are smallish integers so the thing that makes this possible is that these are smallish integers Ok? Rather we're going to be faced with situations where our keys come in arbitrary types, like, oh, camera models Or colors or Fight numbers, they've got, or URL's for heaven's sakes Right? These are not numerical values Now, we could convert them, probably, to integers, but that's a different, but that's a different question Because then, converting, them to an integer that's small enough to use an array for is a whole nother puzzle So, here's what we're going to do We're going to use a binary tree as a dictionary Ok? So I want to say... Oh, and here's how to intrepret this binary tree The contents in the nodes are keys So, this 8 right here is the key And behind every vertex there's like a bubble Ok? Say, it's space in memory, we can think of it as a bubble, where the data dwells. Or the value dwells. Ok? So, the data associated with every key is accessible if you find the key. Moreover, we're going to assume, that key's are unique. Ok? Alright. And the datas are.. datas are associated The data is ... datas are ... ugh.. data is available Given a key We don't care how We don't care how, it's the data in the array For example So we're going to implement these things, we're going to implement these things using a binary tree. Maybe it's that the node contains the node class contains a data field That's what you need to hear Ok So, here's what I want I want you to do a find" of 4, returning the node associated with key value "4" What's your algorithm look like? Traversal? Very good. I heard somebody say traversal. So, we're going to go looking for a 4" (Cinda dropping beats) I don't see any fours Oh there it is! Here it is!
If we're going to do this, why not store our data linearly? It's possible that if were traversing the entire structure, if we have the potential for traversing the whole structure, we might as well be storing our data linearly. This is a bad idea. Let's do this instead. Take a look at this tree and tell me everything you can that's interesting about it. In what sense is it sorted? Someone describe to me how is it sorted? The smaller values are on the left and the larger values on the right. If things are set up appropriately, you kind of move left to right and you're essentially moving in increasing value over the nodes in the structure. Given the careful drawing of these things, that will always be true. Any questions about the observation of the order of this structure? This thing is called a binary search tree. We're going to use it as the implementation of our next implementation of a dictionary. A binary search tree, AKA BST is a binary tree and T is either empty or T is not empty. These are almost always cases for definitions of particular binary trees or specifications of binary trees The constraint is that X is an element of T L. If x is in the left subtree, then every element in the left subtree has value less than the key of r. You can complete the other line. A node in a right subtree has greater than key R. Where does the equal to case go? It has to be r. Because these are unique values. If x is equal to r, it is the root because they're unique values in the structure. You can choose arbituarily otherwise as long as you do consistently Futhermore, here's an example of something that satisfies that condition, but is not a binary search tree.  This satisfies that definition, but it is not a binary search tree.
How do we finish the definition? Do you see there does, satisfy the definition? Everything here is less than 37, DUH. Everything here is greater than 37. But clearly this is not a binary search tree so what's missing here? Must be true recursively. So Tₗ and Tᵣ are binary search trees. Okay any question about it? Alrigh so umm Last time, uh oh we're in trouble because you're flipping your page and we're like... Oh it's perfect, we're going to finish today Last time, when we talked about binary trees, I actually gave you a slide that just looked like this except there was no data in the TreeNode structure. So I pretty much gave you this slide but right before talked implementation, but I didn't talk about it, the reason was because in a general binary tree insert, and remove are ill-defined. We don't have a prescription for where our data can be. For our general binary tree we can just put it anywhere we want and when we go looking for it we have to employ a traversal. So find, as we saw in the previous part of the today was just traversal. So but now now the world changes. Because now if I give you a piece of data. Say I give you I don't know 22. If I give you 22, and say: where should I put this in the tree?" You can go you can start with the root and go "I don't know where 22 goes"  but I do know it has to go in 38's left subtree. And then we can do that again. Here is another tree the problem is the same I need to insert 22 into this tree and you go okay 22 can't go here because I already have a node here. I don't know where 22 goes but it has to go in 13's right subtree. Oh, there is no room there. So again, I don't know where 22 goes but it has to go in 25's left subtree and look we've got room for it. There is nobody it's like goldilocks and the three bears there is no nobody... Wait no not quite like that. There is nobody in my spot... Wait, thank you. There is room there so we might as well put it there  Alright, any question about that? Now look what we've just experienced. Well Well, we've experienced a prescription for where a piece of data goes in a binary search tree. So you've got a given structure, and the new piece of data comes along, it's a well-defined process for figuring out where that value goes. Moreover, the same thing is true for finding the value. I'm going to look for, well, you tell me what we look for. Somebody raise their hand and give us a number. What would be interesting? Oh, I know, I got a quiz for you. Tell me something we should look for that would require three comparisons.
65, okay, let's try it, and count. Okay, we are go off on search node that gonna require more But we'll try, we'll prove him wrong. Can you handle being wrong about 3? So we gonna go on a search for 65, okay? Now is 38 65? This one is easy, you can now say no, okay? Fine, we haven't found it yet. We know where it must be. Where must it be? To the right Have we found it? No, so that's another comparision Where must it be? To the right, good. Have we found it? No, so that's another comparision Where must it be? To the left. Have we found it? No, that's a comparison. Where must it be? To the left. But there is nothing to the left. So, find 65 gonna returns NULL. Cause it will return what's there Alright, any question about that? So the same kind of reasoning that we apply to insert can be applied to find as well. Now, here is a a little foreshadowing for you. I am going to spend whole lecture on remove  Did you have question? Oh, good question. You are two lecture ahead. So she is worried about the fact that it might not be the case the tree is beautiful Well, it actually isn't quite beautiful Because we have approximately the same substructure on the left as on the right.   Do you see that? We have approximately the same, and we are pretty lucky. She is already thinking about what happens if those are not approximately the same substructure Does the world get ugly? It does. Okay, but we are not there yet, we are gonna do the simple stuff first Okay, what's the running time for traversal. Big of n still. That's right Alright, I want to return a treenode pointer. I'm writing a function called find for the BST class and it takes as two values  the root of the tree and some key to find okay? so here's root and I'm gonna call this version of find like this. Find on root and then whatever the key I'm trying to find. Let's find 40 in this example. So, if croot is equal to... we are gonna think about this recursively. And the way to do that is to break down the trees that you consider to two kinds. The first of which is null so if you original tree is NULL, what should you return so, return null We could actually return croot here, because it is null Alright, otherwise, the tree is not empty, so now we are actually in the recursive case. We are in the general case. if we are in the general case, we still have something to consider. Those 3 things to consider in this general case are: If the root is equal to the key. What should we do in that case? return the root. Otherwise, if our input key is less than croot's key. Is that a safe deference? Yes, because we know croot is not equal to null. That's the other case. If key is less than croot key, then what? return, good. what are we going to return? We gonna go looking for in croot left. So we gonna return find on croot left
65 okay let's try it and count. Okay we are going to go off on search no that's going to require more. But we'll try, we'll prove him wrong I think he can handle it. Can you handle being wrong about 3? Alright, thank you. So, we're going to go on a search for 65. Now, is 38, 65, that's one comparison. Is 36, 65? This one's easy. You can all say no. Alright, so we haven't found it yet, but we know where it must be. Where must it be? To the right, good. Have we found it? No, so that's another comparison. Where must it be? To the right, good. Have we found it? No, that's another comparison. Where must if be? To the left. Have we found it? No, that's a comparison. Where must it be? To the left. oh, but there's nothing to the left.  So, Find of 65 is going to return. Well, I don't know what the interface looks like exactly. We'll say it returns null. okay, because it will return what's there the tree node pointer. Alright, because it's not there Any question about that So the same kind of reason we applied to insert can be applied to find as well Now, here is a little foreshadowing for you I'm going to spend a whole lecture on remove Did you have a question Good question you are two lectures ahead of the game. okay So, she's worried about the fact that it might not be the case that the tree is so beautiful. This tree is beautiful. It actually isn't quite beautiful. What the heck is she talking about, right? Because we have approximately the same substructure on the right as on the left. Do you see that? We have approximately the same and we're pretty lucky. She's already thinking about what happens if those are not approximately the same substructure. Does the world get ugly and it does. But we're not there yet. We're going to do the simple stuff first. Okay. What's the running time for traversal? Big O of n still, that's good that's a review question alright, so let's right some code. I want to return a tree node pointer and I'm writing a function called find for the bst class. and it takes as two values the root of the tree and some key to find Okay so, here's root and I'm going to call this version of find like this. Find on root and then whatever key I'm trying to find. Let's find forty in this example. I'm not actually going to do it If cRoot is... we're going to think about this recursively and the way to do that is to break down the trees that you consider into two kinds. The first of which is Null. So, if your original tree is Null what should you return. okay so return null. we could actually return croot here it would hurt anything because it is null We just tested that it's null. Alright, find if so otherwise otherwise the tree is not empty. so now we are actually in the recursive case. We are actually in the case where we're not null. We're in the general case okay. If we're in the general case we still have some things to consider. Those three things to consider in this general case are if the root is equal to the key. What should we do in that case? return the root. otherwise, if croot's key wait I want to do it this way. If our input key is less than cRoot's key is that a safety reference? Yes because we know cRoot is not equal to null. That's the other case. If key is less than cRoot's key then what? Return. What are we going to return? We are going to looking for it. Right? We're going to go look for it in cRoot's left. So we are going to return the find on cRoot's left.
65 okay let's try it and count. Okay we're going to go off on search node that's going to require more. But we'll try. We'll prove him wrong. I think he can handle it. Can you handle being wrong about 3? Okay, alright, thank you. Okay, so we're going to go on a search for 65. Okay? Now is 38 65? That's one comparison. Is 38 65? This one's easy. You can all say no. Okay? Alright so finally we haven't found it yet but we know where it must be. Where must it be? To the right, good. Have we found it? No, so that's another comparison. Where must it be? To the right, good. Have we found it? No, that's another comparison. Where must it be? To the left? Have we found it? No. That's a comparison. Where must it be? To the left, ohhhh, but there's nothing to the left. So Find 65 is gonna return. Well, i don't know what the interface looks like exactly. We'll say it returns NULL, cause it'll return what's there Okay, alright because it's not there. Alright, any questions about that? Okay so the same kind of reasoning that we apply to insert can be applied to find as well. Now, here's a little foreshadowing for you. I'm going to spend a whole lecture on remove.  Yeah, okay. Did you have a question? Oh, good question. You are two lectures ahead of the game. Okay? So she's worried about the fact, she's worried about the fact that it might not be the case that the tree is so beautiful. This tree is beautiful. Well, it's almost, it's actually isn't quite beautiful. What the heck is she talking about, right? Because we have approximately the same sub-structure on the right as on the elft Do you see that? We have approximately the same and we're pretty lucky She's already thinking about what if those are not approximately the same sub-structure.  Does the world get ugly, and it does. Okay, but we're not there yet. We're going to do the simple stuff first. Okay, what's the running time for traversal? Big O of n still, that's right. Good. That's a review question Okay, alright, so let's write the code. Okay, I want to return a treeNode pointer. And I'm writing a function called find for the BST class And it takes as a two values: the root of the tree and some key to find. Okay? So here's root and I'm going to call this version of find like this. Find on root and then whatever key I'm trying to find. Let's find for you and example I'm not actually going to do it. Okay, so, if cRoot, we're going to think about this recursively, okay? We're going to think about this recursively and the way to do this is to break the tree that you consider into two kinds The first of which is NULL, okay? So if your reasonable tree is NULL, what should you return? Okay, so return NULL We could actually return cRoot here. It wouldn't hurt anything, okay? Cause it is NULL. We just tested that it's NULL. Alright, fine, if so otherwise, otherwise the tree is not empty, so now we are actually in the recursive case. We are actually in the case where we're not NULL. We're in the general case. If we're in the general case, we still have some things to consider. Those three things to consider in this general case are: If the root is equal to the key, what should we do in that case? Return the root Otherwise if cRoot key, wait, if our key, I want to do it this way. I don't know, it's easier for me to think about it if our input key is less than cRoot's key, is that a safety reference? Yes, because we know cRoot is not equal to NULL. That's the other case. Okay, if key is less than cRoot's key, then uhhh, what? Return, good. What are we going to return? We're going to go looking for it, right? We're going to going looking for it in cRoot's left. So we're going to return the find on cRoot's left
Otherwise, do we need to write down this final conditional? No, because we cover all possible other cases. Right? Otherwise, we are going to return the find of cRoot. right? Yes, what's your question? Oh, very good. Sorry, So, I messed up the arguments here. [blank] Any question about that it? Alright, I'm ask you to about the running time of this, and then let you answer. So, the running time of this algorithm depend on what characteristic of the tree. The running time of this part of algorithm depend what characteristic of the tree? The height of this tree, that's right. Now, we don't know necessarily what the height of the tree is at any given instance. We don't know whether it's an almost nice looking tree, like this one. Where the about the same height on either side. We don't know whether is like that, whether is dramatic spill. So, we are going to for now report the running time in term of this parameter whose value we don't yet totally understand. So, the running time here is big-O of h, where h is the height.  And notice that the reflecting running time this way does capture accent of the algorithm It does capture the fact the algorithm start at the top and works way down until it find a leaf perhaps  Or, in the worst case it find a leaf. It does't in contrast, it does't explore the whole structure. That is little bit different than traversal we saw before. Any question about that? Ok, fine. I think the future semester I'll change the order of this because I'll actually like for you to written some code. But, this one it a little dicer. So, it would be better to have switch them. Alright, so, we were going write code for insert.  And, this one return nothing. Again, it's a binary search tree member function.  Now, keep in mind that we might be use BST to actually implement the dictionary. So, we still got this responsibility to deal with dictionary kind of things. It's name is insert. And the parameter include the key in data together with a root to the structure. So, cRoot insert might be call on root and might be I am inserting number 0. I don't know 65 was not there, might be we should put it there. And, data.... I don't know, d. can be clever there. Alright, any question about that? So, this is how would look? I have a question really quickly before we write the code. Is insert public or private? Private because refer to the root, the tree node pointer right. It refers to the root, it has root as the parameter. And, you can't expect the client code necessarily know that. But, it does not said it couldn't insert root, it just have to build a public wrapper for its. Like we did last time. Ok, so, it's cRoot is equal to null. don't think about anything else other than if the root is equal to null, and I want to insert something  What do I do?
And I'm gonna do this by reference also. That helps. Blank Okay?So that means we can actually change it So croot is equal to NULL. There is nothing there. OK, nothing there Croot is equal NULL. Don't look at the picture There is no picture Croot is equal to NULL. And I've got data I wanna insert. Where does it go?  Here! right? All I have to do is? Make a new node to put the data in So I can say if croot is equal to NULL, then croot is  new, good. New tree node and I gonna assume the right constructer exist cuz I don't wanna spend time on it Ok? Don't sneaker. That is. That's ok Ok? Alright Any question about that All right. Fine. What if croot's key so now so now we are in the case for croot is not equal to NULL. Now we are in the case for croot is not equal to NULL So what if you are looking for a key and you find it you have the value already in your tree What should you do So this is the matter of design Here we are going to do nothing here we are going to do nothing. we are going to let the tree take a unique value. What you might do is  changing the data associated with that key Em.. but for this example we gonna go a look. Key have to be unique  and that key is already there So we're gonna ignore this case. So I am gonna in fact write do nothing here And we're gonna talk about it in a second Okay? Otherwise, if the key is less than croot's key. What are we gonna to do Hum? I don't know what are we gonna to do But I do know that I should. Because we are not putting it in here. we are not, we are not putting the node in this current  Subtree. I don't know where it goes. But I know it goes in the current node's left subtree So if the key if less than the croot's key than we are going to insert  croot's left in I am sorry insert into croot's left key and data Otherwise, we are going to insert into croot's right key and data blank And you what I am gonna do. I am gonna go ahead and clarify this  So if key is greater than croot's key. So here clarify that case In comple get rid of this one Because we want to do nothing so we should just let the execuation proceeds Through this conditional never satisfy any of them. That's a good way to do nothing  ALL right any question about it? What's yeah? we are never gonna connect the node. The question is when are we gonna connect the node and I'm gonna say You already did Cause it is passed by reference Okay? So we are already operating on the node that is passed in  I take it from you that is time to go  I wanna know the running time first blank Big O h right good That's good enough for me Alright Bye Have a great weekend Class is ended
I will do this by reference also, that helps. 0:00 - 0:01 : I will do this by reference also, that helps. That means we can actually change it. So, croot is equal to null and there's nothing there. Croot is equal to NULL. Don't look at the picture. There is no picture. Croot is equal to NULL And I've got data I want insert. Where is it go? Here, right? All I have to do is? Make a new node and throw the data in. So I can say if croot is equal to null then croot is new treenode. And I'm gonna assume the right constructors exist. Cause I just don't want to spend time on it, okay? Alright, any question about that? Alright, fine, what if croot's key, so now we are in the case for the croot is not equal to null. Now we are in the case for the croot is not equal to null. So, what if you looking for a key, and you find you have the value that already in your tree, what do you do? So this is the matter of design, here we are going to nothing We are going to let the tree take you need values. What you might do is change the data associated with that key. But for this example, we are gonna oh look keys have to unique and that key is already there, so we gonna ignore this case.  In fact, write do nothing here, and I will talk about it in a second. Okay, otherwise if the key less than croot key, what we gonna do? I don't know what we gonna do But I do know that I should because we are not putting in here. We are not putting the node in this current subtree. I don't know where it goes, but I know it goes in the current node's left subtree So if the key is less than croot's key, then we are going to insert croot's left Insert into croot's left key and data. Otherwise, we are going to insert into croot right. key, and data And you know what I'm gonna to, I'm gonna go ahead and clarify this. So if key is greater than croot's key So clarify that case and completely get rid of this one because we want to do nothing and so we should execution proceed through the conditional never satisfying any of them. That's a good way to do nothing Alright, any question about it? The question is when are we going to connect the node I'm gonna say you already did. Cause it pass by reference Okay, so we are already operating on the node that is passed in I take it from you that it is time to go But I want to know the running time first. Big O of H Right, good, that good enough for me 
Ok we should work Ok can you hear this if I talk like this? Yes you can Mute? No. Hey Tim, can you come here a sec So I feel like my fingers are not capacitive. Can you push on this arrow and see if it will interact with you? Alright I hear the echo Alright, so MP5 is out. MP 5 is my favorite MP because the bang for the buck of all of the MPs - the bang for the buck for the code that you write is the highest That is you can write extremely elegant code that ends up not being very long and when you write code like this Your de-bug cycle is shorter So a lot of your time spent preparing to finish up MP5 A lot of your time spent working on MP5 is going to be design time Like, what the heck is a quad-tree? And what the heck does it have to do with a collection of pixels? So you're gonna spend a lot of time working on it from that perspective. And once you gain that understanding, the code that you end up writing is quite elegant. Ok, I want to get us to a common point today, and then we are gonna try to do something new Oh, I know one thing -- I'm gonna announce Exam 2 on Wednesday. So I'm not going to write it up here now - there's no room! Well, I'm not going to write it up here now, but remind me to formally announce the  second exam on our next meeting. Ok, Mike, yeah? Oh yeah - MP5 is recursion. It's a tree MP - so duh! Ok Um Let's get started. So we were implementing an abstract data type called a ...
An abstract data type called a...there's a hint on the screen...dictionary. The Abstract data type that we were interested in was called a dictionary. Here is the functionality of a dictionary we need to be able to insert into it given a key. Insert into it given a key and data. We need to be able to remove elements from it given a key Find elements given a key and returning probably the key-data pair Probably that. And then of course we want to be able to see what things we have in a dictionary. Though this is a gift This is a gift not necessarily part of the original abstract data type.  This is by convention is really nice when a dictionary gives you the ability to get all of your data out of it in some efficient way. So we are talking about implementing dictionaries. What was the particular implementation we were working on? what was the particular structure we were using to implement dictionaries?  Binary search trees that's right. Here's an example of one and I think a quick glance will remind you of that thing, okay? Now, inside this class dictionary, which is templated to accept a key type and a data type.  I have sort of spelled out the necessary components that we needed to implement the dictionary using the binary search tree.  But, oh and going along with that, I asked you to just please accept that the contents of each node were keys, and that the data is hiding somewhere behind the node.  Then our focus became manipulating the structure based on their keys, okay? And we got most of the way through this little list of functionality here.  We did traversal a few days ago, we did inserting and finding in the structure.  And today we are gonna focus on remove it. Now at this moment I'm gonna stop talking about dictionaries per se.  And focus on the implementation. The rest of the code you are gonna see today, instead of being class dictionary,  is going to be class BST. And I'm not gonna focus on the data.  But suffice to say what we do in forms what might be actually a private member of a dictionary class.  So you might say that the dictionary contains, or has a binary search tree at the root of its implementation. Okay it's just a slightly different design. Another motivating factor for this was that I forgot to templatize the data in all the code that I wrote for the rest of the day.  And we don't need it for what we are talking about so I got rid of it and we are gonna focus on the keys.  That's all.  Alright, I want to do a little bit of review, and this is actually one of my very favorite moments.  If I can pull it together here. So this is a web page but it might be just an image of one, apparently.  Let me see if I can get it.  (trying to open up the web page)
You're going to love this as much as I do. So, this applet as a teaching device is extra awesome because it has sound. Alright, so, is this a binary search tree?  How did you check?  What was it that you checked, somebody raise their hand and tell me how they checked, there are a couple right answers here. Okay excellent, so taking a quick glance and making sure that the ordering property held, that particular strategy worked because the way that the tree was drawn was good.  Whoever laid out this tree didn't happen to missplace their nodes, which they could have done, so how else could we check? Good, so an in order traversal of a binary search tree gives you the elements in order.  If you do an in order traversal of this thing they will be laid out in order. That is something that is a tying together of your experience with isOrdered from the lab from last week.  Also it's binary search tree day and it'd be crazy for me to pull up a tree that wasn't a binary search tree. Okay so I'm going to insert into that tree a value that is 74's left sub tree. I want a node there, how many different unique values could I put there? Raise your hand with the answer... I should be seeing a bunch of bunnies (2). Okay, somebody tell me one of them. 73, okay... and insert... (animation plays).. YAH!  I'm telling you the sound really matters doesn't it? Okay fine here's another question for you, I want to know how many nodes will be looked at, that is how many bounces will occur in the search for key 40? k so I'm going to do a find of 40 and I want to know how many nodes will be looked at. Okay, so let's do a find on 40
Find one two three oh there it is yeah It was there right? Ok, three  So notice this is pretty cool it did have to examine the entire tree in order to determine whether or not it is already in the structure Ok? All right all question? about it? Ok, so whisper to ur neighbor   em..a value that could be 48's right child 48's right child Whisper to your neighbor Ok blank All right fine Done? Good, all right any questions about this I am gonna come back to this applet in a minute Ok ok Ok present Noooo Please What if I say please good Ok All right Ok So the only one of the major function associated with the dictionary class and with binary search tree implementation of the dictionary class we talked about is removal And I wanna spend a little bit time in fact all of the day, the entire day talking about removal Who knew it was so hard because actually inserted find pice of case Ok well I gonna go head and write the code for remove And I did so by cutting and pasting by cutting and pasting from insert And what I take from it , well, only, I only took recursive sub structure of the problem itself right?  I only took the piece of the code. I essentially took the piece of code that rises an artifact  of the definition of a binary search tree that is a base case we can argue a little about what that should be but the base case I guess it is more like fine not em.. insert.. em what to do if we are if the thing we are looking for the thing we are trying to remove is less than the key that is  key in the current node Or what to do if it is greater than the key in the current node Okay? Any question about that So we got equal to less than and greater than here any question about it? equal d That can't be right. right? I don't know what I mean I think this is supposed to..Let's see I should fix it. this is d, there Now, fixed I don't know Ok Why? I just call the key d instead of K That variable naming but at least now it is consistent all right fine This is what you want K, K, K K Is that make you happier cause kkk, key, instead of kkk k fine, whatever all right do I have a right now? yes ok thank you there are no brains ten feet twenty feet maybe here no brains at all all right so what is so hard about this this can't be hard. look it just inline of codes. we have seen those code before the issue is what the hack do we do when we do the removal Okay? So, I don't wanna think about exactly how to make the remove right now how to make the remove happen right now. So I am gonna push it off into some other function to be thought about latter now notice what this does from a software development perspective  If I write a scalaren function do removal that is if I have stub and have a a return. whatever I want   Then I can then I can pass this function without yet ever even have to implement this one Ok, so this idea of decomposing our you know seemingly maybe difficult task into this you know separated function   is something that gonna actually improve our quality of life our debugging processes which related to our quality of life Ok, why is this so hard why is this one linear kind of like find is  Em well
I look at this tree and something that are super easy to remove. what are the keys that are easy to remove. the leaf that's right the keys are easy to remove because..the leaves are easy to remove because w how to find .e know..walk down the tree we can find something and if it is a leaf we simply snip off,right? ok so lets...well we will do that in a minute. so this one is easy any questions about that? we look at both code and example to see how this work in a second. which one is a kind of easy. what could be a node that does not seem to be that hard. discuss with some person sits next to you really quickly. leave nodes that are easy what is also not terribly diffi ok out of you discussion somebody raise your hand and explain to me why removing 25 will not be too difficult. why would we remove... very good notice that this string right here this sort of pieces of trees this is just looks like a linked list, right? because there is no branches to deal with in that context you already know how to remove things from a linked list. so removing 25 or 10 or any other nodes with that many children it is pretty easy so this one is  kinda easy but different  it is a different process on the other hand the heck all right what i wanna do is how do i switch apps like can i get back to my browser right now  swap from left side screen so like this one finger to three ten hoo hoo ok i think i can get back  one finger i am gonna show you how to do this two child removes i want you to watch closely i am gonna do it fast first and then i want you watch closely to what happens to see if you could articulate what  going on . but before we .... do this it must drive real windows uses crazy how like in particularly with the whole thing 71I want to remove yeah right 71 and delete it are you ready it is going pretty quickly i will slow it down in a minute but i want you ti see it  we found it what happened could we put something back there? we are gonna to insert...it does not have sound i am gonna plug in that i cannot help it it is full sensory experience ok now just to give you the feeling for you know what i am gonna do really radical  here. next we are gonna insert ...oh  it turn out i am gonna insert 41
Oh...I don't know....okay.  Okay?  And now I'm going to...keep in mind, I'm gonna say something first, before I actually...oh, does that mean it's working now? I dunno.  Ok I'm gonna do this.  Alright just a minute...soo keep in mind that what were... Im gonna remove 48, but this could just be any two child nodes in some larger tree, right? Like this is just some subtree. So I'm gonna not remove 26 for example and I'm gonna not remove 74 because I want you to have a bigger context in which to see what's happening, But I want you to remember that it might just be above 48 there's this humongous binary search tree of which this is just a little part. Alright, so I'm going to, I'm just gonna do this once and then Ill turn it off I promise....ok nevermind sorry I didn't have you sign the auditory stimulation waiver today, so I cant be too mean to you. Alright, 48...delete. Are you ready? Maybe I should slow it down. I cant read it...More options????? The interface needs to be better. Animation speed???? Go down....Kay, and bound type is fine, node size fine...tree size? I'm gonna make the tree bigger. No...reset...NO? No ok this is dumb....Alright close?? Alright now?? AUGHGHG of course.....Im sorry, sometimes a keyboard would just really be nice. 48....and delete. You ready??? Got it? Did you see what happened?? Okay!  Soooo what would happen if I did delete 36? What would happen? 32 would come up, that's right! Very good! What would happen if I deleted 74?? 73 would come up. What determines which one comes...which one swaps in? Its in the left side and it is...its the biggest one on the left side.    Okay we have a special name for it, its called the in order predecessor. Now all of the convers....I'll write it down in just a second, Any questions about it do you want to see it one more time?? yes??? YES!!!  you want to tell me what that other way is???  Yea sure we have a name for that too, its called the in order successor.   Yeah? Is your question too yes. it was an arbitrary choice to choose the biggest one in the left subtree to swap up there we could have chosen the one in the right subtree instead. The key observation is when you do an in order traversal of this tree, the order is not ruined. The order of the tree is not ruined, but by removing an element and replacing it with the one whose value comes just before it, the question is where in the structure does that occur?  So let's go back...okay. Look at this....oh I don't have to I don't think...I can do this right??? haha there.  This is kinda easy...Alright! So remove 13. We have seen the idea of in order predecessor, it is the max element in the left subtree. 
and we commonly refer to it as the IOP, OK we also have a notion of in-Order successor which we refer to as the IOS and it is the min element in the right subtree now I have a very very subtle question for you OK, we're talking about removing, we're talking about the algorithm for removing a node with two children OK. We're talking about the algorithm for removing a node with two children. Do I have to worry that the in-Order predecessor does not exist? Do I have to worry that the in-Order predecessor does not exist No! Because I am always removing a node with two children, OK. So I don't have to be kinda crazy with my error checking, right? My task defines my tas..  my task as it is defined makes it so I don't have to worry about that they are not being an in-Order predecessor I wouldn't be doing a two-child remove if they weren't one OK. Alright, any question about that? OK. So what is this code going to look like, it's going to find the in-Order predecessor it's going to actually swap keys which we don't like very much, but we're gonna do it anyway. Keys aren't that expensive, they are not usually that huge of data items. So, we're going to swap keys. So one, find IOP. Two, swap keys.  Three, remove IOP OK, snip it off. Any question about it? Do you guys ready to write some code? Alght write some code OK, so notice that the function that I wanna write is doRemoval. OK, and that's what I refer to in a recursive skeleton Am..  and it assumes that I am passing in the node in the tree that I wish to remove and moreover, I handle on it that exists in the tree. So, for example , if I'm doing a two-child remove of 38, croot is not a copy of the pointer holding on to node 38. It is a name, another name for the node... the pointer to the node containing 38, OK. Similarly, if I do a two-child remove of 13, and I make a change to croot, I am changing 38's left child. And that is accomplished because I am passing the whole thing by reference. That's the intention here. OK. Ahh... one, no, one, two. The blanks contain the values no, one, two. You fill them in. Real quick, take a look at the code, you fill them in. What you get? I would hand you my thing, but I want you to have sounds so I am not wireless today. What did you get? What's the first blank? No child remove, very good. Because that says both of the children are NULL What's the second one? Two, good! And the other one? One, good. OK, why did I do that? Why did I do that? It doesn't go one, two, zero, one, two. Ahhhh... Why would I do that? Yeah?
Yeah, look, think about how messy the boolean would be, it would have 2 cases, for testing just for 1 child. Screw this, this is all the other cases, and those 2 are super easy. So when you're doing this, when you're evaluating a collection of booleans whose union is all the possibilities, take your most complex one and make it the else.    That's the easiest way to go about it. Any questions about that? Now look what I did here. I took due removal, and said oh my gosh", this is a huge task In fact it's a task that I don't want to think about all at one time. I'm going to break it down into these 3 little things. The first two I'm going to think about are these two. Because both of them are easy and kind of easy. So let's write the code for them real quick. So here's no child removed, and I'll just trace the code. I'm going to do a no child removed on this pointer, is that okay with you? I'm going to remove 12 and illustrate what the code does. It grabs hold of this, with temp, it sets cRoot = null, so this pointer is now gone and there's a null sitting here, and then deletes temp. So the end result is a null sitting where that whole thing used to be. Any questions at all about that? If I just said delete cRoot, cRoot = null, oh I probably could huh? Delete cRoot, cRoot = null Oh yeah that would be fine. I was probably on auto pilot here, which says grab ahold of something for deletion. I was probably on auto pilot here, which says grab ahold of something for deletion, that's all. I hate it when people come up with more elegant code than I do, I hate it. Alright, any question about it? Let's do 1 child removed, and maybe the same issue will exist here. So where is a 1 child we can remove? Looks like 25 is good, I'll do this one in green so we can illustrate it. So here is cRoot coming in, and we're going to remove 25. So the thing is that I don't have to, that I will already have found it back here, because cRoot = key here, and then I'm going to pass that through to here. So I will already have a hold on exactly the one I want to remove, and I have it by reference, so I can kind of be changing the parent as I go. Now, we could argue a bit about whether this is good style. What is does do is it keeps an empty tree from being a special case, that's why I'm going to leave that right there. So let's do this 1 child remove. Oh, again! It's not a lot of code, let's see if it does what we think it should do. So the first thing I'm going to do is grab hold of the node that I'm eventually going to remove. And then, I'm going to either reset this pointer, the 13's right child, effectively to be 25's right child or 25's left child, which ever one exists. That's what that conditional is doing. And in this case, it happens to be this assignment statement that goes. Because 25's left child is null. That means that in the end this one points there, or 37 gets kind of drawn up, and now I do delete temp.  You like it, does it seem good? Well that was easy. It was even better than kind of easy. Alright, you ready for 2 child remove? Don't peak, how many lines of code is 2 child remove? It must be really hard. Because, you got to do all this stuff, and you got to do all that stuff.
Three lines of code. Yeah? OH maybe. It might.. I don't know. Do you want me to go back and actually pursue that? I don't know if I believe that. I will look at it. Alright, fine So what's going on here? I'll give you a hint -- this code has a big bug. But it's not one of algorithm. It's one of implementation The algorithm does exactly what we said We are going to call the right-most tile of cRoot's left We are going to call it the IOP We are going to grab hold of it, as the IOP Then, we're going to swap the key from there up into the root So that seems okay. And then we are going to snip off the IOP And I know how to snip things off You just call doRemoval doRemoval will figure out whether it is a one child or a no child, and will do the right thing I already have a function to take care of that part Any questions about this? Yeah? No, doRemoval doesn't. doRemoval only looks to see how many children there are It just looks at the pointers - the left and right pointers. Ok? If you look, you have it on there Or I could go back. It's three slides ago Yeah? Where do I move the data. Oh yeah, so that was my initial thing We were talking about dictionarys, we're now talking about dictionaries We're focusing on the keys. We would move the data at the same time Hopefully we have a reasonable way of referring to the data so it doesn't incur a huge cost. It's a valid concern, but not a bug Ok, what's the bug here? Ready? Yeah? Good So what he said was, since you're passing by reference Since doRemoval takes something by reference It's gonna change exactly the pointer IOP But that's a local variable. Who the heck cares what IOP is It's a local variable, It's gonna go out of scope So I am going to change IOP, but then the effect of that change is really just going to break my tree So I'm gonna trace through that with you carefully in just a minute But I want to ask you one question first How do I know that this isn't going to incur an infinite loop? With the doRemoval.. Look how did I get to this function It was via doRemoval. How do I know I will not get into an infinite loop with twoChildRemove, doRemoval, Yeah? It doesn't have to be a leaf node -- That's not quite true It's almost true, and in the right ballpark Yeah You know IOP doesn't have a right child. It might have a left child Because those values are less. But it can not have a right child, because a right child would be bigger. And we're getting the biggest key in the left subtree Alright, so we don't have to worry about infinite loops doRemoval is going to end up taking us into no-child or one-child remove And I'm letting it diagnose which one, because I don't want to think about it I don't want to write anymore code to do it So now, let's trace this through and track down the bug Ok, sooooo I'll put  We're going to remove 13 and I'm going to put node 11 off here Just so that you believe me that the IOP isn't necessarily a leaf And, I'm going to do a removal of 13 TwoChildRemove of 13 So what does this code do? It goes and it assigns to variable IOP The rightmost child of cRoot's left. I don't know what that does But, it better give me IOP pointing here Do you see the problem? IOP is just a variable and I'm assigning to it a value It's not another name for something in the tree Now, when I do doRemoval of the IOP This thing right here is going to point to 11
This one is not, it's still gonna be hanging off clinging to memory we have deleted So That's the bug, do you see it, and it's all because IOP does not refer to one of the pointers in the tree, there's a couple ways of fixing this, we could rightmost child again here, uh c root's left but that feels wasteful right We could find it again and pass by the reference to it so we're holding on to it or this is something new, this is a new thing, but it won't surprise you, we can declare something  to be a reference variable. And i'll put this in a different color ink. We can declare something to be reference variable and if we do that then it becomes another name for whatever it was  that we assigned to it so then in that case, IOP would be a name for that variable in the tree So reference variables behave exactly the same way as reference parameters do okay yes, yeah Oh I don't have to swap, I don't have to do the swap 'cause I'm just gonna cut the other one off Right That's fine though because do removal takes, it doesn't care about key value At that point, it just says it just concerned with structure We've already said I want to remove you, we've already done all key evaluations That happened here, way out here Do removal is after we've already identified which one we want to remove okay does that make sense  Okay, alright, any other questions about this Okay, fine Uhh, what slide number is that, so second to last one Okay I have a question for you, what's the running time of this function of remove What's the running time of remove  And as you reflect on this answer Oh it isn't oh there's one more right okay We're not quite done, not quite done there's one more function right We need to write the code that gives up the rightmost child of the left subtree. How many lines of code is this one gonna be Uh, my question for you is is it code that contains a keyword that has a w"? Like while? so raise your hand if you automatically would think to write this thing recursively Okay, yeah me too the people always yell at me for it Uh so if the right subtree is already to null, then we found what we're looking for Otherwise, we're just gonna keep walking down the tree okay So, there you go, and what you should notice from this is that we are returning it by reference so that The thing that came in is actually going to be the handle on the thing that came out That's why it's okay to assign IOP to it It's not a copy to begin with it's actually in the tree And I'll leave that to you to untangle and goodbye  Oh what is the run time? Big O of h, big O of the height of the tree, we'll talk about it next time Uh let's see so you wanna know
Ok, so Mike described what Mike described was that oh please let me write on my screen. no it won't let me. Ok. what mike described was that 36 would be swapped up in place of 35 and the order of the values would not change. so so we had this small local set of data. so if i wrote down all the data in the tree in order, it would have looked like this. 23 35 36 54 74 etc. so if I had written down all the keys in the tree they would've looked something like this. now our goal was to remove 35. what we're saying is ok fine, go ahead and remove 35. we can do that if we either sort of let 23 or 36 take its place. ok. now we have special names for these things. the name we have for 23 is the in order predecessor. and the name we have for 36 is the in order successor. and these are in the slides from last time. now, you can't read this I'm sure because I can't. if you look at this applet and you go look at the menu you can choose whether or not you want to do a removal using the in order predecessor or in order successor. so this is recognized as a design decision that you're going to make. now I made the design decision to use in order predecessor because the textbook I used to use used in order predecessor. textbooks on data structures are about evenly split between IOP and IOS. but both of them are kind of wrong. because the consequence of always using one or the other if you're doing a lot of removals is that you get a tree that's kind of lopsided. if removals always happen from the left then the trees going to be heavier in general on the right. so you end up inducing an imbalance in the structure just by virtue of the mechanism you use for removal. real algorithms to do this would probably swap back and forth between in order predecessor and in order successor. yes, quickly. maybe. maybe. some definition of balance would come into play. it might be the height of the other subtrees and there are other metrics on trees you can use to assess the size of a subtree. k. balance almost always means that the sizes of subtrees are approximately the same. the question is how is size defined. is it height, is it number of nodes, is it some other metric on the size of the tree? that's for discussion and um. ok how is it? is it one finger if I do this? no. huh, yes. ok look. this is great. k. but I don't know why, ok fine. whoo, whoo, ok, fine, whatever. ok, any questions about all that? so I just wanted to remind that you that applet exists. i think i find it particularly useful. we'll use it again. ok, um, running times so we're talking about implementing dictionaries using binary search trees. so far any time we talk about implementations we're responsible for arguing about the efficiency of that design choice. that implementation choice. right now, this moment, the only thing we have right now to argue the running times of these algorithms are we we know they all use the height of the tree. they all traverse the height of the tree. they all walk down in the worst case. in the worst case the height of the tree is going to determine the running time. any question about that? alright, and then traversal of course just by way of reminder is big o(n) the amount of data in the structure. so, let's see. i want to know, this is just a little bit of practice. i want to know what this tree looks like. so really quickly declare my t to be a binary search tree. and go ahead and on paper, as quickly as you can implement that sequence of inserts. ok. will you do yours on my tablet? it doesn't matter you can make as many mistakes as you want. ok. so everybody do this, just build the tree really quickly. insert into the binary tree several times.
OK so what mike describe was that
Okay how do you feel about this. What does that look like, especially if you do okay so, look at the screen and rotate your head in the horizontal plane by 45 degrees. What does that look like? A link list? That's right. This thing is a linked list. Which means that, there are binary search trees whose performances really no better than a linked list. What was it about our data, that made this happen? Yeah Nathan? Yes, the data was already in. The insertions happened, now... this is a cautionary tale because a very common way of creating these structures from the start is to build them up incrementally, take data one at a time form some data source and build them up. It's also very common to store data in a sorted fashion so it's very possible that if you were to say to somebody, give me your data, I'll build you a binary search tree, and employ this algorithm, you would end up with a poorly behaved tree just because your friend happened to be helping you by giving you the data in order already sorted....does that make sense? SO, one thing you might do then, is anytime anybody gives you data, jumble it up. Mess it up. Create disorder. How many times in your life, has anybody in your life that it will help if you create disorder. Almost never right! Well, maybe it would here. We'll quantify that, but so here's the thing. It's easy to look at data and tell if it's in order, but these are not the only bad trees it's not just you know, either an increasing sequence, or a decreasing sequence, of numbers, that create a long skinny tree like this. Here's a tree, binary search tree, who knew!? Can you see it? There's the root, right child, left child... What I want from you, but this is a little harder, is a sequence of inserts that result in a tree that looks like this. Who would like to do it on my table... I want a sequence of inserts that create a tree like this, I'll assume they are in order. Can you all see this sequence of numbers results in..
A tree that looks like this? Now, when I look at that, it's a little harder to distinguish the fact, sorry, that there have been some sort of-- that there is structure to the numbers themselves, right? This isn't, you know, uhhh, I guess there's an increasing sequence, but it's very-- it requires a very particular decreasing sequence going the other way, kind of. Right? So, it's easy to say, yo, do not give me data in sorted order. But it's a little harder to say, make sure not to give me data that looks like this, cause I don't even now necessarily how to describe that. And yet, it made what looks like, kind of a bad tree, right? Like this linked list-y kind of tree. Any question about that? So now I have a question for you and this is a harder puzzle yet. I wanna know, how many bad n-item trees are there? K, so we agree these are bad trees, or at least they're no better than linked-lists. Um, I wanna know, if I have n pieces of data how many of those-- how many trees are there that look like this? [gibberish] We could do this remotely-- like a remote control thing, right? Like, I could say, and you can write, and... Are you working on this? My hint is to draw a few of other bad trees, and maybe to just kinda start counting them and think about it combinatorially with a picture. Yeah? Uh-huh. Oh yeah, sorry I'll do that. It's one, six, two, five, three, four. Does that make sense? So you insert one, that becomes the root. You insert six, it goes to the right. You insert two, it goes-- it's greater than one but less than six. Does that make sense? Yeah? And then you insert five. It is greater than one. Five, we're talking about five, k? Now where does five go? I don't know, but it has to go greater than one, it has to go less than six, it has to go greater than two, right? It would probably help if I drew this more like this, right? Like... right, like if this-- here's one, here's six, here's two, here's five. Okay. I should have-- I should have done it... Should have been more careful. Okay, anybody have any ideas for how many BAD n-item trees are there-- there are? So, I've got n pieces of data, I don't really care what they are. say they're the numbers one through n. I wanna know how many of these long straight trees there are. Yeah? 2^n?! Where did you come up with that? That was pulled out of the air! ...Was it? [laugh] Now where'd you come up with that? It's correct, I wrote it down. It's correct. So, where did that come from? Yeah? Oh, actually it might be 2^n-1. Ohhhhhhh! [laughs] Okay, where does that come from? Yeah? Yeah? Uh-huh.
A tree that look like this, now when I look at that, It is a little hard to distinguish the fact that there has been some sort of, there is structure to the number themselves, right? This is a, I guess, an increasing sequence. But it requires very particular decreasing sequence going the other way. So it is easy to say, you, do not give me data in sorted order. It is a little harder to say, make sure not to give me data that looks like this. Because I don't even know necessary how to describe that. And yes, it made what looks like bad tree, right? Like this linked-list kind of tree. Now I have a question for you. This is a harder puzzle yet I want to know how many bad item tree are there. We agree this is a bad tree because it is no better than linked list. I want to know if I have N pieces of data, how many trees are there are there that look like this? My hint is to draw a few of other bad trees. And may you would just start counting them. Think about the combinatorial of the picture. One, six, two, five, three, four. Make sense? You insert one, that becomes the root, you insert six, goes to the right. Insert two, goes left. Then, you insert five, greater than 1, less than 6, greater than 2. It would probably help if I draw like this. I should be more careful. Anybody have the ideas for how many bad items three there are? I got N pieces of data. I don't really care what they are. There are number one through N. I want to know how many long string tree there are. Where do you come up with that? It is correct. I wrote it down. Where does that comes from? Actually, might be 2 times N minus one. Where does that come from?
A tree looks like this. Now, when I look at that it's a little to harder distinguish the fact, sorry, that there has been some sort that there is structure to the numbers themselves right? This isn't, you know, uhhhhhhhh, I guess there is an increasing sequence, but it's very, it requires very particular decreasing sequence going the other way kinda right? So it's easy to say yo do not give me data in sorted order. But it's a little harder to say make sure to not give me data that looks like this, because I don't even know necessarily how to describe that, and yet and made what looks like kind of a bad tree right? Like this linked listy kind of tree. Any questions about that? So now I have a question for you, and this is a harder puzzle yet. I want to know how many bad n-item trees are there? So we agree that these are bad tree, that are no better than linked list. I want to know if I have n-pieces of data, how many of those how many trees are there that look like this? Ok, I take it back. We can do this remotely like a remote control thing. Right? Like I can say and you can write. Are you working on this? My hint is to draw a few other bad trees and maybe to just start counting them and think about combinatorial with the picture. Yeah? uh-huh, oh yes, sorry. It's one six two five three four. Does that make sense? So you insert one that becomes the root. You insert six and it goes to the right. You insert two it goes it's greater than one but less than six. Does that make sense? Yeah? And then you insert five it is greater than one. five. We're talking about five. Now where does five go? I don't know but it has to go greater than one. It has to go less than six. It has to go greater than two. Right? It would probably help if I drew this more like this. Right? Like this here's one here's six here's two here's five. Ok. I should have should have been more careful. Hey, anybody have any ideas for how many bad n-item trees there. So I got n-pieces of data, I don't really care what they are. Say they are the numbers one through n. I want to know how many of these long straight trees there are. Yeah? two to the n? Where did you come up with that? That was pulled out of the air. Was it? hehehe. Now where did you come up with that? It's correct. I wrote it down. It's correct. Where did that come from? Yeah? Oh, actually it might be two to the n minus one. OHHHHHHHHHHHHHHHHHHHHHHHHHH. HAHAHAHAHAHAHA. Ok, where does that come from? Yeah? Yeah? Uh-huh.
Ohhhhhhhhhhhhhhhh. Ok. So notice when you're building these trees that you are making a sequence of left-right decisions. You are making sequence of left-right decisions, right? The first thing is always going to be the root and then you're going to decide whether the tree is going to have the, uh, whether your next data element is going to be something smaller in which case you go to the left, or something larger in which case you go right. So, it's simply each one of these tree is simply a, uhh, a sequence of decisions of whether you go left or right. To re-enforce that, I can write down right left left right right right left. I can write down n of these and it prescribes a tree. How many choices are there? Well there are n minus one choices. There's one for each edge here. There are n data elements n minus one edges, and there is a choice of right or left for each of those. And so in total it's two to the two time two times two times two to the n minus one times. Yeah? Because, uhmmm, here's how I really do it. For data equal to if n equals two, how many trees are there? How many trees are there for n equal two. two right? So this is how I really do it. I go oh gosh if it were two to the n that would be four. HMMMM. It must be n minus one and I check that out. I'm serious. Simplify your problems. Always simplify your problems. Ok, so two to the n minus one. Also, recognize that the data is the number of nodes, but the decisions for where the tree goes are edges and there are one fewer edge there's one fewer edge than yes. Mike? Oh yeah, this is a tree. oh yes, this is definitely a tree, no cycles here. Oh what is it? Rooted. hehe. A connected, acyclic graph that is rooted and ordered and binary. Ok, Alright did you have another comment? ok. Alright, anything else here about this? Alright. I didn't know I didn't plan. Alright. Is this a big number or a little number? A LOT. This is a lot of bad tree. Which means that it means that we really can't count on the order in which the data comes at us to use as a criteria for building these structures. Right. If we just build this structure using this strategy, but okay I'll just enter into it whenever you give me data. It's possible. It's possible that you know that we're gonna get a bad tree, and that height that the algorithm insert remove and find will take us a long time, because we have this tall tree. Ok? Alright. Well, uh. We should quantify this. We should quantify this.Ok. Alright. So, here's what we're going to do. We're not happy with Big O of h for running time, because people who listen to you argue about the efficacy of your algorithm always want to hear about there running times in terms of the amount of data your structure contains. So the analysis, whoops, the analysis
The analysis or the argument about how good the algorithm is should be in terms of N, so we can make these arguments if we understand if we keep completely understand the functional relationship between H and N. Now here what we are going to do. H in this context represents the running times of our algorithms, so H is a running time, it is a stand in proxy for the running time, we recognize that it is you know, is some constant factor of H. We don't know what the coefficient in front of H is. But what we are going to do is we are going to argue that H is at least this much. As a function of N um, uhh, for running time, the running time is at least this much as a function of N. Now what does that mean we are doing, we are in official terms putting a lower bound on the running time of an algorithm and we are saying that if someone comes to you and says they have a better algorithm. That is, they say they have an algorithm that is less than whatever we come up with for f(n) you go NO! Thats not possible, you're algorithm must not work. Because no such algorithm exists, thats what a lower bound gets us. Lets see. No algorithm can do better. Can have better worst case performance, alright but at the same time, at the same time, we need to argue about the relationship of the running time on the top end. That is we want an upper bound on the running time, because that, in fact we say a tight upper bound. Because thats actually the currency we use to argue, which algorithm is better, ohhh I've got a structure that implements a dictionary in constant time, that means an upper bound, in the worst case it is constant time. I have an algorithm that ok, yea. We'll talk more about that in a minute. K any questions about that. Alright so um, as a reminder because we are going to be arguing about height, and because our argument is going to be recursive and need this. Um I want you to remind me what the height of an empty tree is. Do you remember? What we have defined the height of an empty tree to be. Zero. Negative 1. thats right. If that bothers you, if that bothers you remember that the english definition of height is the length of the longest path from a root to a leaf. The english definition longest path root leaf. An empty tree has no root, so this is sort of an indeterminate question in the context of our understanding of heights, so we get to make it anything we want. Its indeterminate, we can make it anything we want, so we chose something thats convenient, that makes this recurrence work well for us. Alright any questions about that? All of that. Ok uhh lets see. So it turns out, it turns out we're gonna do this one first and this one second. It turns out that this is kind of a complex, tends to be a complex argument. And if instead we equivalently argue this.
Now you're allowed to tell me the +1/-1 stuff. 2^(h+1)-1. Should I believe him? And that's for h>=-1? Ohh, yeah, look at that, it works. Should I believe him? No, we should not believe him. How do we prove it? Yes, this is like day one induction. This right here, this is day one induction. Super easy! In fact, I'm going to call it Back of the Envelope" induction. Ok? Um, I already eye-balled it to check to see if the base case worked. Did you see what I did? I eye-balled the base case by plugging in h=-1. There, ok, eye-balled, check. Did it break? No, 2^(0-1)=0 m(h)=0 whew! Ok, now what is my Back of the Envelope, super quick, evaluation of the recurrence (the recursive case)? m(h)=1+2* what goes in that box? (2^((h-1)+1)-1) all in parentheses [m(h)=1+2(2^((h-1)+1)-1)]. Ok, what did we do there? We applied the inductive hypothesis, but I didn't write it down; and that's okay. [Gasp!] Don't tell Margaret. [laughter]. Ok, so what went on there, the inductive hypothesis was applied. Ok, any question about it? Is that okay? Raise your hand if you no that's not nice. Tell the person sitting next to you if that's not okay and I won't watch, if that freaks you out a little bit. So, I'm assuming you can be candid with your friends. So, have a minute of discussion, have a minute of discussion, please, like okay, not okay, I can't believe we're doing this, feels revolutionary but okay. Yeah, is Margaret still watching? Oh my gosh! I just asked for class transcription too, shoot! Ok, so, alright, any questions about it? I won't actually get the polls of the class. This is how grown-ups do induction. Ok. Oh, sometimes when it's this straight forward. Okay, any question about it? And it all works out, right, you do the math and it all works out, oh look! I did all that arithmetic in my head. Aren't you impressed? (kidding) Okay, but we're not done. Here's what we know. We know that I'm going to say this in English and write it in math, ok, we know that the number of nodes in any tree of height h is less than or equal to is no more that 2^(h+1)-1. The domain is greater than uh-oh! ok, but that's not what that doesn't say anything at all about our algorithm. Right, that's not what we want to say, h represents our algorithm, the running time of our algorithm so, all we have to do is invert this function. okay, I'll race you. So it looks to me like this one goes to n+1 oh I'd better take the log of that and then subtract 1 from the whole thing and I have h>=log(n+1) a constant here. ok, now how do we say this, how do we say this using the discrete math that we know? We say that h is big omega of log(n). Ok, now do we have all of the pieces? H is at least some constant factor of log(n) right? two of them.
Greater than half a point probably. Yeah, its a lower bound. So you know how big O is like a less than an equal to, big O if you go back and you look at the definition from 173, prerequisite, you look at the definition, big O is like less than or equal to, big omega is like greater than or equal to. And their definitions are symmetric in almost every possible way. Any question about that? Alright. Any other questions about this? So now this says no algorithm, if somebody comes to you and says they have a binary search tree where the key functions work in time less than log (n) say they run in constant time, you go ah then its not a binary search tree, you might be doing something else, it might be a dictionary but if you're using a binary search tree those functions cannot run in time better than log n. Okay. This falls in our world of how tall is the binary search tree in general, hows that logn. Like that is where that conversation goes. Okay, so we did this one we did this one, lets do the other one as well. Now were trying to argue is that h is less than or equal to some function of n. Okay, no matter what. What we what to do is go big here. Okay fine whats the very largest tree we can make out of n nodes. Because the height has to be less than that. Whats the tallest tree we can make with n nodes? I don't wanna ask this question its stupid. Okay. Whats the tallest tree we can make with n nodes. N-1, right. N-1. Tallest tree is N-1 so in general if you have n nodes, the height is always going to be less than or equal to n-1. Okay so if you take n nodes and you look at all the possible trees you can, none of them is going to have height greater than n-1. So look, again we got a close to something that looks like a definition from cs173 in this less than or equal to. So instead of less than or equal to, we are going to write it is big o of n. Where we ignore constant factors and we roll the less than or equal to card into that symbol, into the definition. Alright so is this good news or bad news. Bad news right. What if we did this same argument about linked lists? We did the same argument about linked lists, we'd have the same result, so we should all be sitting here thinking we should all be sitting here thinking well binary search trees really aren't all that good then, shoot we had so much fun, and its not important to us. Okay well it turns out the following is true. If you consider
of n keys. Again this is 173. Most people say 173 is a reasonable prerequisite. Alright but here is the cool thing. here is the result. you're ready for the result. If you take all the n factorial arrangement and you builds trees from a tree from each of them and then quanitify the heights so this is one would be 1 2 3 4 5. This is one has 5 and this one has height 2 and you take the average over all of those, you get a result that is bounded by. What do you hope by right here? log(n). you get a result that is bounded by log(n) and so that's good. it means that random trees are good trees. if you have a reason to believe that you data is inserted in an arbitrary order then you have hope bigger height of your trees not too bad so that's good news. we could fill in this table but I'm going to leave it to you to do that because i want to talk about something else that's more interesting. you can do that offline you can do it on piazza if you want because I want to talk about this. i want to talk about desert. I have here two trees that contain the same data. two trees that contain same set of keys. which one do you like better? the one on the right. right? okay so the way we're going to describe this as we go forward is we prefer trees that look like mountain to trees that look like sticks. so that now though we can rely on our affection for mountains or sticks, instead we have to quantify. we have to give our selves a way of differentiating between things that we like and things that we don't like. so we gonna define a metric on a the root of subtree so this the height balance of a tree so tree is any. it could be a subtree as well so this is true recursively. so its the definition at any root at any subtree, we gonna take the difference between the height of the left subtree and the height of the right subtree and call that the balance. okay? so this is just the difference between subtree heights. okay? so T tree has balance if its an empty tree or tree T is equal to T not empty then its height balanced b that is the balance that it holds is. what do you think this will be? 0 right, that would be perfectly balanced but guess what? we gonna let be a little bit not zero. yeah we gonna let trees a little bit out of balance. every good life has a good balance and not good balance and its this definition then that. this is an example of a definition that differentiates between this tree and this tree. OH! its a recursive definition and TL and TR are height balanced. and that's where we will start next time is figuring out what this balance gets us
of n keys. Again, this is 173 right? All these people that say that 173 isn't a reasonable prerequisite. ukh. I dont know. Alright. umm but here's the cool thing, here's the result, you ready for the result? If you take all of those n factorial arrangements and you build trees a tree from each of them and then quantify the heights so this one would be one two three four five this one would have height 5 and this one would have height 2 and you take the average over all of those you get a result that is bounded by what do you hope I right here? log(n). good you get a result that is bounded by log n. okay so that's good news it means that random trees are good trees that if you have reason to believe that your data is inserted in an arbitrary order then you have hope that the height of your tree is not bad. so that's good news. umm this is a point at which we could fill in this table but I'm going to leave it to you to do that because I want to talk about something else that is more interesting. Okay so this is busy work you can do that offline you can do it on the piazza if you want cause I want to talk about this. I want to talk about dessert, okay? I have here two trees that contain the same data. two trees that contain the same data same set of keys okay. which one do you like better? the one on the right right? okay so the way we're gonna describe this as we go forward is we prefer trees that look like mountains to trees that look like sticks okay that just looks like a stick to me okay like a branch on a tree okay alright so now though we cant rely on our affection for mountains or sticks instead we have to quantify we have to give ourselves a way of differentiating between things that we like and things that we don't like. so we're gonna define a metric on umm on uhh the root of a sub tree so this is umm a height balance of a tree so tree is any it could be a subtree as well so this true recursively its just the definition at every umm root of every sub tree we're gonna take the difference between the height of the left sub tree and the height of the right sub tree and call that the balance. okay so this is just the difference between sub tree heights. okay so a tree t is height balanced if well if its an empty tree..empty trees are height balanced okay or if t is equal to if tree is not empty then it's height balanced if b that is the balance that it holds is what do you think this would be what do you think this would say. zero right that would be perfectly balanced at the same height but guess what we're gonna let it be a little bit not zero yeah we're gonna let trees be a little bit out of balance huuh. every good life has balance and not balance okay and it is this definition then that different this is an example of a definition that differentiates between this tree and this tree. OH its a recursive definition so tl and tr are height balanced okay and thats where we'll start out next time is figuring out what this balance gets us
Count down to the game. Ok I'm gonna start because I have some stuff to talk about first. Ok so raise your hand if you knew this was homecoming weekend. Ok not bad, its homecoming weekend that means there is a parade this afternoon at 5:00 its kinda ohhh I don't know what time. Does anybody know what time the homecoming parade is 5:00 Ok. Every time I've ever gone its a blast. Um its just i don't know its a great day, um if you're gonna go to a football game this season, this is a good one to go to. The teams are evenly matched, at this point at least in terms of record. And it promises to be a pretty festive affair, um yea. So the problem with this is that I hear that our lab dict is um more challenging than it has been in the past, is that true. So here is what I want to say about that laugh, Um I think it is important because I think dealing with an unfamiliar interface is what you will do authentically everyday in your programming life, dealing with new specifications and how pieces of software tools talk to each other. thats a profoundly important skill. Um its also important to understand how to apply dictionaries and to see them as a tool and a resource for solving problems where you might be kind of surprised that they apply. So those two things together make this actually yes a more challenging lab, but also quiet a more important lab. Now all of that said it is not inconsistent that I am encouraging you to go to the football game and talking about how important this lab is, because you can go to the game and work, no no thats not what I meant. No. No. What I want to do is remind you that our labs are designed to be collaborative, so don't try to do this lab by yourself, don't sit in your dorm room or wherever you chose to work by yourself, trying to crank through this lab, find a white board and a friend and go get it done. Okay, that amount of code you have to write is not a lot, so find a white board and a friend and work together and talk out this lab, because that is when learning, thats when learning happens. Alright any questions about all that. I am going to the football game because we have to go to out of town this weekend, but otherwise we would. Okay. Alright okay, at this point we are into the second half of MP 5, i think nothing about the announcements here surprises you. Ohh the second exam is coming up but still almost two weeks away. So it'll be on Tuesday night November third. Okay. I'll put that here, exam two and I'll put it in red, because you know thats what we do with exams. Okay. And it may 7:30 to 10:30 I don't remember the room reservations, if we don't get the room till 7, we won't start the exam till 730 ish. Okay so last time we were talking about binary search trees and, we sort of have this emotional journey between kind of being disappointed in binary search trees worst case performance. And being encourages by the fact that, on average, though, if you average over all possible binary search trees, that you can build from a collection of data, that result is not so bad. That in fact the average height of a binary search tree is logarithmic, alright so we started of on this new um, uh, avenue of investigation, one which gave us a measurement of how balanced a tree was, now lets talk about this term balanced. It could mean a whole bunch of different things it could mean the number of nodes on each subtree of a binary search tree, it could mean something that we referred to as a rank of a binary search tree, which is sort of like the largest imbedded perfect tree. The rank, yea the the height of the largest imbedded perfect tree. Just another metric, that will not be on the test, probably. Ohhh. Um, but the one that we are focussing on for now, is balancing via height. So making sure that our search algorithms um, traverse subtrees that are approximately equal in height. Okay, so we define this measurement on a tree, um, which is just the difference in the heights of the subtrees, okay no mystery there. Um, I'm not really, I never remember whether this is L-R or R-L it sort of a matter of low level detail, but you can kind of debug when you need to but, uh, so so if you ask me I'll probably look at you empty, with empty eyes uhhhhh. Its the difference that matters, the absolute value of the difference. Okay, so this is a measurement on a tree, this is a characterization of a tree. Ok so, this is a measurement I'll fix that
Countdowns the game. Okay, I'm gonna start cause I have some staff to talk about first. Okay, so raise your hand if you knew this was home coming weekend. Okay, not bad. It's home coming weekend. That means there is a [gibberish] on this afternoon at five o' clock, it's kind of... oh, I don't know what time. Does anybody know what time the home coming [gibberish] is? Five o' clock, okay. So every time I've ever gone it's a blast, em..it's just... I don't know. It feels good. It's a... it's a great day. Em... If you gonna go to a football game this season, this is a good one to go to, em the teams are evenly matched at this point at least in terms of record, and it promises to be a very festive affair. Em... yeah. So, the problem with this is that I hear that out lab dict is, em... more challenging that it has been in the past. Is that true? Okay, so here's what I wanna say about that lab. Em... I think it's important, because I think dealing with unfamiliar interface is what you will do authentically every day in your programming life, right? Like dealing with... em... dealing with new specifications and how pieces of software tools talk to each other. That's a profoundly important skill. Em... it's also important to understand how to apply dictionaries and to see them as a tool and a resource for solving problems where you might be kind of surprise they apply. So those two things together make this actually maybe as a more challenging lab but also quite a important lab. Now, all of that said, it is not inconsistent that I'm encouraging you to go to the football game, and talking how import this lab is, because you can go to the game and work... no no, that's not what I mean. No no, what I want to do is remind you that our labs are designed to be collaborative, so, don;t try to do this lab by your self. Don't seat in your dorm room wherever you choose to work by yourself, trying to [gibberish] through this lab. Find a whiteboard and a friend, and go get it done, okay? The amount of code you have to write isn't a lot. So find a whiteboard and a friend, and work together, and talk out this lab, cause that's when learning, that's when learning happens. Alright, any questions about all that? I'm not going to football game cause we have out of time this weekend, but otherwise we would. Okay. Alright, so this point we are into the second half of mp5, I think nothing about the announcement here surprises you. Oh... the second exam is coming up, but still almost two weeks away. So it'll be on Tuesday night, November 3rd. Okay, I'll put that here. Exam 2...and I'll put it in red, because... you know, that's we do on exams. Okay. Maybe 7:30 to 10:30, I don't remember the room reservation, cause we don't get the room until 7, we won't start the exam until 7:30. So, yes. Okay, so last time we are talking about binary search trees, and we have a sort of emotional journey between kind of been disappointed in a binary search tree worst case performance and been encouraged by the fact that on average, though if you average all possible binary search trees that you can built from a collection of data, the result is not so bad. That in fact, the average height of a binary search tree is logarithmic, okay? Alright, so we start it of on this new... em... em... avenue of investigation one which gave us a measurement of how balanced a tree was. Now let's talk for second about this term, balance. I could mean a whole bunch of whole different things. It could mean the number of nodes on each subtree of a binary search tree. I could mean something we have refer to as the rank of a binary search tree which is [gibberish] like the largest imbalanced perfect tree, the rank, the height of the large imbalanced perfect tree. Just another [gibberish], you don't... that will not be on the test, probably. No! Em... but the one that we are focusing on for now is balancing the height. So making sure that a search algorithm, em... traverse subtrees that are approximately equivalent height. Okay, so we defined this measurement on a tree, em... which is just a difference in the height of the subtrees, no mystery there. Em... I'm not really, I never remember whether this is L minus R or R minus L, it's sort of a matter of low level detail, but you can kinda debug when you need to. But, em... so If you ask me I'll probably look at you empty, with empty eyes. It's the different matters, the absolute values are different. Okay, so this is a measurement on a tree. This is a characterization of a tree. So this is a measurement... I'll fix that.
At this point we are into the second half of mp5. We have this sort of emotional journey to be kind of disappointed in binary search tree's worst case performance, and being encouraged by the fact on average though, that if you average all possible binary search tree that you scan build from a collection of data, the result is not so bad, that in fact, the average height of a BST is algorithmic. So we started off on this new avenue of investigation which will give us a measurement of how balance a tree was, now, let's talk about the term balance, it could be the number of node of each sub-tree of a BST, it could mean something that we refer to as the rank of a BST that is sort of like the largest imbedded perfect tree. That will not be on the test probably, but the one we are focusing on for now, is balancing via height so making sure that our search algorithm traverse sub-tree that is equal height. Okay, so we define this measurement on a tree, which is just the difference of the height of the sub-trees. I never remember whether this is L-R or R-L is a low-level detail. So this a measurement on a tree, this is a characterization of a tree.
On a tree... and this one is a characterization... of a tree... that uses that measurement. Okay? So, the... um... the vocabulary is the same, but there's a subtle difference in their application. Alright, so we say that a tree is height balanced if... uhh..if it's an empty tree, an empty tree is height balanced. Umm... or if it's not empty, then, you know, the recursive the recursive nature of this definition says that whatever is true for the entire tree must be true of the subtrees. And, I think, what you wanted me to write here is b=0, but I didn't. I wrote the absolute value of b is less than or equal to 1. So, rather than demanding... rather than demanding that a binary search tree be perfectly balanced, and all it's subtrees, we allow a little wishy-washyness, we allow a little bit of imbalance. And the question is whether that's a big sacrifice or whether it kinda gets us where we want. Uh, any questions about that before we go on? Okay, so... is the tree on the left, ignore the little trees, is the tree on the left height balanced? Okay... I'll say no it's not. It is not height balanced. Now, I want you to find me this sub-the subtree that is not balanced. The subtree rooted at...51, very good! So take a look at 51, at that node. And what you observe is that, you know, the height of the left subtree is 0 and the height of the right subtree is 2. You know, I don't ever really think about the heights of those trees. I kinda eyeball it and look at the difference in the levels. Oh, look! There is a subtree where the left and the right different by 2. So, hence, this tree is not height balanced. Okay? Alright... uh... let's see..So what we're going to do what we're going to do moving forward is... um... take our earlier observation take our earlier observation that we prefer mountains to sticks. And we're going to view the change we're going to view it as an operation on the tree to go from a piece of a tree that looks like this to a piece of a tree that looks like this. Okay? And the piece of the tree that looks like this is going to be based on the observation that this example tree is out of balance. And, by doing some little operation on the very same data, we create a tree that is very nicely balanced, thank you very much. So now let's apply that thought that impression to this tree. Where is the stick in this tree? Where is the stick that we might want to change? Where is the string of nodes all of which play into what might be con- what is an imbalance. Why there it is! Okay? So starting at the tre- node that is out of balance, the lowest node in the tree that's out of balance, because it's possible that there was another node out of balance. But starting at the lowest node in the tree that's out of balance, we're going to observe that anything that looks like this... if we applied this magic operation and just changed that portion of the tree, we could actually change the structure of the tree in a way that... um... reduces the height. Okay? And we're going to talk about how to do that in just a second. Alright, any questions about that? No, there are no technical details. By the end of the next slide, you will know how to do all the pointer assignments necessary in a pointer based tree to make that happen. So, if it feels technically a little mysterious right now... that's perfectly fine. Okay, i have another question for you... um... How would we asses... How would we find 51 and determine that it was out of balance. What would be an algorithm Just kind of a loose description of an algorithm to figure out whether or not 51 is out of balance? Eww, that's a hard problem, right?
measurement on a tree. And this one is a characterization of a tree that uses that measurement. Okay, so the vocabulary is the same, but there are some of the difference in their application. So the tree is height balanced if it is a empty tree. An empty tree is height balanced. Or if it is not empty, then you know the recursive nature of this definition says whatever is true for this entire tree must be true of the subtrees. And I think what you wanted me to write here was b equal 0, but I didn't. I wrote the absolute value of b is less than or equal to one. So rather than demanding that a binary search tree be perfectly balanced and all of its subtrees, we allow a little bit of imbalance. And the question is whether that's a big sacrifice or whether it can get us what we want. Any questions about that before we go on? Okay, so, is the tree on the left height balanced? OK, I'll say no, it's not. Now I'll need you to find me some subtrees that are not balanced. The subtree is rooted at 41. Take a look at 41,that node. And what you observe is that the height of the left subtree is zero and the height of the right subtree is 2. And I don't ever really think about the heights of those trees. I cannot eyeball it and look at the difference in the levels. Look there is a subtree where the left and right is different by 2. So hint this tree is not height balanced. Let's see. So what we are going to do moving forward is, take our earlier observation that we prefer mountains to sticks. And we're going to view the change, an operation on the tree to go from a piece of the tree that looks like this (middle) to a piece of the tree that looks like this (right). And the piece the tree that looks like this is going to be based on the observation that this example tree is auto-balanced. Ant by doing some little operation on the very same data, we create a tree that is very nicely balanced. Thank you very much. So let's apply that thought, that impression to this tree. Where is the stick in this tree? where is the stick that we might want to change? Where is the string of nodes, all of which play into? What is an imbalance? Right there, it is? So starting at the node that is out of balance, the lowest node in the tree that is out of balance, because it is possible that there are other nodes out of balance. But starting at the lowest node in the tree that is out of balance, we are going to observe that anything that looks like this, if we want to apply this magical operation and just change that portion of the tree, we could actually change the structure of the tree in a way that reduces the height. Okay, we'll talk about how to that in just a second. All right, any questions about that? No, there is no technical details. By the end of next slide, you will know how to use all the pointer assignments necessary in a pointer based tree to make that happen. So if it feels technically a little mysterious right now, that's perfectly fine. Okay, I have another question for you. How would we assess, how would we find 51 and determine that it is out of balance? What would be an algorithm, just kind of loose description of the algorithm to figure you out whether 51 is out of balance? That's a hard problem, right?
What? Who's talking to me? Is that you? Ok yes, what's your suggestion, thank you. Ah, okay so you want to write a recursive function to do this right? So write a recursive function that checks to see if these are out of balance, so the code that can check for balance is almost gonna look like a traversal. You can write the recursive code that says, okay, I'm gonna look and make sure my left subtree is balanced and my right subtree is balanced, AND, what else are you gonna check? Because, look, for 51, the left subtree is balanced, right? And the right subtree is balanced? so what else are you going to check? What are you gonna check? If you're sitting at 51, and you've made a recursive call, that came back, oh yep, your left subtree, perfectly balanced, no problem. Your subtree, balanced, no problem. So then what are you gonna do. Yeah? Check if its balanced. At that node what information do you need to do that? Yes, very good. You need the height of this subtree, and the height of this subtree. Okay, so here's what we're gonna do. We're going to augment the information stored in every node with the height of that node. And we're going to maintain that as we do insertions into the structure. Okay, so one of the, a little asterisk about what we're going to do, by way of foreshadowing, is: it would be helpful to store height in each node. We'll talk about exactly how to do that in a minute. This is all intuition. Okay, so, let's do some mechanics here. Um, I wanna change this since I don't like this tree very much. I wanna change the structure of it. I noticed that the whole tree is out of balance right at 50. 50 is the root of the tree that is out of balance. Yes? Is that true? Did I eyeball that correctly? Okay. But, so is 80. So i'm gonna actually focus the code we are gonna write together, the algorithm that we're going to employ, is going to focus on the lowest node in the tree that's out of balance. So here's what I'm gonna do. I'm gonna take this stick, and change it into a mountain. So that means, for that subtree, I'm going to change 90. I'm going to change that subtree to 90, 80, and 99. Okay and now we have to hook things back together. Now where do things go? I don't know for sure but here are my observations. I have one, two, three, four places I can hook subtrees into the original tree. And I have, one, two, three, four places I can hook subtrees into the new structure. That's good. If that were different we'd have a problem. So four places in the old structures, four places in the new structure. And if you notice, in the old structure, we have the following, we can make the following observation. Everything in this subtree labeled A here, is going to be less than everything in this subtree, which we're labeling B, because of the binary search tree property. Which is less than everything in this subtree, which is less than everything in this subtree. And furthermore, the relationships to their parent nodes correspond, and that will be true over here, and furthermore, the relationship to the parent nodes will be preserved if we only put A and B and C and D. Hook them up right here. Okay, so I'm gonna do this. I'm gonna put A here, whatever is in A I'm gonna put there. I'm gonna put B here, I'm gonna put C here, and I'm gonna put D here. Alright, so what is that? I'll do that in a different color so it's easier to see. So 80's left looks like this. B will now be 80's right, so that looks like this. C will now be 99's left, and D is empty. So there's nothing to do. So notice that this actually, for that subtree, for the subtree for 50's right child, we've actually reduced the height of 50's right child. Woohoo! Right, it used to have height 3, and now it has height 2. So that's cool. Now we just build the rest of the tree, just like it was before. We don't even have to think about it very much. 50 is still the root of the tree. 30 is still its left child, and 30 is still the parent of 20 and 40.
What? Who's talking to me? Is that you? Okay, yes, what's your suggestion? Thank you for.. Ahh, okay so you want to write a recursive function to do this, right? Okay, so write a recursive function that... write a recursive function that checks to see if these are out of balance, right? So, the code that can check for balance is, you know, its almost gonna look like a traversal. You can write the recursive code that says Okay, I'm going to look and make sure my left subtree is out of balance, or balanced, and my right subtree is balanced, and what else are you gonna check? Because, look, for 51, the left subtree is balanced and the right subtree is balanced. So what else are you going to check? What else are you gonna check? If you're sitting at 51 and you've made a recursive call that came back, oh yeah, your left subtree perfectly balanced, no problem. Your right subtree balanced, no problem. So then what are you gonna do? yeah? check if its balanced at that node what information do you need to do that? Yes, very good, you need the height this subtree and the height of this subtree, okay? So, here's what we're gonna do. We're going to augment the information stored in every node with the height of that node and we're going to maintain that as we do insertions into the structure. Okay, so [gibberish] a little asterisk about what we're going to do by way of foreshadowing is... it would be helpful to store height in each node. We'll talk about exactly how to do that in a minute, this is all intuition. Okay, so lets do some mechanics here. I wanna change this, I don't like this tree very much. I wanna change the structure of it. Notice that the whole tree is out of balance, right? 50, is the root of the tree that is out of balance. Yes? Is that true? Did I eyeball that correctly? Okay, but so is 80. So I'm actually going to focus the code that we're going to write together, the algorithm that we're going to employ is going to focus on the lowest node in the tree that's out of balance. Okay? So here's what I'm gonna do. I'm going to take this stick and change it into a mountain. So that mean, for that subtree I'm going to change 90, I'm going to change that subtree to 90, 80 and 99. Okay and now we have to hook things back together. Now where do things go? I don't know for sure but here are my observations. I have one, two, three, four places I can hook subtrees into the original tree. And I have one, two, three, four places I can hook subtrees in to the new structure. Thats good, if that were different we'd have a problem. So four places in the old structure, four places in the new structure and if you notice in the old structure we can make the following observation. Everything in this subtree labeled A here is going to be less than everything in this subtree, which we're labelling B, because of the binary search tree property, which is less than everything in this subtree, which is less than everything in this subtree. And furthermore the relationships to their parent nodes are... are correspond to... and that will be true over here. And furthermore, the relationship to the parent nodes will be preserved if we only put A and B and C and D, hook them up right here. Okay so I'm gonna do this, I'm gonna put A here, whatever is in A I'm gonna put there, i'm gonna put B here, I'm gonna put C here, and I'm gonna put D here. Okay? Alright, so what is that? I'll do that in a different color so its easier to see. Alright, so 80's left looks like this. B will now be 80's right so that looks like this. C will now be 99's left and D is empty so there's nothing to do. Okay? So notice that this, actually, for that subtree, for the subtree for 50's right child, we've actually reduced the height of 50's right child. Woohoo! Right? It used to have height 3 and now it has height 2, so that's cool. Now we just build the rest of the tree just like it was before, we don't even have to think about it very much. 50 is still the root of the tree, 30 is still its left child, and 30 is still the parent of 20 and 40.
Circular assignment of pointers. And this particular rotation is one that take the length of the tree and kinda moves it up around ninety for the new root. And because of this dance move, because it's like this and then up it is a left rotation. OK got that? Because it went from this side and moved the bulk of the tree left, and it's shadow dancing. OK so this is a left rotation. So this example is a left rotation. So the way I emphasized that sort of implies there is a symmetric operation called a right rotation where everything. Every left here is replaced with right, every right here is replaced with left and of course having a swap variable before you do that. Um but that the operation itself would be... would... the operations itself would be in that... Operation itself would be analogous. OK. Any question about this? Yes. Ah, very good. When we uh. Well you tell oh this is the perfect time to talk about this actually. I don't usually but this is really good. So I wanna know, in this structure whose heights changed? In fact you can kinda shade it with your pencil, as you're doing it sort of just do a little sketch over the heights in the structure that change in the rotation from this tree to this one. Which ones change? I'm gonna do it like this. OK, so eighty's height changed yeah? Ninety's height changed. Anybody else's? Height is the longest path from a root to a leaf in a subtree. Did we change A? Did we change A at all? We changed where it's located but did we change any of the nodes inside A? Take a look at A. Did we change A? Nothing's different about A at all, so none of the heights of its nodes can change. Yeah. No, yeah we are answering it with the whole tree, I'm not done here. Yeah. Yeah, so did A change? Did B change? Yeah so none of these subtrees had any heights that changed. Uh what about over here, twenty, thirty, fourty, any of that change at all? Absolutely not even participating in this, the rotation, right? OK what else changed? Yeah? Yeah. Oh it happened not to. Yeah, yeah, OK. It's true. Ninety's happens to not be different but might have if the tree had been shaped differently. OK so here's the deal. When you deal
Circular, assignment of pointers. And this particular rotation is one that takes the link of the tree and kinda moves it up around 90 for the new root. And because of this dance move, because it's like this, and then up. It is a left rotation. Ok, got that? Cauz it went from this side and move the book of the tree left. And it shadowed dancing. Ok, so this is a left rotation. So this example is a left rotation. So the way I emphasize that sort of implies that there is a symmetric operation called a right rotation where every every left here is replaced with right. And every right here is replaced with left, of course having the swap variable, or do that. But, that the operation itself would be. The operation itself would be an elegance. Okay? Any question about this? Yes? Em, very good. When we, emm... Well you tell. Oh this is a perfect time to talk about it actually. I don't usually, but this is really good. So I want to know, in this structure, whose heights changed. Okay, and in fact, you can kinda shade it, with your pencil. As you're doing it, sort of, just do a little sketch over the heights in the structure that changed in the rotation from this tree to this one. Which one's changed? I'm gonna do it like this. Sooo, 80's height changed, yeah? 90's height changed. Anybody else is? Height is the longest path from a root to a leaf, in a subtree. Do we change a? Do we change a at all? Do we change any of the nodes inside a? Take a look at a. Do we change a? Nothing's different about a, at all. So none of the heights of its nodes can change. Yeah? No, yeah, we're inserting with the whole tree. I'm not done here. Yeah. Yeah, so did they change? Did v change? Yeah, so none of these subtrees had any heights changed. Um, what about, over here? 20, 30, 40, any that changed at all? Absolutely not, even participating in this rotation, right? Ok, what else changed? Yeah? Yep? Oh, happened not to? Yeah, ye, ok. That's true. 90 happens to not be different, but it might have, if the tree had been shaped differently. Ok, so here's the deal: when you deal
When you write the code, the nodes choose the heights you need to update. The nodes choose the heights you need to examine are 80 and 90, the ones... the upper one in this stick. Because it's easier to do so, we also happen to update 99, but it will never change. So we can use same helper function for left and right rotation, I think, if I recall correctly. So 80 and 90 and every node on the way up the tree. Okay? Including in this case, 50. They might change. Okay? Any question about that? Yep? What is the height of 60 here? Heights go down, heights are measurement, so A is the subtree whose root is 60. A is the subtree whose root is 60. Height is measured as the distance to a leap. So when you looking at A, you are only looking it down the tree. Yes, I agree A's level changed, But not its height. Okay? So again this is an example of vocabulary that is very easily swapped, right? Make sure you see the difference a description of tree's level and a tree's height. They are kind of, almost inverses of one another. So it makes sense? It's totally clarified? Ok, anything else about this? Alright, so when we write real code for this beyond just assignment, we are going to do 2 things: we are going to assume each node stores its height and then we are going to update its height as we walk off the tree. Alright, so let's get some practice. Let's get some practice. And, as I said, the right rotation is symmetric. I looked at this tree and I go, oh ,it's kind a long on the left. So I am gonna take it and do a right rotation and fix it. Okay? So what's the first thing you do. You find... oh that's cool. Okay. And you have fixed it... Okay. Is it better really? I don't know. I need to be able to adjust it quickly. Alright, so find the stick, I need to change it into a mountain. I will raise you. You don't have to remember the code we already did, but I will raise you in changing this one into a mountain. Okay? So, I know how to do this... 40, 20, 70, and then I've got A and B and C and D. This was an easy one because a lot of them marked empty. And I am gonna hook those on here. A and B. C is 50 and 60. And 70 is right tail. It's 80. Okay! Got it, yep? To get the same tree? Okay, check the neighbor, haha. Put your nose on your neighbor's paper. How they do? Rough them out if they didn't do any work. Just kidding. Oh, hi ,what's up? Oh nice. Okay. So we have a beautiful new tree huh? What you think? Shot. It didn't help anything. So can you see why? Can you see what kind of happened here? You see what kind of happened? Why didn't this work? What happened? Nobody wants to articulate?
To a right rotation, I think, if I recall correctly. Um, And eighty so eighty and ninety and, every node on the the way up the tree. ok including in this case, fifty, might change. ok? Any question about that? yeah? Whats the height of 60 here? heights go down. heights are measurements so a is the subtree whose root is sixty. A is the subtree whose root is sixty, height is measured as the distance to a leaf, so when you're looking at A, you're only looking down the tree. Yes I agree A's level changed but not it's height, ok. So again this is an example of vocabulary that is very swapped, make sure you see the difference a description of a tree's level and a tree's height. Ok they're kinda almost inverses of one another. Does that makes sense, Does that totally clarify. Ok anything else about this? alright, so when we write real code for this beyond just these assignments, we;re going to do two things, we're going do two things, we're gonna assume each node stores it's height, and then we're going to update the height as we walk up the tree. Alright, so lets get some practice, lets get some practice. And, as I said, the right rotation is symmetric. I look at this tree and I go its kinda long on the left, so i'm gonna take it and do a right rotation and fix it. Ok? so whats the first thing you do? you find whoa that's cool. Ok? I know how to fix it. ok. Is it better like that, I don't know, I need to be able to adjust it quickly. Alright, so you find the stick, and you change it into a mountain. Ok, I will race you. You don't have to write the code, we already did, but I will race you in changing this one into a mountain. Ok, so I know how to do this its... forty twenty, seventy, and then I've got A and B and C and D. This was an easy one because a lot of them are empty, Then, I'm gonna hook them on here, A and B and C is fifty and sixty and seventy's right child is eighty. Ok. Got it? yeah did you get the same tree? Ok check your neighbor. haha put your notes over in neighbor's paper. How did they do. rat them out if they didn't do any work heh heh heh. just kidding oh hi whats up. Oh nice. sorry. thank you for listening Ok, so we have a beautiful new tree. huh what do you think. shoot. ugh darn it. it didn't help anything. So can you see why, can you see what kinda happened here? can you see what kinda happened? Why didn't this work? what happened. Anybody want to articulate it?
When you write the code the node whose heights you need to update the nodes whose heights you need to examine are 80 and 90, the upper ones in this stick because it's easier to do so. We also happen to update 99 but it will never change just so we can use the same little helper function for left and right rotation, I think, if I recall correctly. And 80 and 90 AAAND every node on the way of the tree. Including, in this case, 50. They might change. Any questions about that? Yeah? What's the height of 60 here? Heights go down. Heights are measurements so A is a subtree whose root is 60. A is a subtree whose root is 60, height is measured as a distance to a leaf. So when you're looking at A, you're only looking down the tree. Yes, I agree A's level changed but not its height. So again, this is an example of vocabulary that's very easily swapped. Make sure you see the difference between the description of a tree's level and a tree's height. They're kind of almost inverses of one another. Does that make sense, totally clarified? Anything else about this? Alright, so when we write real code for this beyond just these assignments, we're going to do two things, we're going to assume each node stores its height and then we're going to update the heights as we walk up the tree. Alright, so let's get some practice. Let's get some practice. And as I said, the right rotation is symmetric, I look at this tree and I go oh, it's kinda long on the left, so I'm gonna take it and do a right rotation and fix it. So what's the first thing you do? You find- woah that's cool. K. I know how to fix it... Is it better like that? I don't know I need to be able to dust it quickly. Alright so you find the stick, and you change it into a mountain. K, I will race you. You don't have to write the code we already did. But I will race you in changing this one to a mountain, k? So I know how to do this it's... 40, 20, 70, and then I've got A and B and C and D. This was an easy one because a lot of them are empty. And I'm going to hook those on here. A and B, C is 50 and 60 and 70's the right child of this 80. Ok! Got it? Yeah? Did you get the same tree? Okay. Check your neighbor. Put your nose over your neighbor's paper. How'd they do? Rat them out if they didn't do any work! Just kidding. Oh hi, what's up? Oh nice! (K sorry! Thank you for listening) Okay. So, we have a beautiful new tree. What do you think? (Cute!) It didn't help anything. So can you see why- can you see what kinda happened here? Can you see what kind of happened? Why didn't this work? What happened? Anybody want to articulate it?
Ok, I'm going to do this kind of loosely at first, and then we'll talk- we'll kind of gradually edge toward more official discussion on it ok? The part of the tree that made this long, made this tall and stringy is in the middle of the tree. And the rotation just took that thing that's making it long and moved it over. K, so the solution to this is to do the following. Do- first do a left rotation, so that we change the balance of the left subtree, so we're going to make it- we're going to take the 50, 60 and kinda move it over so the stringiness is all in one direction, and then we're going to do a right rotation. So this tree requires a double rotation in order to fix it. Alright, so let me- let me draw that all out, and we'll do the rotations and then we'll talk about what has happened here. So, the observation here is that we don't actually have a stick. We have a bent stick. K, the stick is bent. So what we're going to do is first, a rotation around 40, and then a right rotation- a left rotation around 40 and then a right rotation around 70. K, so ok I can do this. Ummm... Left rotation around 40 means that this is my stick for the moment. K, so I'm going to 50, 40, 60 and then I have to put 20 in the right spot on 40, and the rest of the tree still looks like this. And this was a- oh, sorry, yeah a left rotation about 40. Left rotation. K? And now, when you look at this tree, oh it's very sticky. Now, it's a simple right rotation around that stick. So again, I'll race you. 50, 40, 70, and then I attach 20, and I attach 60, and I attach 80. So this is to get to the next one is right about 70. Okay. I have questions for you. How long does it take to do a single left rotation? Constant time, good. Constant time. Because of those assignment statements. What about updating the heights? Hmm... It's also constant time, because you're storing the heights in the subtree. You don't have to do any- uh, you don't have to do any traversals to get those heights. So we're storing the heights in the subtrees so readjusting heights within a rotated subtree is a matter of within the stick, is a matter of just looking at the nodes in the subtrees. Kay, so rotations are constant time so what if we do two of them? It's still constant time, very good. Just a bigger constant. Where'd my machine go? Alright, so, rotations are constant time..
Okay I am gonna do this kind of loosely force, then we will kind gradually edge toward more officially discussion of it Okay? The part of the tree that made this long, made this tall and stringy is in the middle of the tree. And the rotation just took that thing. It's making it long and move did over. Okay. So the solution to this is to do the following. First, do a left rotation so that we change the balance of the left subtree. So we are gonna take the 55,60, kind of move it over so the stringiness is all in one direction. And then we are gonna do our right rotation. So this tree requires a double rotation in order to fix it. Alright, so let me draw that all out. And we will do the rotations and then we will talk about what has happened here. Okay? So your observation here is we don't actually have a stick. We have a bent stick. Okay? The stick is bent. So what we are gonna do is first a left rotation around 40. And then a right rotation on 70. Okay? So okay I can do this. Left rotation around 40 means that this is my stick for the moment. Okay, so I'm going to... 50, 40, 60, then I have to put 20 in right's bottom of 40. And the rest tree still looks like this. And this was a, oh, sorry, yeah, a left rotation about 40. Left rotation. Okay. And now, when you look at this tree, oh it's very sticky. Now, it's a simple right rotation around that. So again, I all raise you 50, 40, 70. And then I attach 20 and I attach 60 and I attach 80. So this is, to get to the next one, is right about 70. Okay. I have questions for you. How long does it take to do a single left rotation. Constant time, good. Constant time, because of these assignment statements. What about updating the height. It's also constant time, because you are storing the heights of subtree. You don't have to do any, you don't have to do any traversal to get those heights. So we are storing the heights in the subtrees. So readjusting heights within a rotated subtree is a matter of, within a stick, is a matter of just looking the nodes in the subtree. Okay? So, rotation is constant time so what if we do 2 of them? It's still constant time, just a bigger constant. Alright, So rotation is constant time.
and that's a really good news cause it means we can adjust the structure of tree by spending a little bit more time on our insertion and removals just quite complex but satisfying nonetheless yes! (students asking) so right very good so we are going to look at this but I am answering the question right now so we will wait a minute when you go back up the tree adjusting the height that is cost you time and the answer to that is that you will do that in the context of insertion right? like all of this is happening in the context of some other manuplation on our tree like insertion so we've already spending the time navigating the height so yes we are going to spend a bit more time but not more time in the insertion would taken anyway ok? so at each stage in the worst case we just gonna to do a rotation but it will still be only at every level of the tree in the worst case actually insertion there proves you to do at only once ok any question so far? yes! (students asking) oh very good so the question is how to I choose seventy, forty and fifty? so there is a mystery here and I consider it to be diagnosing the need of the rotation ok and it is exactly the right question right like I don't know why I could observe that it is the bent thing instead of the straight thing except right now you do have the intuition that is too long in the middle ok we are gonna actually I think I have slide in two slides that help you to diagnosing exactly how you figure out which rotation to do ok so this is the exactly the right question to do alright so here is the summary here's we know so far there four kinds of rotations this one I should say this is an example of double rotation called a left-right rotation so left is like an left modifies right ok still a right rotation it just say lefty right rotation ok there are four kinds: the singles in each direction left-right and right-left ok they are all symmetric so that means that currently we are already know how to write the code for one of them they are local operation that is ABC and D and also all subtrees on the other side of the imbalanced subtree none of those are affected em and we are just readjusting the structure of binary search tree we are not breaking a binary search tree in any way ok? alright. so our goal is to use these rotations to maintain the balance of a binary search tree em this particular height balanced tree these are called AVL trees where AVL they are a collection of initials for these guys whose name I always forget Adelson-Velsky and Landis two people and this was done in 1962 ok? alright so here's I am gonna say about that so this is two people who did this there are particularly kind of tree there are other balanced trees you will see the references to red-black trees if an interview or if you are reading an research paper or somebody refers to red-black trees kind of quizzes about it you say in our discrete structure classes we did an AVL tree instead and oh you can get red-black trees if you know AVL trees when I took the theory classes when I took what's now 374 here decades ago they did red-black trees there and they may still I don't know for sure alright and the thing I'd like to point out is look this is not all that long ago this is a relatively short time ago it's kind of weird right? like this is when your grandparents when they are in their height of career properly about
And that's really good news because it means we can adjust the structure of the tree by spending a little more time on our insertions and on our removals which is quite complex but satisfying nonetheless. Yes? So right very good. We're gonna look at this but I'm going to answer the question right now. Wait a minute. When you go back up the tree adjusting the height that is costing you time. And the answer to that is that you're doing that in the context of the insertion. Right? All of this is happening in the context of some other manipulation on our tree like insertion. So we're already spending the time navigating the height so yes we're gonna spend a little bit more time but not more time than the insertion would have taken anyway. So at each stage in the worst case we're just gonna do the rotation but it will still be only at every level of the tree in the worst case. Actually in insertion there's proofs you only do it once. Ok any questions so far? Yes? Oh very good. So the question is how did I choose 70, 40, and 50? So there's a mystery here and I consider it to be diagnosing the need for a rotation. Ok? And it's exactly the right question. Right? I don't know why I could observe that it was this bent thing instead of this straight thing except right now you do have the intuition that it was too long in the middle. We're going to actually... I think I have slides we have two slides that it help you diagnosing exactly how you figure out which rotation to do. So that's exactly the right question. Alright. So here's a summary. Here's what we know so far. There are four kinds of rotations. This one I should say this is an example of a double rotation called a left-right rotation. So left modifies right. Still a right rotation it's just a leftishly right rotation. Ok so there are four kinds. The singles in each direction and left-right and right-left. And they're all symmetric. So that means that our code we already know how to write the code for one of them. They are local operations that is A B C and D and also all subtrees on the other side of the imbalanced subtree none of those are affected. And we are just readjusting the structure of the binary search tree we are not breaking the binary search tree in any way. Alright so our goal is to use these rotations to maintain the balance of binary search trees. These particular height balanced trees are called AVL trees. Where AVL they are a collection of initials for these guys whose names I always forget: Adelson Velski and Landis. Two people. And this was done in 1962. Alright so here's what I want to say about that. So this is two people who did this. There are this particular kind of tree. There are other balanced trees you will see references to red-black trees. So if an interviewer or if you're reading a research paper or if somebody refers to red-black trees and kind of quizzes you about it you say in our Discrete Structures classes we did AVL trees instead and they're go oh oh oh you can get red-black trees if you know AVL trees. When I took the theory class when I took what is now 374 here decades ago they did red-black trees there and they may still. I don't know for sure. Alright. And then the thing I like to point out is look this is not all that long ago. This is relatively short time ago. This is weird like this is when you're grandparents were at the height of their career probably... about.
So It kind of makes it like it's not calculus. The reason we choose this height balanced tree, I strongly believe, that if you got a friend in white board, you could figure out how to do this yourself. You can just as easily has your names on it as these people who happen to be interested at that time. It makes feel very accessible to me. We are moving toward implementation. You know the mechanics of doing a rotation but how to deploy it at all. That's OK. We are going to talk about that. We need to be carefully how to maintain the height and we need to detect the imbalance. So this one I feel like you already know. You understand the need for the second one and the third one we haven't talked about at all. OK, we already kind of talked about this. I forgot that I had a slide for it. Is this tree height balanced? What's the lowest node in the tree that is out of balance? Five? Good. And what kind of rotation would you expect to restore the rotation? This is intuition right now there is no algorithm for you to apply. So this is all you intuition for what we have done so far. What kind of rotation? A right rotation. Yeah, a right rotation. Do you think it's single or double? Single, because it is not right here that is long. Good. The only thing I want you to observe is that the height of this one is going to change, the height of this one is going to change, and in fact the height of this one is going to change on the way. It is a recursive call on the whole structure. Keep in mind that this piece might be a subtree of some much larger structure whose height may also change. Because this is the root of the longest path and the height of the structure further up would change as well. Alright, any questions? We already did this. OK, this is the moment when we have to identify the need of a rotation. Here is the thing. Last night, I puzzled over this slide for a while because I never like it. I never like how this slide goes. Here is why. It's starts with the assumption that you have inserted into a particular place. The thing is that's true. That's what determines the rotation that we do. So I couldn't think of another way to do this. So, it the insertion was in subtree t3 or t4 and the imbalance is detected at t, that's the setup. Now, what determines whether the insertion was in subtrees t3 or t4? We were doing an insertion. What would that have meant? It meant that it was greater that t's right. So insertion in subtrees t3 or t4 means it was greater or equal to the key of t's right subtree. So this is sort of an equivalent. t is greater or equal to t's right. Any questions? That's what it means. And the imbalance the insert is detected at t. Remember that's just look at the height of the left and right of the subtree. So that's looking at the left and right of the subtree. And imbalance means that it's heavier on the right that imbalance is two then, the height difference is 2. Then what do you think I'm going to write here? What kind of rotation do you think is going to fix this? Left, good. Left rotation about r rebalances the tree. I think it's easier to gage this if we judge the insertion position by greater or equal to t's right. But actually we can also observe that the balance factor at t's right actually has to be one.
So it kind of makes it like this is not calculus, right? The people were not wearing togas when they did this. And the reason we choose this kind of height balance tree is I really strongly believe that if you've got a friend and a whiteboard, you could figure out how to do this yourself. It could just as easily have your names on it as these people who happen to be interested at that time. So, it makes it feel very accessible to me. Alright, so we're going to move toward implementation. You know the mechanics of doing a rotation but not how to deploy it at all, and that's okay. We're going to talk about that. We need to see; we need to think carefully about how to maintain the height, and we need to be careful about detecting the imbalance. So this one I feel like you already know. You understand the need for the second one. And the third one we haven't talked about at all. Okay, we already kind of talked about this. I forgot I had a slide for it. Is this tree height balanced? What's the lowest node in the tree that's out of balance? Five. Good. What kind of rotation would you expect to restore the balance? So this is intuition right now. There is no algorithm for you to apply. So this all just your intuition for what we've done so far. What kind of rotation? A right rotation. It would delight me to no end to see just somebody do like this during an exam. That would, like, be so fun. Alright, so yeah, a right rotation. Do you think it's single or double? Single, right. Because It's not right here that's long. It's already the weight is pushed way left. So good, your instinct is really good here. And the only thing I wanted to observe is that the height of this one was going to change. The height of this one was going to change, and in fact, the height of this one was going to change on the way up. It was a recursive call on the whole structure. Keep in mind that this piece might be a subtree of some much larger structure with who's height may also change because maybe this was the longest path, and so the height of that structure further up would change as well. Alright, any question about it? We already did this material on the previous slide. Okay, yay! It's the moment when we are going to identify the need for a rotation. Now, here's the thing. Last night, I puzzled over this slide for a while because I never like it. I never like how this slide goes. Here's why. It starts with the assumption that you have inserted into a particular place. The thing is that that's true. That is what is going to determine the rotation that we do. So I couldn't think of another way to do this. So if an insertion was in subtrees t3 or t4 and imbalance is detected at t, that's the setup. What determines whether an insertion was in subtrees t3 or t4? We were an insertion. What would that have meant? It meant that it was greater than t's right, right? So an insertion in subtrees t3 or t4 means it was greater than or equal to the key of t's right subtree. Fine, so those are sort of equivalent. Key is greater than or equal to t's right, the key that you're inserting. Alright, any question about that? That's what it means. They mean the same thing. Okay, and an imbalance is detected at t. Now remember that's just looking at the heights of the left and right subtree. That's looking at the heights of the left and right subtree. An imbalance means that it's heavier on the right, that imbalance is 2 then. The height difference is 2. Then, what do you think I'm gonna write here? What kind of rotation do you expect to fix this? Left. Good. Left rotation about t rebalances the tree. We gauge this so I actually think its easier to gauge this if we judge, if we judge the insertion position by the key greater than or equal to t's right. But actually we can also observe that the balance factor at t's right actually has to be 1.
So they kinda makes it like this is not calculus, right? These people will not wearing togges when they did this.
Class is at 11 o'clock. Umm, let's see. All right. So umm, this is what I'm talking about. So raise your hand if you went to football game. Ok. So e, a student section was full. A student section was like more full than the stadium. Yes! Way to go. Umm, I wasn't there, cause it was my mother in law's 80 years' birthday parties. So you know, call it family politics. Umm, but this is what it was like in the pre game. It was a big party. So somebody who went, somebody raise your hand again if you went to the football game. Was it blast? Yeah, and we won't talk about the outcome. I will tell you though, I will tell you that my mother in law's 80 years' birthday party was in Wisconsin. So I was hearing, you know, I was hearing the game updates from the wrong side. The whole time my husband was looking at me like hahaha. So, you know, family, family complexitiies. All right, so, let's go to school. Let's play school, ok. Umm. So you'll have an exam a week from tomorrow. Umm, we are gonna do it, you know, all of our good attentions have gone a waste here. We are going to do a big exam. This is known as the tree exam. So all the questions on this, almost all the questions on this exam will be related to trees in one way or another. Umm, though it will also include maybe a little bit more series treatment of stacks and queues. You should notice that Level Order Traversals, Level Order Traversal is a great way for me to ask you both about queues and about some related to trees and about MP4. So make sure you really, make sure you see the connections betweeen, umm, queues and stacks as well actually. And traversal of trees and MP4. Cause that is a sort of very rich set of topics around which we can build questions. Now, I don't say that with any knowedge of what the exam looks like. I don't even writing the exams. So I'm just saying that if I were you, that would be one area of sort of integrated learning you might take pretty seriously. And then on this end of things that's the beginning, the stacks and queues was the kind of the beginning. We also have not yet test you on iterators in any reasonable way. So I would expect multiple choice question or something related to iteration and generic programming in c++. Umm, also let's see, umm, oh on this end of things, all the way through Friday's lecture on this week will be on the exam. So we'll finish up B trees on Friday. We are finishing AVL trees today. We are gonna do B trees Wednesday and Friday. And then there will be this kind of queen break away from trees. Ok. Umm let's see. And we'll be providing you opportunities for review. And we usually do an MP5 solution party right, you know, in those few days between MP5 and exam. Umm, what else, you can do your own MP4 solution party if you like. It's not as complex as MP5. All right, umm, I'm gonna save playing around with the [o no heck]. Let's just do it. Slide this, hoho, and go here, and go here. Oh, yeah it's this. And now I'm actually going to turn on AVL. Ok. So last time we talked about fondamental algorithms for, fondamental algorithms for maintaining balance in a tree. Today we are gonna actually write the code or I'm gonna show you the written code for [insortion], Am I believe removal happens in labs. I believe you write the code for removal in lab. Umm, but ohh hey. look. ok. I can recover. like this. Oh and we are good to sound this light. ok. Come on everybody. Everybody's happy. Everything is awsome.
classes is at eleven o clock alright so this what I'm talking about so raises your hand you would supporting ok so ah the student section was full the student section was more full than stadium yes! a long ago I was not there cause it was my mother birthday party so you know probably family politics but this is what was like a pregame it is a big party so somebody who went somebody raises your hand if you went the ball game? was it a blast? yea and we won't talk about the outcome I will tell you thought I will tell you that my mother birthday party was in Wisconsin so I was hearing you know I was hearing the game updates from the wrong side the whole time my husband loos at me is like HAHAHA so you know family family complexities ok so let's go to school lets play school ok em you have an exam a week from tomorrow em we are going to do it you know all of our intentions is gonna waste here em we are going to do a big exam this is known as the tree exam so all the questions on this almost all the question on this exam will be related to the trees in one way or another though we will also include maybe a little bit more serious stacks and queues you should notice that level-order traversal is a great way for me to ask you about both queues and about something it related to tree and about MP4 so make sure you see the connections between queues and stacks as well actually and traversal of the trees and MP4 cause there not be sort of very rich set of topics around that we can build questions now I don't say any knowledge what is exam looks like about and I am not even writing the exam I am just saying if I were you that would be one area of sort of integrated learning you might take it very seriously and on this end of thing that is the beginning stacks and queues are kind of the beginning we also have not yet tested you on iterators in any reasonable way so I would expect multiple choice question or something related to iterations and generic programming in C++ em also let's see em on this end of thing all the way through Friday's lecture this week will be on exam so we will finish up B-trees on Friday we are finishing up AVL trees today we are gonna do B-trees Wednesday and Friday and then there will be this kind of clean break away from trees ok let's see we will provide you opportunities for review and we usually do MP5 solution party right you know in those few days between MP5 and the exam em what else I don't know you know you can do your own MP4 solution party if you'd like it's not quite complex as MP5 alright em I am gonna save playing around with the all node hack let's just do it slide this and go here and go here oh yea! it's this and now I am actually turn on the AVL ok so last time we've talk about the fundamental algorithms for maintaining the balance of an tree today we are going to actually write the code or I will show you the written code for insertion and I believe removal happens in labs I believe you will write the code for removal in the lab em but oh hey ha look em a-o ok I can recover brand this oh and look at the sound ok come on everybody everybody is happy everything is awesome
[silence] May you never have this feeling that I have right now. This feeling that I have may you never have it in your life. Don't take a job where whether or not you're happy depends on whether your screen rotates. I think I got it yeah. But thank you. Thanks. You could sit right there just in case I'm lying. YAY!!! Thank you Ian. Okay. [gibberish]... input... this... no... Alright. Okay, so let's play around a little with this a little bit. Umm, if you recall, we use this fundamental operation called a Rotation to maintain balance in a tree. A rotation is simply a reordering of the nodes well a restructuring of the nodes in such a way that the heights of the tree are changed, but the order of the keys in the tree are not changed. So, my question for you is first of all is this a balanced tree? Is this a balanced, a height balanced, tree? Yes it is. The difference in no subtree in no pair of subtrees is greater than 1. So this is a height balanced tree. Alright I want you to tell me a key I can enter that will unbalance this tree. Somebody raise their hand. This is a good one. This a good opportunity to be brave to speak in class because there are lots of keys that will work here. Yes, what key could I enter that would unbalance this tree? 85. Okay, everybody make sure they see where 85 would go in a binary search tree. Umm, insert. You see it? Where it would go? Okay, now walk up the tree and look from 85 and look for the first node that is out of balance an unbalanced subtree. That key is... 36. Good, 74 is still fine, because in that case right left would be 1. We put up with that. But 36 would then be out of balance. Now, my question is intuitively, instinctively, what kind of rotation would you expect to fix it? A left rotation. Good. Now, make a guess, an instinctive guess, whether or not it is a double or a single rotation. Whether it is a rightLeft or just simply a left. Single rotation is correct. Okay, so let's watch that happen. Do this... Do this... 85... Insert are you ready? K... Insert... Boink... Come one... Insert... Okay laptop, VGA... Happy, happy, happy... K... Insert... No, come on... Nothing is working I got nothing from my stylus... Refresh the page, them 85 goes away. I think what I need to do is reboot my machine and let microsoft do its work, but that's sad. [Groans]. Oh, watch this. I can do... 40. Remove... delete... [silence]...
May you never have this feeling that I have right now. This feeling that I have, may you never have it in your life. Don't take a job where whether or not you're happy depends on whether your screen rotates. I think I got it. Thank you. You can sit right there just in case I'm lying. Yay! OK. Pen... input... alright. OK, so let's play a round with this a little bit. If you recall, we used this fundamental operation called the rotation to maintain balance in a tree. A rotation is simply a reordering of the nodes, well, a restructuring of the nodes in such a way that the heights of the tree are changed, but the order of the keys in the tree are not changed. So, my question for you is, first of all, is this a height-balanced tree? Yes, it is! The difference in no pair of subtrees is greater than one, so this is a height-balanced tree. Alright, I want you to tell me a key I can enter that will unbalance this tree. Somebody raise their hand this is a good opportunity to be brave and speak in class, because there are a lot of keys that well work here. Yes, what key could I enter that would imbalance this tree? Eighty-five. OK, everybody, make sure they see where eighty-five would go in a binary search tree. Do you see where it would go? OK, now, walk up the tree and look from eighty-five and look for the first node that is out of balance the root of an unbalanced subtree. That key is... thirty-six, good, seventy-four is still fine because in that case, right minus left would be one, we put up with that, but thirty-six would then be out of balance. Now, my question is, intuitively, instinctively, what kind of rotation would you expect to fix it? A left rotation, good! And now, make a guess, an instinctive guess, whether or not it is a double or a single rotation. Whether it's a right-left or just simply a left. Single rotation is correct. OK, so let's watch that happen. This... do this... eighty-five... insert... are you ready? OK, go! Insert... boink... c'mon... insert... OK, laptop VGA... happy happy happy... OK, insert... c'mon... nothing's working. There, I've got nothing from my stylus. Refresh the page, then eighty-five goes away... I think I need to reboot my machine and let Microsoft do its work, but that's sad. Oh, watch this, I can do... forty... remove... delete.
may you never have this feeling that i have right now, this feeling that i have, may you never have it in your life. Don't take a job where whether or not you're happy depends on whether your screen rotates. Ok, so lets play around with this a little bit, if you recall we used this fundamental operation called rotation to maintain balance in a tree. a rotation is simply a reordering of the nodes, well a restructuring of a nodes in such a way that the heights of the tree are changed but the order of the keys in the tree are not changed. so my question for you is first of all, is this a balanced tree? A height balanced tree? Yes it is. The difference in no pair of subtrees is greater than 1 so this is a height balanced tree. Alright, i want you to tell me a key i can enter that will unbalance this tree. Somebody raise their hand.This is a good one. This is a good opportunity to be brave and to speak in class there are a lot of keys i could enter. yeas what key could i enter that would imbalance this tree? 85. ok everybody make sure they see where 85 would go in a binary search tree insert. you see where it would go? ok now walk up the tree and look for the first node that is out of balance, that iis the root of an unbalanced subtree.That key is 36 good. 74 is still fine right? In that case right minus left would be 1, we put up with that, but 36 would then be out of balance. Now my question is, intuitively, instinctively, what kind of rotation would you expect to fix it? A left rotation good. And now make an instinctive guess on whether or not it is a double or a single rotation. whether its a right left or simply a left. single rotation is correct, ok so lets watch that happen. do this, do do this, 85. insert. are you ready. ok insert. boink. come on. insert. ok laptop. vga. happy happy happy. insert. no! come on. nothing is working. i've got nothing from the stylus. refresh the page then 85 goes away. i think what i need to do is reboot my machine and let microsoft do its work. but thats sad. awww. oh watch this. i can do. remove delete.
okay so so its working, alright, proof of concept, now I'm going to plug it in because i like it, okay alright, now I'm going to do 40 again, sorry, you know, delete, boink, muted anyways, who cares, oh, okay, so that was fine, and then I'm going to insert, I'm going to make it look like it was before, oh no, don't mess with me. 76. Insert, boink, boink, boink, boink, and oh okay, and now we are going to be inserting 85. didn't expect that part to take 5 minute. Okay ready? ready? are you sure you are ready? they do it a lot faster than we do. lets try, alright, so now what i want is something that you can insert, lets take 85 out, okay? Sorry I'm keeping it in for one time. Okay. Deleting 85. Oh its not working. Ill save you. Nothing is out of bounce, now I want to know some key that will inserted will result in right rotation. 62 will do it. Anything bigger than 36 or less than 75 right? anything inside 75's left subtree will result in a right subtree, is that true? Yes. And anything in 75's left subtree can contain keys between 35 and 75 so somebody raise their hand, you get to speak here. Yea what number do you want? 45, okay. 45 and inserting, okay, boink boink, boink, boink. Oh, thats not out of balance, oh. Okay right rotation. Okay any question about that? What happens when I insert 17? Nothing special right? Finding the spot for 17 and checking to make sure that everything is okay on the way up. Yea Mike? Oh, uhm, so, going up is sort of like yelling out a value after you processed the rest of the tree in a post order traversal, okay so I'm going to do this post order after the recursive call is made. Okay? Does that make sense? And when you look at the code, ill be sure to point it out, so all of this evaluation assumes that the insert actually happens. Okay I want now a key that will result in a double right rotation, in a right rotation, but a double one. A double right rotation, I believe that there is only one key that will result in a double right rotation. It's a power of 2.
Oh, okay, so it's working alright. Now I'm gonna plug it in because I like it. Now Im gonna do 40 again, sorry. Delete. Boink. Oh okay. So that was fine. And then I'm gonna insert 76. I'm gonna make it look like it was before. Oh no. Don't mess with me. 76. Insert. boink. boink. boink. boink. And now, we're gonna insert 85. didn't expect that part to take five minutes. Okay ready? ready? are you sure you're ready? Okay we're okay, oh oh woah. They do it a lot faster than we do. Okay. Let's try... so now what I want is something you could insert, let's take 85 out okay? Sorry I'm keeping it in for one time. Deleting 85. Nothing's out of balance. Perfectly fine. Now I want to know a key some key that when inserted will result in a right rotation. 62 would do it. Anything bigger than 36 or less than 75 right? anything in 75's left subtree would result in a right rotation is that true? Yes? and anything in 75's left subtree can contain keys between 35 and 75. So, Somebody raise their hand you get to speak here. Yeah what number you want? 45. Okay. 45. And inserting boink boink boink boink. Oh that's not out of balance, that's not out..ohh. uh oh. right rotation. what happens if i insert 17? Nothing special right? 17 finding the spot for 17 and checking to make sure that everything's okay on the way up. yeah Mike? Oh, going up is sort of like yelling out a value after you've processed the rest of the tree in a post order traversal. So I am actually doing this post order after the recursive call is made. and when you look at the code I'll be sure to point that out. So all of this, all of the valuation assumes the insert has happened. okay. let's I want now a key that will result in a double right rotation. In a right rotation, but a double one. a double right rotation. I believe there's only one key that will result in a double right rotation. and it's a power of two.
[gibberish] yes sixteen, lets try sixteen and see what happens, okay see where sixteen is going to go, whats the lowest key out of balance when i insert sixteen, fifteen very good fifteen is the lowest one and its the root of this sort of dog leggy thing so lets do this see what happens, sixteen there oh uh oh broken uh oh got it, see it, alright um i wanna do a double one. i mean one where its not quite so obvious. im gonna remove sixteen, im sorry fifteen, well eh remove 15, oh, i dont know what i wrote, there is no fourty eight are you tired of this? does anybody have any specific questions about it, the applet itself is on your handout, you can play with it a little bit yourself and we'll probably talk about it a little more when we talk about removals so you can see the removal process in action, but i wanna get to work. okay, so last time we were right smack in the middle of diagnosing the correct rotation. this processing is one that we're using to inform the code that we write and there is the easy way to understand whats happening mechanism for writing the code and then there is the thinking a little bit farther so that youre code looks beautiful part of writing the code so im gonna sort of start with the easy way of looking at it and argue for the um argue for the more elegant code in this slide okay so pretend your tree looks like this and we have t, t is where we're going to first detect an imbalance and furthermore im gonna tell you that insertion has happened somewhere over here. okay, so, insertion has happened somewhere over here for now and we've kind of walked up in this postorder mechanism after the actual insert has taken place and we get to t we evaluate the balance and we go whoa whoa whoa the balance equals what, theres in an imbalance there what is that balance have to be if the insertion has happened over here, that is we've increase the height over here, then and t is out of balance, so what is the new balance have to be at t, balance is right minus left how about that. does that help, height of right minus height of left, two is correct cant be anything else, if it were three that would mean we have done several insert without rebalancing and we're not gonna do that okay so the balance factor at t is two we can check that with a little function that checks that and some kind of what is your instinct say here some kind of what kind of what kind of rotation, left rotation will rebalance the tree thats all we know right now, further i will tell you that the insertion occurs here, now when i first wrote this code, i said look i can tell if the insertion happens over here, because it just means that the key that we're inserting is bigger than the key in t's right okay so saying this statement insertion occurs in t or t3 or t4 is equivalent to saying the key we are inserting is bigger than t's right key.
[gibberish] yeah, 16, lets try 16, see what happens. Okay, see where 16 is gonna go? Whats the lowest key out of balance when I insert 16? 15. Very good. 15 is the lowest one and its the root of this sort of dog leggy thing. So lets do this. See what happens. 16, there. Oh! uh oh! Broken, uh oh. Got it? See it? Alright, um. I wanna do a double one. I mean uh, one where its not quite so obvious. I'm gonna remove 16, I'm sorry, 15. Oh well, ha. I removed 15.Oh. I don't know what I wrote. There is no 48. Okay, are you tired of this? Is anybody have any specific questions about it? The applet itself, the name or URL is on your handouts so you can play with it a little bit yourself. And we'll probably talk about it a little more when we do removals. So you can see the removal process in action. So for now, I wanna get to work. Okay. So last time, umm, last time we were right smack in the middle of diagnosing the correct rotation. Now, this process is one that we're using to inform the code that we write. And, there is the easy way to understand whats happening" mechanism for writing the code, and then there is the um,"thinking a little bit farther so that your code looks beautiful" part of writing the code. So, I'm gonna sort of start with the easy way of looking at it, and argue for the more elegant code in this slide. Okay, so. Pretend our tree looks like this. And we have T. T is where we're going to first detect an imbalance, and furthermore I'm gonna tell you that insertion has happened somewhere over here, okay? So, insertion has happened somewhere over here for now, AND, we've kind of walked up in this postorder mechanism after the actual insert has taken place. And we get T, we evaluate the balance and go Woah The balance equals what? There's an imbalance there, what does that balance have to be if the insertion has happened over here? That is, we've increased the height over here, and T is out of balance So what does the new balance have to be at T? Balance is right minus left. How about that. Does that help? Height of right minus height of left. 2 is correct, cant be anything else. If it were 3, that would mean we have done several inserts without rebalancing. And we're not gonna do that. So balance factor T is 2, you can check that with random function that checks that. And some kind of, what does your instinct say here. Some kind of, what kind of rotation? Left rotation will rebalance the tree. Thats all we know right now. Further, I will tell you that the insertion occurs here. Okay? Now, when I first wrote this code, I said look, I can tell if the insertion happens over here. Because it just means that the key that we;re inserting is bigger than the key in T's right. OkaY So, saying this statement insertion occurs in T3 or T4" is equivalent to saying "the key that we're inserting is bigger than T's right key".
32 is already there. Yes, 16, let's try 16 and see what happens. See where 16 is gonna go? What's the lowest key out of balance when I insert 16? 15, very good. 15 is the lowest one and it is the root of the sort of dog leggy thing. So let's do this, see what happens. Uh-oh, broken. Got it? See it? Alright, I wanna do a double one. I mean, one where it's not quite so obvious. I'm gonna remove 16, insert 15.
we still havent found the right spot found the right spot but this is null when this guy is null all we have to do is make a new node and return we make a new node and return to the black calling box the function corresponding to the black triangle where this blue one is the root we are going to do these steps is it out of balance in the black triangle is there an imbalance no okay we do not need to rotate this should be indented does its height need to be updated yes so we update its height so now the height of that guy is one ill just put it in there now we have computed we have accurate height height of subtrees pass back to green calling function recursion at green level and we follow those stpes is there an imbalance no so no rotation necesarry do we have a new height? how do we compute new height its the maximum of those two plus 1 that becomes 2 fine pass control back is there an imbalance here no so no rotation we should update height is there new height yes this becomes three one two three its a comparison of height of subtrees pass control to the blue pass control to the blue and what do the steps say check for imbalance it is out of balance and where have we done the insertion it is out of balance and where have we done the insertion in the left right subtree so what we have here is this so we think a double rotation a left right will fix and then we update the height it may not need a new height i think its height will be three after that rotation and then we pass control back and the heights are updated again any questions i dont want to do the rotation here the point is that we can do these things after we insert the node in its correct place lets look at some code yuck too much code for one function so lets take a tiny piece of it and examine that in fact you know what describe what is going on in this code you can even start with the function signature sure in fact you can probably fill in the blanks if you look at this code you can fill in the blanks and i should point out that there is no right right and left left rotations
we still haven't found the right spot. we still haven't quite found the right spot, but this is null when this guy is null all we have to do is make a new node and return. so we make a new node and return to the black calling box. the function corresponding to the black triangle. where this blue one is the root. now were gonna do these steps. is it out of balance in the black triangle. is there an imbalance? ok so we don't need to rotate. this should be indented probably. And now does its height need to be updated? yes, so we update its height. right. so now the height of that guy is one. I'll just put it in there, why not i've never really done that before. and now we've computed execution, we have accurate heights of subtrees. and now we pass control back to the green calling function, the recursion at the green level. ok and we follow those steps. is there an imbalance? no so no rotation necessary. do we have a new height? how do we compute that new height. it's the maximum of those 2 plus 1, so that becomes 2. there is a 2 written in there, i'm just gonna go with it. Alright fine, and then we pass control back. Is there an imbalance here? no, so no rotation necessary, but we should update the height, is there a new height? yes, this one becomes three. right, 1, 2, 3. and again its just a comparison of heights and sub nodes and subtrees. and then we pass control back out to the blue.pass control back out to the blue, and what do the steps say. check for imbalance. is it out of balance? yes ok. its out of balance and where have we done the insertion? its out of balance and where have we done the insertion. in the lefts right subtree so what we have here is this. right so we think a double rotation. a left right rotation will fix. and then we update the heights. it may not need a new height but i think its height will be 3 after that rotation, and then we pass control back. ok and then heights are updated again. ok any question about that? i dont want to make the mess of doing the rotation here its not the point. The point is that we can do these things after we insert the node in its correct place. ok lets look at some code. yuck! yuck! this is way too much code for any one function. its way too complex. ok so lets just take a little teeny tiny piece of it and examine that. oh in fact you know what id like you to look at it with your neighbor, and just sort of describe to each other whats going on in this code, you can even stat with the whole function signature if you like. in fact you can probably fill in the blanks. if you look at this code you can probably fill in the blanks. And i should point out that there are no right right and left left rotations.
We still haven't found the right spot, right? Still haven't quite found the right spot But this is null. when this guy is NULL, all we have to do is to make a new node, and return So we make a new node, and return to the black calling box, the function corresponding the black triangle, where this blue one is the root now we gonna do these steps Is it out of balance? In the black box, in the black triangle Is there inbalance? No, ok So we don't need to rotate, this should be indented, probably And now, does it height need to be updated? Yes, so we update its height, right So now, the height of that guy is 1 I will just put it in there, why not And now we have computed execution, we have accurate heights of subtrees, and now we pass control back to the green calling function, the recursion at the green level And we follow the steps, is there inbalance? No, so no rotation is necessary Do we have a new height? How do we compute the new height? It's the maximum of those two plus 1 right? So that becomes 2 There is a 2 written in there, I will just go with it Alright, fine, and then we pass control back. Is there inbalance here? No, so no rotation is necessary, but we should update the height. Is there a new height? Yes, this one becomes 3, right? One, two, three And again its just a comparison of heights in subnodes, subtrees Alright, and then we pass control back to the blue Pass control back to the blue And does the steps say? Check for inbalance. Is it out of balance? Yes, ok It's out of balance, and where have we done the insertion? It's out of balance, and where have we done the insertion? In the last right subtree. So what we have here is this right? So we think double rotation, a left-right rotation will fix And then we update the height, it may not need a new height, but I think the height will be 3 after the rotation And then we pass control back Ok then the heights are updated again Any question about that? I can't really, I can't really make a mess of doing the rotation here, it's not the point The point is that we can do these things after we insert the node in its correct place Ok, let's look at some code YUK, YUK, this is way too much code for any one function Ok, it's way too complex So let's just take a little teeny tiny piece of it and examine that And in fact, you know what, I'd like you to look at it with your neighbour and just sort of describe with each other what is going on in this code You can even start with the whole function signature if you like In fact you can probably fill in the blanks, if you look at this code you can probably fill in the blanks And I should point out that there is no right-right and left-left rotation
Alright, should we chat? Okay, first let's make sure this sort of things that we thought it should do from the step on the previous slides. so notice that this is, well, if I ask you to describe what this is, what would you say? Base case, good. That's the base of recursion. It's simply create the node. Huh, The reason this works to just set t equal to the new tree node is because we have t pass by reference in the parameter. Okay, there some. I did. Is that cool? Magical. Alright, any question about that? So that creates the yellow node. Okay. Then the rest of this, if you hide this conditional, it looks just like a recursion insertion into a binary search tree. And in fact, that's what happens first. In each of these cases, the first thing happens is the recursive call. So everything follows the recursive call. So, there is inserting into the proper place from previous slide, here check for imbalance. Wait. There is an imbalance, do the right kind of rotation. This is diagnose thing what kind of rotation you need. And after all of that is done, before you move up, before you cast control out of the calling function, you recompute height. You may have to look at your own paper for that. You update the height of the parameter node. Any question about that? My desire to answer your question what has to happen or how would it happen we do things after the insert or walking of the tree? Any other questions about that? I guess we should fill in the blanks. Huh, so, what goes in this blank? It's easiest one. Okay, it's out of balance, and longer on the right. So we need a left-rotation. This one is a right-left, because this has to be some kind of left-rotation. Imbalance has to be some kind of left-rotation. And then up to the top boy, everything look symmetric, and I write this code without thinking about it, and, hope that I can catch any problem in the test. Any questions about it? So this is kind of code that I would write this part with some thought and do some substitution there. Now, I don't like this code. I particular don't like the fact that this and that are kind of the same. So I might refactor this a little bit, and make some helper function. But this is a little tough, I'm not really sure pass a little flag parameter that help you diagnose right and left. Be clever you name your variable. I'm not sure how I would refactor this. I know this is quite readable here, maybe I wouldn't at all. Because she know what? Height is always going to be the maximum of the height of my two children, which I have updated plus one. No, No. This parentheses closes this one. And notice here that I got a helper function that deal with the case that one of them is null, because I don't deal with that here. Same thing true here. Balance factor gonna deal with the case where t->right is null or left is null. I don't. Alright. Any other question about this?
Yup, yeah yeah. So he's asking about how many helper functions you need for this. I need one for height, I need one for balance factor, I need one.. I need four for the, uh.. four for the rotation cases. Yeah, that's a lot but yeah. I need those constructors and you know, this is.. this is what we're good at this point. This is what's gonna get you a gazillion dollars, but not me. Okay... Alright, AVL tree removal. What happens if I remove nine? Oh...... [gibberish]. Oh yeah okay. First of all, is this tree in balance? Is this a balanced tree? Yes it is. Okay, there is nothing obviously out of balance I don't think. You can pretty much eyeball it here. What happens if I remove nine? It's even better, I got a better one. What happens if I remove ten? Ha ha. Yeah. Alright. Alright. So lets trace this a second. This is just an example. I wanna remove, I'll remove nine. Ten is structurally the same. Okay. So we remove nine and we have every reason to believe, we have every reason to believe the process for removal mimics that of insert, that is that we can kind of test after we change the structure of the tree wether or not a rotation is necessary. Now what's interesting about this of course, is that binary search tree removal invokes an in order predecessor, which invokes.. may invoke further cutting off of the tree and so actually it's not even just in the um removal where you need this checking of height but also um in the.. in order predecessor evaluation portion. So, but, we're not gonna do those details here, that's for lab. For now, we're just gonna remove nine. So now my question is what kind of rotation fixes this tree? Some kind of left rotation, correct? Some kind of left rotation. Which kind of left rotation? Single or double? Double, that's right! Because at that point the balance factor here, the balance factor here would be two, the balance factor here would be negative one. And so its a left right rotation that's necessary. Oh that's why. Because here you can use the same balance factor function ha ha I see. So in the end, after we do this, I'm gonna put this in red because you'll be able to see it, you'll be able to see what happens. In the end, I'm going to have eleven here, ten there, and twelve here, still. Okay. And this will be gone because the rotation will result in this. And then we will complete execution of that recursive call and come here and what happens? Oh..... Now it's out of balance. Okay, you see that? Because it's long on this side, we've shortened one that was barely long enough right? This side was barely long enough and we've shortened it. So that creates another imbalance. So what kind of rotation is gonna fix it? A right rotation, right! Yes. Very good. And what do you think? A right... or a double or a single? Single, I think either one of them works in this case but.. we might as well go single here, right? So, it's going to result in a right rotation about eight. Now, think about it. This tree rooted at 8 might barely have been long enough and we shortened it. Okay, it might be a subtree. This.. this tree that I have painted here might be a subtree in some larger structure and it might barely have been long enough, tall enough and we just shortened it. So it's possible that actually fixing things at eight would cause the need for rotation farther up the structure. So it is possible in fact that when you do a removal, you may have to do rotations all the way up the tree. Okay, any question about that? You see how that's possible? Okay... uhh.. let's move on. We'll see how far we get here. Just a little bit. So....
The good news would be O(n). Otherwise you know we might just as well let the binary search tree to run them their way, do what they are going to do anyway, okay? So the next few minutes are going to be spend arguing that AVL trees, by, using their definitions, AVL trees resulting trees whose height are worse case O(lg(n)). Now, I can't make this argument very cleanly without first reviewing the definition of Big-O from CS173. Okay? Anybody need some [gibberish] points? You wanna refresh me of the idea, refresh me of the ide of the definition? What is the definition of Big-O? Yes, it is the worst case running time, it is the an upper bound on the running time. Okay? But, what is the definition of it? I will give you a hint, you will need that symbol. Okay? Oh What? Yeah ready Nathon? Yeah a function of Big-O of n, is a function of g(n), if and only if, okay good. Exist a constant c so that......Good.....Very good.......So i am going to take that for sufficient large n and turn it into that some other that [gibberish] variable k and make it when n is greater than k. Alright oh what the heck? That was impressive. That was a [gibberish] a environment that I might like to give you a hint, that is very good. Okay, there exist constant c and k so that the function is less than some factor of this other em....this function, when n is big enough. Okay? So now, here is the deal. This function that we are going to argue about is we think logrithimic. Okay? f of n. We think it is logrithmic, but we don't know for sure. We don't know, we don't know that it is like for sure, but we do know that the one that we are going to compare against is logrithmic. So I am going to put that on here also, okay? So maybe here. g of n is equal to log of n. And pretend that this is increasing. I kinda dipped it down, I shouldn't have. Now alright we are not going to make the argument that our function is less that g of n. But we are going to take some constant factor of g of n and maybe this goes like this, [Gibberish]. And we are going to make the argument that our function is less than that one, when n is greater than some value k. Is that make sense. You've probably seen this graph before right? Alright, this is what big-O of n means, this is what it is means for a function to be big-O of another function. Here is the problem with it, i can't do the problem. I will tell you the problem with this next time. The start of next time.
ok.let's work. So i wanna talk for a minute about for the exam coming up. So i wanna make sure you hear there was the exam on Tuesday, not Wednesday. Wednesday is the pain in the ass. We didn't like it very much. So we are moving it back to Tuesday. I'll leave that in red for you. And the conflict exam should you need it? It's the following morning, so that would be Wednesday morning. I like to get all these taken before class meet, but we can be a little bit flexible inside the morning window, larger morning window. Let's see, there will be review session this weekend, I'm still waiting to hear from course staff when they would like to do them, and for room reservation, we will make the room reservation then we will let you know. So, if you are not yet connected to the class on the piazza, now is a good time to do so, because thats where we will announce it, where we will announce the review session this weekends. We talked about this morning in the format for the exam will be very similar to the past exam, which means multiple choice, lots of running time questions, so we will paint a little scenario for you and ask how long will this take, how long will this take. And, let's see, and a couple of programming questions or did you understand for the work you did for the mps type questions. One thing that would be different is there will be an exam booklet decoupled from the exam solution papers, so it doesn't surprise you, you will be writing the solution on the page we will then scan for improve efficiency in grading. So, don't let us surprise you when you get there and your exam booklet is separate from your long solution paper even. Bubble sheet does well of course. i think thats all i wanna say about the exam today. Like i said, we will keep you price of opportunity for review. Are there administrative question before i start,do you have anything you wanna ask about it? I haven't really told you anything so The material to be covered is everything from stacks and queues, through Friday. And if i don't start on the material, you miss out the chance to be test over Btrees, so i better get started. Last time we sort of refresh our memory for the definition of Big O, the key observation here is that we are looking at, we are trying to access an upper bound on the running time of our algorithms. So in this definition, f(n) represents the true running time of our algorithm and g(n) is some function that we use to communicate its quality, the quality of the algorithm or the speed of the algorithm. Now, thats said, this inequality allows us to make g as big as possible, but smaller is better when you are talking about the quality of an algorithm. So typically when we talk about big o, we have a function here and we want the lowest possible version of that function, the lowest possible function that we could put in there. So we say we want a tight bound, tight upper bound on the running time, and that is, just to iterate because we use this big o to reflect the quality of our algorithm. Nobody who can run a four-minute mile goes around saying I can run a mile in less than eight minutes. Thats what I'm talking about here. They say oh yeah I can run a mile in less than four minutes. Like they get down as low as possible.
Ok let's work. So I wanna talked for a minute about the exam coming up. Tuesday. So I wanna make sure you hear these words, the exam is on Tuesday, not Wednesday. Wednesday was pain in the ass we did like it very much. So we are moving it back to Tuesday. I'll leave it in red for you. Umm and the conflict exam should you needed is the following morning, so that will be Wednesday morning. Like to get all those taken before, umm, class meet. But we can be a little bit flexible inside the morning window, the larger morning window. Umm, let's see there will be reduce sessions this weekend and still waiting to hear from course staff when they would like to do them. Umm, and from room reservations actually with them we need to make the room reservations. Then we will let you know. So umm if you are not yet connected to the class on the piazza. Now it is the good time to do so. Because that's where we will announce it, that's where we will announce the review sessions this weekend. Umm, we talked about this moring in the format for the exams gonna be very similar to those of the pasting exams. Umm which means multiple choice, lots of running time questions. So we will paint a little scenario for you and ask how long will this take, how long will this take. Umm and let's see, and then a couple of programming questions or, you know, did understand the work you did for the MPs type questions. One thing that will be different is that there will be an exam booklet decoupled from the exam solution paper. So just sort doesn't surprise you. You will be writing your solutions on a page that we will been scaned for improve the effeciency in gradings. So don't let it surprise you when you get there and you exam booklet is seperate from your long solution paper even. Bubble sheet does well of course. Ok, I think that's all I'm wanna say about the exam today. Like I said, we will keep your priced of oppotunities for review. Are there administrative questions before I start? Do you have anything you wanna ask about it? I really told you anything so. The material to be covered is everything from stacks and queues through Friday and if I don't start on the material you'll miss out on the chance to be tested over B trees. So I'd better get started. Umm, last time we sort of refreshed our memory for the definition of big O. The key observation here is that we are looking at, we are trying to assess and upper bound on the running times of algorithms. So in this definition, f(n) represents the true running time of our algorithm. Ok? Represents the true running time of our algorithm. And g(n) is some function that we use to communicate its quality, the quality of the algorithm or the speed of the algorithm. Quality. Now, that's said, that's said, this inequality, this inequality allows us to make g as big as possible. Right? But, smaller is better when you talking about the quality of a running of an algorithm. So typically when we talked about the big O. And we have a function here. We want the lowest possible version of that function, the lowest possible of function that we can put in there. Ok? So we want, we say we want a tight bound, tight upper bound on the running time. Umm that is, again just re-iterate because we use this big O to reflect the quality of our algorithm. Nobody who can run a four-minute mile goes around saying Oh yeah, I can run a mile in less than eight minutes", right? That's what I'm talking about here. They say Oh yeah, I can run a mile in less than four minutes." right? Like they get down as low as possible.
Any question about that? So, if we forget to say it, we will always mean the least bigO possible. You could probably recognize that I could put a 2^n and that will hold in almost everything we do. Alright let's get started. I'm going to draw last time's picture very quickly. I tried to do it in powerpoint and I'm not a powerpoint user. So I failed. So here is running time of our function. Here is the running time of our algorithm. This is the function reflect it. We don't necessarily know how it's characterized. We don't know it has to do with all kinds of things that are not necessary. We don't know necessarily what kind of function it looks like. But we have a feeling that there is this other function somewhere that we can use to reflect the running time of our function. We also don't know what this function looks like. It might look like something like that. In fact this one is what we do know what it looks like. In the case of this particular example, we are going to argue that the running time is log in the size of the data. The reason we suspect that's appropriate running time is because of the structure of our tree. Because the heights of the balanced binary trees. We didn't just pull this out of the air. It was sort of a good guess based on the way our tree split our data in half. In fact, for regular binary trees we couldn't say this. We couldn't say logn here for regular binary search trees. We couldn't guess logn. We couldn't prove it. But in the definition here, we allow for some. We allow for some function, whatever it is, to be pushed up by some constant scale factor. Positive scale factor whose intention is to push that function up for a little bit. We also allow for some muss at the start. I'm going to draw some c times g of n in kind of exaggerate because there is something I want to illustrate very concretely on this picture. So I'm going to draw the c times g of n sort of like this. So this is c times g of n. Maybe I have g of n drawn poorly. Doesn't matter much. OK. So now is f of n greater than c times g of n? Sorry, is f of n greater than c times g of n? Like we want in this inequality is that f of n less than c times g of n. Sometimes it's the right answer. Sometimes it's forever less than eventually forever less than... yes. So we have a bound here right? Here. Beyond which f of n is forever less than c times g of n. If I to label this right here, this on the x axis, what would it be? That's right, that's k. Any questions about that? I'm doing this carefully here. I'm actually think this should be done carefully in 173 I don't know if it is or not. I'm doing it here carefully because we are going to it turns out that making this less than or equal to argument isa pain in the neck. OK. There is all kinds of like, potential for all rounding and floors and ceiling and I don't want to deal with that kind of stuff. I don't know about you. So what we are going to do instead is to invert the argument completely. So we are going to completely invert this picture. I haven't practiced it for a while. It has been four years since I drawn this picture. So let's see if I can do it. So where is f of n go now? In the inverted picture. It goes like this, right? Is that what f of n looks like? g of n as I have drawn here. It goes a little bit farther from the axis and stays forever on the back side of the f of n. So g of n looks like this. Right? And c times g of n now looks like this. Yes? Did I do it right?
Okay and now this is gonna... and the line for k is here, okay. all right so now what we're going to do, so, now these are actually these are no longer the right labels right? This is if this is N and this is H. Then these are now f inverse of H and G inverse of H(s) and this is now a slightly different C and this is G inverse of H. and now what we're going to be looking for is a diffrent k as well. K prime and this'll be a c prime, but we're gonna make the argument that f(n) is now, the inverse argument that f(n) is now bigger than, f inverse of h is now bigger than c prime, g inverse of h, okay. It's exactly the same picture though, its just the labeling that's different. I didn't draw the graphs differently though, right? yes, uh huh. Ya because i still want it to be a function, i still want this to be the domain, in fact that's exactly what i am doing, is changing the domain of the function, to one that is dependent on h instead. Yeah I have g inverse of h there. But f and g still live there. so what we're gonna do is take f(n) switch it over to f inverse or g(n) switch it over to g inverse and then switch it back, so we can make the argument that we want. It;s just that this argument is much easier to make because it says that the number of nodes in a tree of height h is at least this much, its lower bounded by this much. And that turns out to a super easy argument. Alright so an upper bound, im gonna read this out loud i know how you love when professors read their power points. an upper bound on the height for a tree of n nodes, thats that picture, is the same as a lower bound on the number of nodes in a tree of height h, and this is whats going on mathematically this inversion, any questions about that? is it okay? alright, its a little trick it should be in your toolbox of proving things about commontorial structures. proving the inverse about the inverse. But im not sure anybody ever really talks about it explicitly its one of those things that my math professors used to do and i went how did you know to do that? Now i know. okay so here's how we're going to do this, we're going to uh, talk a lot about this red function we're gonna talk about this red function, sort of the green one as well they end up being pretty much the same in this example. okay so, n is what we're gonna use to communicate the true number of nodes in an AVL tree of height H, so n is the true number of nodes in an AVL tree. okay, so n you don't know what it is for sure, but if the tree has height h we're going to use n(h) to be the smallest possible maybe ill put a little h here. So we're paramaterizing it by h sort of. But N(h) because it may have various values. N(h) is the smallest such tree, so N(h) is the smallest AVL tree and when i say smallest i mean by the number of nodes.
Hello. Ok and now this is, oh and the line for k is here. Ok? Alright, so now what were gonna do, oh so now these are actually, these are no longer the right labels right? This is if this is n and this is h then these are now f inverse of h and g inverse of h yes? And this is now a slightly different c and this is g inverse of h ok? Alright is that clear? And now what were going to be looking for is a different k as well, ok. K prime and this will be a c prime, but were gonna make the argument that f of n is now. F, yeah. The inverse argument that f of n is now bigger than c times. F inverse of h is now bigger than c prime g inverse of h, ok? It's exactly the same picture though it's just the labeling that's different. Yeah *Audience question*. Uh huh, I didn't draw the graphs differently though right? Yes, uh huh. Yeah because I still want it to be a function, I still want this to be the domain, in fact that's exactly what I am doing is changing the domain of the function to one that's dependent on h instead. Yeah I have g inverse of h there, ok? But there's still f and g still live there. So what were going to do is take f of n, switch it over to f inverse or g of n or switch it over to g inverse and then switch it back so that we can make the argument that we want, ok? It's just that this argument is much much much much much easier to make, because it says that the number of nodes in a tree of height h is at least this much it's lower bounded by this much and that turns out to be super easy argument, ok? Alright so an upper bound, I'm going to read this out loud. I know how you love it when professors read their PowerPoints an upper bound on the height of a tree with n nodes that's that picture is the same as a lower bound on the number of nodes in a tree of height h. And this is what's going on mathematically, this inversion. Ok, any question about that? Is it ok? Alright, it's a little trick, it should sort of be in your toolbox of proving things about common structures just proving the inverse about the inverse. Uh but I'm not sure anybody ever really talked about explicitly it's one of those things that my math professors used to do and I went how did you know to do that? Now I know. Ok, so here's how we're going to do this, we're going to talk a lot about this red function here. We're going to talk about this red function. Sort of the green one as well, they end up being pretty much the same in this example. Ok, so n is what were going to use to communicate the true number of nodes in an AVL tree of height h so n is the true number of nodes in an AVL tree, ok? And you don't know what it is for sure, but if the tree has height h we're going to use n of h to be the smallest possible, maybe I'll put a little h here so we're parameterizing it by h sort of, but n of h is not a function because it may have various values. N of h is the smallest such tree, so n of h is the smallest AVL tree, and when I say smallest here I mean in number of nodes.
Hello, okay, and now, this is O and the line for K is here. Ok. Alright. So now what we're gonna do. So now these are actually, these are no longer the right labels, right. This is, if this is N and this is H, then these are now F inverse of H, and G inverse of H, yes. And this is now a slightly different C, and this is G inverse of H. Ok, alright, is it clear? And now what we're gonna be looking for is a different K, as well. Ok. K prime and this will be a C prime, but we're gonna make the argument that F of N is now.. or F yeah, the inverse argument that F of N is now bigger than C times.. I'm sorry, F inverse of H is now bigger than C prime G inverse of H. It's exactly the same picture though, it's just the labeling that's different. Yeah. Uh huh. I didn't draw the graphs' differently though, right. Yes, uh-huh. Yeah, because I still want it to be, I still want it to be a function. I still want this to be the domain. In fact, that's exactly what I am doing: is changing the domain of the function, to one that's dependent on H, instead. Yeah, at G inverse of H, there. Ok, but there's still F and G still live there. So what we're gonna do is take F of N, switch it over to F inverse or G of N, switch it over to G inverse, and then switch it back. So that we can make the argument that we want, ok. It's just that, this argument, is much much much much easier to make because it says that the number of nodes of a tree of height H is at least this much. It's lower bounded by this much. And that turns out to be a super easy argument. Alright, so, an upper bound... (I'm gonna read this out-loud. I know how you love when professors read their power-points). An upper bound on the height for a tree of N nodes (that's that picture) is the same as a lower bound on the number of nodes in a tree of height H. And this is what's going on mathematically. This inversion, okay. Any question about that? Is it okay. Alright. It's a little trick. It's sorta, it should sort of be in your toolbox of proving things about combinatorial structures. Just, proving the inverse about the inverse. But I'm not sure anybody ever really talks about it explicitly. It's one of those things my math professors used to do and I went how did you know to do that", now I know. Ok so, here's how we're gonna do this. We're going to talk a lot about this red function here. We're gonna talk about this red function. Sort of the green one as well, they end up being pretty much the same in this example. Ok, so N is what we're gonna use to communicate the true number of nodes in an AVL tree of height H. So, N is the true number of nodes in an AVL tree. Ok, so N, you don't know what it is for sure, but if the tree has height H, we're going to use N of H to be the smallest possible. Maybe I'll put a little H here. So we're parameterizing it by H, sort of. But N of H is not a function, because it may have various values. N of H is the smallest such tree. So N of H is the smallest AVL tree. and when I say smallest here mean in number of nodes.
OK, let me question about that
good? ok. classic balanced but we have already talked a little bit AVL trees are not the only balanced trees.red black trees are another.there are a gazillion slight variations of each.each corresponding to the phd thesis of somebody in the 70'S. Maybe the 60's.Alright so ugh so there are probably variations thereof but these are classic and any adaptation is probably you know an addition of record key things or some constant time access to part of it things like this.so here are the key contrasts to all of them. Red black trees actually allow for a little strings of red and black parents so the overall height is bounded by a a factor 2logn. we proved 2 logn for avl trees but infact if you solve that recurrence more exactly you could get it down to 1.44 max height but in either case they are log heights.The main difference is that red black trees will only have upto 2 rotations upto each operations but avl trees you might need to rotate upon remove all the way up to the tree.avl tree have no rotations along find but i feel red black trees might. Why are we doing this? why are these such great structures?They are kinda cool because we can always give a worse case bound of log n. That is good news.we don't have to worry about the order in which our data comes in.we are gonna build one of these and the rotations will keep the tree short even for ordered data. umm so that is an improvement over linked lists,arrays and also plain old binary search trees.The other thing the absolute best thing about avl trees is that you can use them to solve other harder problems. The type of problems that they can solve are called range finding that is find 2 values be in the tree in which some query value falls for example or find all the values within a range of numbers that can be done very efficiently and nearest neighbor is a big one so imagine your favorite its your dream moment.Imagine your favorite avl tree, it has got keys in it and it is balanced.And i come to you with keys and i dont really care if the key is in the tree i want the key closest to this one. AVL trees can be used to to do that whereas other faster dictionary structures cant. MP6 is actually a k nearest neighbor search in it in a slightly different structure. Here is the problem.Turns out its possible if you are only looking for a particular key and you know what your keyset is it is possible to search for faster than log n time.That is foreshadowing. And then the other drawback is that we really can only build these avl tree if all our data fits in memory coz we are poking around in ram for these memory addresses for these keys and our data might be so big that infact doesn't even fit in memory.These 2 observations define the next two structures that we are gonna look at and we are gonna go bottom to top and later actually after your exam we are gonna address this issue. So that's the setup if the data is so big that it doesn't fit in main memory where we are gonna put it? Okay so I have got data oh i had this very cool weird experience about i dont know 5 years ago or so so you wouldn't years ago i was sitting in dan roth's office and we were talking about doing some research on some data that involved calling the web and i was like oh my gosh the web is so big and he looks at me and like i am crazy because the web is sitting in those 4 hard drives behind you. it was early of bunch of terabytes drives sitting there but it still was sort of cosmic moment where this this i thought was so huge actually fit on dan roth's desk. it was a little strange for me but nonetheless that entire web no matter what fraction of the web at the time that web wouldnt fit into the ram. so we couldn't build an avl tree out of all urls for example. We just couldnt do it Okay so the answer here is no
Classic balanced but we've already talked about a little bit, a little bit about this. AVL trees are not the only cool balanced trees. Red black trees are another. there are probably a gazillion slight variations of each. each corresponding to a PhD thesis of somebody in the 70s. maybe the 60s. alright? so.. so there are probably variations thereof but these are classic and any adaptation is probably, you know, an addition of record keeping or some constant time access to part of it. things like this. okay. so here are the key contrast to them. red black trees actually allow for, uh, little strings of red and black parent so the overall height is bounded by a factor of 2logn. umm. we proved 2logn for avl trees, but in fact if you solve that recurrence more exactly, you could get it down to 1.44 maximum height but in either case they're logarithmic height. the main difference is that red-black trees only will have up to two rotations per each operation but for avl trees you might need to.. umm.. rotate upon removal with the tree. umm. avl trees have no rotation on find and I believe red-black trees might. I can't remember for sure. okay. why are we doing this? why are these such great structures? umm they're kinda cool because we can always give worse case bound of logn. okay that's good news. we don't have to worry about, you know, the ordering which our data comes in. we're gonna build one of these and the rotations will keep, uhh, the tree short, even for ordered data. umm so that's an improvement over linked-lists, arrays, and also plain old binary search trees. the other thing, the absolute best thing about avl trees is that we can use them to solve other harder problems. the type of problems that they can solve are called range-finding, that is find a, uhh, find two values be in the tree in which some query value falls, for example. or find all the values within a range of numbers. that could be done very efficiently. and nearest neighbor is a big one. nearest neighbor is a big one. so imagine your favorite, it's your dream moment. imagine your favorite avl tree. its got keys in it, it's kind of balanced. and I come to you with a key and I say, I don't really care if this key is in the tree, I want the key closest to this one" avl trees can be used to do that whereas other faster dictionary searches cannot necessarily. so this is a big one for avl trees. umm mp6 is actually a k-nearest neighbor, has a nearest neighbor search in it. it has a slightly different structure. okay. so define some problem. let me show you. here's a problem. turns out it's possible if you're only looking for a particular key and you know what your key set is, it's possible to search for it faster than logn time. *gasp*. that's foreshadowing. dun dun dun. and the other drawback is that we really can only build these avl trees if all of our data fits in memory. coz we're poking around in ram, right? for these memory addresses for these keys, and they, our data might be so big that it in fact doesn't even fit in memory. we're gonna, these two observations define the next two structures that we're gonna look at. and we're gonna go bottom to top. so we're gonna do this one first and then later actually after your exam we're gonna address this issue. okay so that's the setup. if data is so big that it doesn't fit in main memory, where are we gonna put it? okay, so i've got data. oh, I had this very cool, weird experience about, I don't know, five years ago or so. So it wouldn't, I don't even know. Five years ago or so, I was sitting in Dan Roth's office and we were talking about doing some research on some data that involved crawling the web. And I was like, oh my gosh the web is so big". he looks at me like I'm crazy coz, web is sitting in these 4 hardrives right behind you. like, it, he had this, it was kinda early for, to have a bunch of terabyte drives sitting there but he had a bunch of terabyte drives sitting there and, you know, it wasn't all of the web but it was still this sort of cosmic moment that this thing that I thought was so huge actually fitted on Dan Roth's desk. That was a little, a little strange for me. But nonetheless, that entire web, no matter what fraction of the web it was at the time, that web would not fit into ram. so we couldn't build an avl tree out of all the URLs, for example. we just couldn't do it. umm.. okay so the answer here is no.
not going to do this slow, ssds are about three hundred megabytes per second, yea both of these are slow compared to the number of instructions you can do, it's weird, I can do some things in the front of the room but like basic arithmetic no no. Oh no don't ask me that, alright fine, so let's think about an AVL tree that sorts what i consider to be lots of data, okay? consider the US driving records so lots of data, how many records do you think there are? make a guess, this is one of those questions google is going to ask you, how many drivers are there in the US, three million is certainly an upper bound, that's about how many people there are, i think i read last night there's like a hundred and sixty million current US driving records so over time it's increasing of course like twenty years ago only half the adults drove, really? but the cool thing is in twenty years it will go back down again right. we didn't let our teenager get a driver's licence because he didn't want one either because google cars are going to be real. he'll be riding in an autonomous vehicle, he will never have to drive,its cool. Okay yeah tesla is going to beat him okay so lots of records, let's say three hundred million, okay how much data, oh my gosh. how much per record, i don't know. three hundred million times three megs each so if you have a picture there a meg each. i don't know what is that. it's like gig. that's not alot. okay here's the point, i'm sweating so badly, this is too deep okay. sorry i didn't look at notes before class ok i can't remember, okay let's say AVL tree is thirty deep which means that you may have to look for records ,you have to do thirty comparisons down an AVL tree to get to your data now that's all fine if you're AVL tree is sitting in memory because you can access that memory super fast, those operations are quick, thirty comparisons who cares but here's what really is happening, here's a cartoon version of what is really happening. so suppose this is the AVL tree of US driving records okay and suppose it does not fit into ram so you do a find, i want to find US driving record number sixty six, okay I need some records, my disk is way out there, you have to go all the way out say mr AVL tree give me a key, bring it all the way back, i should even walk slower right, all the way back and you go sixty eight, bigger or smaller? you compare the two. okay? and that happens super fast,okay i need the other part of the tree.
not going to do this slow ssds are about 300 MB per sec both are slow compared to the number of instructions you can do its weird i can do somethings in the front of the room but not basic artithmetic 4+8 is i dont know lets think about an avl tree that is considered to be lots of data consider the us driving records how many records do you think there are make a guess this is a question google will ask you how many drivers in the us 300 million is an upper bound how many people there are 160 million current us driving records increasing 20 years only half adults drove the cool thing is in 20 years it will go back down we didnt let our teenager get a driving licence because google cars are going to be real he will ride in an autonomous vehicle tesla will beat him how much data how much per record 300 million 3 megs each so uhh you have a picture there i dont know what is that its only a gig thats not a lot okay heres the point i am sweating so badly this is like this is too deep its about 28 tall i did this once i didnt prepare today i didnt look at notes i cant remember lets say the avl tree is 30 deep what that means is you may have to look for you may have to do 30 comparisons down an avl tree to get to your data thats all fine if your avl tree is sitting in memory because you can acess that super fast 30 comparison who cares heres what is really happening a cartoon version of whats really happening suppose this is the avl tree of us driving record and suppose it doesnt fit in ram you do a find i want to find number 66 heres what happens i need some driving record my disk is way out there you have to go all the way out mr or ms avl tree give me a key bring it all the way back walk slower bring all the way back 68 bigger or smaller than 66 that happens supper fast i need the other part of the tree
And you go out, and you get the part containing 51, and you bring it back. So, there is this big trip that happens from your conceptual notion of the AVL tree to the disk, and this is very slow. And you bring the data back, and the comparison is quick, and we say okay, we need this." And again, you know you go out, and you get this [vocalizing, ohh]. Ok, and then you say you need this, and you go out and you get it from another spot on your disk. And finally you go out and you get it and you go, Oh yay, 66, that took a long time." Ok, so this is bad. So shallow trees are basically imperative. Because, they minimize the number of trips that you have to take to the disk. Here's the other thing, here's the secret, here's the secret I didn't tell you: Back when I was over here, getting the key off the disk, over here, way over here, I didn't just pick up one key, what's transferred back is actually a block of data. A whole block of data, ok that's the bandwidth of the interaction with your disk. Now, it would be great if a lot of searching could happen in all of that. So, we want a structure that has a shallow tree, and takes advantage of relevant data in the nodes, in a block. So, my picture of what's really happening is you get a bunch of data from your disk, even if you're only interested in part of it. Ok, any question about that? Alright, I have something fun to show you. This is a b tree, this is what we call a b tree, so I read about it a little bit, I don't know what b tree stands for, but the speculation is that it stands for block, ok, because this is a one node, b tree. Ok? Now, in fact, it's the root of one. Um, it corresponds to an entire block of data brought back. Usually they have uh um a thousand keys in them. We have only eight keys. Um, and we'll describe what m is in just a minute. So, what do you notice about those pieces of data? They're in order, that's right! So, and it's a node of a b tree, so a node of a b tree is a essentially a vector or an array of ordered keys, ok? Um, and these are the principles: Build a tree that uses one disk block per node, uh the nodes will have more than one key, and they key will be or the tree will be balanced and shallow. We'll start next time looking at an illustration of these, because they're really quite cool.
I have a question. Thank you, uhm, so i knew that this was going to happen some day, uhm but i forgot my stylus. Does anyone have a surface pro 3 stylus. May i use it? okay i owe you. Thank you, good answer. Okay, so let's work uhm, there's an MP due tonight, uhh, surprise, surprise, and there's an exam next week, we are really close to coming up with the room assignments, but we're not quite there yet, because we're trying to move, they assigned us rooms on south campus and we're trying to move everything up here so we're hoping to find rooms. Yea, yea, yea, okay you're telling me this. okay, so uhm, no body's available on Halloween to do an exam review it's just too, uhm, cob to do that. so i cant quite get anybody to do and Roahn is out of town, so his normal pen and paper, i know, he didnt ask my permission. uhm, uhh, let's see, so here, this is all up in the air, but, what i know id that we have siebel 1404 for both of those times. and i know that i have a staff person who can do one or the other but i prefer that he not do both, just because i dont wanna burn him out, and i think that he wants to do the solution party, i just dont know which night is gonna go which each event, and which sytaff people are gonna be in which ones but both of those will happen on those two nights at that time. Im just not sure whether it will be the review or the mp5 solution on which date, okay? is that clear enough? oh no in fact its totally not clear. we will keep you posted on uhh, the piazza, okay so. Raise your hand if you would like us to also send you email with the details. okay fine, okay so somebody needs to send an email reminding me that im gonna send you, just kidding. no, okay, uhm. This exam is gonna be fine youre gonna be fine. its the tree exam, you know, if you get this stuff youre gonna be fine. Okay uhh, lets work a little bit, uhh. I'm sorry i was in meetings all day and have not entirely gotten into teaching mode, okay so. we're talking about a new data structure whose interface is really that of a dictionary but whose utility applies specifically when we have ginormas data, now what constitutes ginormas data. It means data that won't fit in RAM, how big is that data? Well how big is RAM typically? When you buy RAM for your machine, how big is it?
4 to 8 gigs? Is that about it? Okay, assume you can only use half of that for, I mean at most, assume you can use a fourth of that for computation of any one given program, that's probably even an overestimate, you realize that any data set larger than a couple gigs really merits some other storage. I'm not going to analyze driving records, that's whatever, it's kind of a fake application I think. Maybe it isn't, I've never really looked into it. So, not gonna look at this. The point is, the point of it is this: If you cant fit an entire AVL tree into this immediately accessible piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it someplace else. Now, I'm gonna talk about that some place else, as if it is a hard drive. But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced structure, this one wasn't balanced so I better make it balanced, if we have some balanced structure which we think is a reasonable way of accessing our data, but our data isn't close to us, that is that balanced structure doesn't fit in memory that is fast, then if we are going to do this sort of search for thirty eight, thirty eight may be out in some place where the communication cost is high, whether it is the disk or the cloud or whatever. Is that clear? Is that clear enough? This is high communication cost. That says high communication in the font that this pen chooses to write in. But what is also true about all of this sort of remote data is that you don't get just one piece of data at a time, you get a block of data. So even if you are only looking for key thirty eight on the moon, when you go to the moon and you come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or via communication with your hard drive, or your solid state drive. So, here's the thing, you want to make sure that piece of data you get is relevant to your search, relevant to your application. And that's kind of where we were. So we're gonna define this structure called a B tree and into the B tree, into a B tree node, we are gonna throw not one key, but a bunch of keys. So you can imagine that this whole thing is a B tree node. And it corresponds to some linear function, it is some fraction of a transfer block from your disk, from remote storage. So this is some fraction of a block in remote storage. And the reason I say that it is some fraction, like a fourth or a third, the reason I say it is some fraction is because when you get the block you also need some other information too. Just like when you get a binary search tree node, you also get pointers to children, in this case you also get a collection of keys together with some other redirection. Okay, main goal, we want to minimize the number of reads from a disk or any other remote storage. Okay, I want to show you how these things work before we do a formal description and the way I'm going to show you how they work is by hopefully pushing on this link. Gnarley trees, that's new. What am I doing? That's not the one I want, I want that person but I want the big, and we just hope it exists at this point.
4-8 gig. Ok assume you can only use half of that for or a fourth of that for computation on any one given program. That's probably even an overestimate. Good morning! Heheh. And you realize that any data set that is larger than you know a couple gig, really merits some other storage OK. Um in yeah alright. So I'm not going to analyze driving records, that's kind of a fake application. Maybe it isnt. Not gonna look at this. The point is, is this. If you cant fit an entire AVL tree into this immediately accessable piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it elsewhere. Now, I'm gonna talk about this someplace else, as if it is a hard drive. But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced, and this one wasn't balanced, which we think is a reasonable way of accessing our data, but our data isnt close to us. That balanced structure doesnt fit in memory that is fast, then if we're going to do this sort of search for 38, 38 may be out in someplace where the communication cost is high. Whether a disk or the cloud or whatever. Ok. Now, the other piece, [tangent about pen stylus], all of this sort of remote data is that you dont get just one piece of data at a time. You get a block of data. Ok so even if you're only looking for key 38 on the moon, when you go to the moon and you come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or with your hard drive or SSD. You want to make sure that that piece of data that you get is relevant to your search, application. And that's kind of where we were. So we're gonna define this structure called a b tree, and into the b tree, into a b tree node, not 1 key but a bunch of keys. So you can imagine that this whole thing is a b tree node. It corresponds to some linear function. Some fraction of a transfer block from your disk. Remote storage. [repeating]. [pause]. And the reason that I say it is some fraction, is because when you get the block you also need other information too. Just like when you get a BST node, you also get pointers to children. In this case you get your collection of keys with some other redirection. Some other information. Main goal. We want to minimize the number of reads from a disk or any other remote storage. Ok. Alright. I want to show you how these things work before we do a formal description. Hopefully show you by pushing on this link. It worked! Oh. Gnarly trees. That's new. What am I doing? Ok. Alright. This is my ok. that's not the one I want. I want that person, but I want the big ok. We just hope it exists at this point.
4 to 8 gig? Is that about it? Okay, assume you can only use half of that. Or at most, assume you can use a fourth of that for, uh, computation on any one given program. That's probably even an overestimate. And, and you realize that any data set that's larger than, you know, a couple gig really merits some other storage, okay? Um, in, yeah, I'm not going to analyze driving records. That's, you know, whatever. That's kind of a fake application I think. I don't know, maybe it isn't, I never really looked into it. So, not going to look at this, okay? The point is, the point of it is this: if you can't fit an entire AVL tree into this immediately accessible piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it someplace else. Now, I'm going to talk about that someplace else as if it is a hard drive, okay? But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced structure, and this one wasn't balanced so I better make it balanced, if we have a balanced structure that we think is a reasonable way of accessing our data, but our data isn't close to us, that is, that balanced structure doesn't fit in memory that is fast, then, if we're going to do this sort of search for 38, 28 may be out in some place where the communication cost is high, whether it's a disk or the cloud or whatever, okay? Now, the other piece of- is that clear? Is that clear enough? This is high communication cost. Your pen is different than mine, it's kind of cool. I didn't know a pen was like a personal piece of electronics... a stylus. Okay. That says high communication... in the font that this pen chooses to write in. Okay, but what is also true about all of this sort of remote data is that you don't get just one piece of data at a time. You get a block of data. So even if you're only looking for key 38 on the moon, when you go to the moon and come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or via communication with your hard drive or your solid state drive. Okay? So, here's the thing. You want to make sure that piece of data that you get is relevant to your search. Relevant to your application. Okay? Alright, and that's kind of where we were. So we're gonna define this structure called a b-tree, and into a b-tree, into a b-tree node, we're gonna throw, not one key, but a bunch of keys. So you can imagine that this whole thing is a b-tree node. And it corresponds to some linear function. It is some fraction of a transfer block from your disk, from remote storage. So this is some fraction of a block in remote storage. And the reason I say that it's some fraction, like a fourth or a third, the reason I say it's some fraction is because when you get the block, you need some other information, just like when you get a binary search tree node, you also get pointers to children. In this case you're gonna get your collection of keys together with some other redirection. Okay? Together with some other information. Okay, main goal. We want to minimize the number of reads from disk or any other remote storage. Okay? Alright. I wanna show you how these things work before we do a formal description, and the way I'm gonna show you how they work is by hopefully pushing on this link. Oh, it worked! (joyous exclamation). Oh. Gnarley Trees. That's new. What am I doing? Okay. Alright. This is my... okay. That's not the one I want. I want that person, but I want the big, okay? And we just hope it exists at this point. Union find ordered dictionaries. I don't know. Ack.
Oh no! It really wants me to use their interface. Oh no! No! Oh no! Oh no! Alright. Alright, here's a random one. I'm on a random one. Sorry guys, I think I've seen this one before. Alright. Alright. So... need you to start telling me numbers, insert. Can you read that? Okay. Yes you can. This is not a good applet. Sigh. Sorry but you need this. Okay! So I'm building up a B-Tree and you notice right now that I'm basically just inserting things into the root. It's fundamentally implemented dictionary just like the AVL tree did, it's an alternative to the AVL tree. You can't see that at all. Oh my god, it's 25 and 28, okay? So maybe draw this down. They're both in the same box. Okay? I'm gonna put in 35, so I put in 35. Where did it go? Where do you think it went? So the right of 25 and 38, and then I'm gonna put in 14. Where do you think it's gonna go? To the left, still in the root node. Good. Okay! Now, I have chosen a max degree of 4. That's one of the parameters to this applet. You should be sitting there thinking what the heck is all that about? A max degree of 5! Okay? What it means is that a node can have 5 children and it has a child between every piece of data and at each end. Okay? Yes, it has a child between every key and at each end. So we now have the maximum potential degree, because we have 4 pieces of data and you know, there's no room for any more in that node. So, let me add another one and see what happens. I'm adding 52. I don't remember what our other pieces of data were. Oh! Oh! I know you cant see it, you saw what happened structurally. You want to speculate on what happened? What happened to change the shape in that way. We have 5 pieces of data, they were in order, they were ordered pieces of data, and now the structure looks like that. What happened? No speculation at all? No way?
oh no, it really wants me to use their interface, oh no. oh no.oh no. oh no. alright, alright where's a random one. I want a random one.sorry guys, i think i've seen this one before, alright. so, i need you to start telling me numbers, insert, can you read that? okay, yes you can. this is not a good applet, i'm so sorry but you need this. okay, so i'm building up a btree and you notice right now that i'm basically just inserting things into the root, it fundamentally implements a dictionary just like the AVL tree did, it's an alternative to the AVL tree, you can't see that at all, oh my gosh it's twenty five and twenty eight, they're both in the same box. Okay. um. I'm going to put in thirty five so i put in thirty five where did it go, where do you think it went, to the right of twenty five and thirty eight okay, and i'm going to put in fourteen, where do you think it's going to go? to the left, still in the root node good okay now I have chosen a max degree of four okay that's one of the parameters to this applet you should be sitting there thinking what the heck is that all about, a max degree of five okay? what it means is that a node can have five children and it has a child between every piece of data and at each end, okay? yes so it has a child between every key and at each end so we now have the maximum potential degree because we have four piece of data and you know there's no room for any more in that node, okay so let me add another one and see what happens. i'm adding fifty two i don't remember what our other pieces of data was. oh! oh. i know you can't see it but you saw what happened structurally, you want to speculate on what happened? what happened to change the shape in that way we have five pieces of data they were in order they were ordered pieces of data and now the structure look's like that, what happened? no speculation at all? no way?
Ohhh, heh, sorry. Use your technology! Ohh! Ohh! Gnarly, woah. That's cool. Ok. My child for his english class asked me for eighties idioms. Like, Mom, you were a child in the eighties, what or you were in high school in the eighties, what uh, what were some of the phrases that you ever used?" Gnarly was one of them that I told him. Yeah, heheh. How did I get, oh, forward! [gibberish] Ok, that's better, how do I, raise the thing to full screen? Ohh, it's Windows, right, it's on the other side. Ok, alright, we're gonna survive this. Ok, what does somebody want to insert? What should we insert? Three. Ok fine, three. Insert. Oh, we should watch. Three, oh where did three go? Why? Yeah it was less than 28. Ooh, this feels binary search tree ish. Right? And, it went into the other node, and furthermore, it went in its right place in order. Right? Ok I have a question for you: if I insert 36, where is it gonna go? I want you all to speculate in your own minds: where does 36 go? Right at 35, right? Ok, ok! Alright, see how it's working a little bit? Alright, somebody want to insert something into this tree? What are you curious about? Yeah? 27. Alright let's oooh, insert 27. Everbody speculate, on where you think it will go. Ok, we're gonna do this for a while, cause this is actually fun, and it's not working too horribly. I have to do this fast though. Ok, did you see that? That was cool. Alright, does anybody have something they'd like to insert into this tree? 1. 1, who said 1? Ohhhh living on the edge. [inaudible] Do you see why one is a scary thing to insert? How big can these nodes be? They can only have four things in them. If you try to put five things in them, the world is a broken place. Ok. So, let's try, ahhh, I think I can hit enter here. Ok, are you ready? Alright, what do you think is gonna happen? Alright, I'm asking that rhetorically so you all get a little picture. Ok, you ready? I hope it, oh, it wants me to push insert. Ok, fine, can I get em both on? Insert. [Cinda gasps, screams of both terror and amazement ensue from the class] I call this a vomit tree. Because it throws up the middle value. [audible laughter from the crowd] You get it? You see? Where was 14 before? So 14 lived, there was one node, and 14 was right between these two values, ok. We made that node too big, so it took the middle value and threw it up, right? Now, look at this tree and make a key observation about the relative magnitudes of they keys. The word between might occur in your response. Ok, so every node still has this ordered characteristic, right? Every node has increasing keys. And what is true about this node? Yeah? Very good, that's right. Did you all hear that? Both of they keys in this node are between the two corresponding keys in the parent node. Ok? Any question about that? Alright, yeah? [inaudible question]
oh, sorry. use your technology. thats cool. okay. my child for his english class asked me for 80s idioms. like mom, youre a child in the 80s, what are your high school in the 80s what were some of the phrases you ever used. narly was one of them that i told him. yeah. hmm. hmm. how do they get. oh! forward. i am so... okay. that's better. how do i raise the thing to full screen. oh its windows! right! on the other side. okay alright. we are going to survive this. okay. what does somebody want to insert. what should we insert. alright fine, 3. insert. we should watch 3. oh where did 3 go! why? yeah it was less than 28. oh this feels binary search tree-ish right? and it went into the other node and further more, it went into its right place in order. okay i have a question for you. if i insert 36, where is it going to go? i want all of you to speculate in your own mind where does 36 go. right of 35 right? okay. alright. see how its working a little bit? alright, lets. somebody want to insert something to this tree? what are you curious about. alright lets... oh... insert 27 everybody speculate where you think it would go. we are going to do this for a while. cuz this is actually fun and its not working too horribly. i have to do this fast though. okay did you see that? that was cool! does anybody have anything they want to insert into this tree? 1! who said 1? ohhhh living on the edge! do you see why 1 is a scary thing to insert? how big can these nodes be? they can only have 4 things in them. if you try to put 5 things in them, the world is a broken place. kay? so lets try errr i think i can hit enter here. are you ready? alright what do you think is going to happen? alright i just want to ask it rhetorically so you all get a little picture. you ready? i hope it oh. it wants me to push insert. okay fine. get them both. insert. oh! i call this a vomit tree because it throws up the middle value. you get it? you see? where was 14 before? so 14 lived there was one node and 14 was right between these 2 values. we made that node too big so it took the middle value and threw it up. right? now. look at this tree and make a key observation about the relative magnitude of the keys. the word between might occur in your response okay so every node still has this ordered characteristic right? every node has increasing keys and what is true about this node? yeah? very good. thats right. did you all hear that? both of the keys in this node are between the two corresponding keys in the parent node. okay? any questions about that?alright yeah?
Um that degree is the number of children they can have, degree is the number of edges coming out. Okay? Okay? So where is the four value? Four is the number of the keys that you have because its one less than the number of nodes coming out. So you can have five coming out. Let's fill one up and you'll see it. Well, Oh, this is so much fun. Okay, We need to insert a few values, okay? And I think you will be good if we insert a whole bunch of values over here for now, okay? Just cause I want to you see it again and then I actually want you see what happens when we throw up. I love saying that, throw up to the root when there's no room, okay? All right, so I am gonna insert a button here, maybe shrink it just a little. Oh, there! Perfect! Insert 30, umm, insert, I don't know, 40. Make sure that you are following where all these go, okay? Follow alone. You all have the speculation. Insert 40. Oh, what happened? A threw up. Threw one up. All right, fine. Now notice the degree of the root, the degree of the root is 4, right? The degree of the root is 4, it has four edges coming out of that and it has three things in it. As I said, there is a child node between every pair of this and one at each end. Notice if I hide all this, if I hide this center thing, you'll have a binary tree, pretty much a binary search tree, right? If I hide, you know, if you have one node and two things on the side, a binary search tree, right? It just behaves differently. I think I want to do something like enter 5, 7. Now what? 8? Okay? 8. Oh, Okay? Got it? We got do do this one more time. We must. It's awesome. All right, I think this middle child is feel little neglected. So, let's insert 16. That's a joke, middle child neglected, you know. I I hate it when you miss my jokes, especially when they are bad. You are ready? I am inserting 20. All right. Oh. Dung dung dung. Are you ready? Are you ready? Yes? Okay, I wish I can slow it down. All right, I am putting in 26. All right. Okay. Insert, you know, insert 26. Oh! It threw up twice. It's stupid, stupid. Okay, got it? Yes. This is a good question. It miss a giggle every time. All right so the question is if I chose a maximum degree which was odd, in fact when we talk about btree, that's called the order of that btree, the order of this btree is 5, the question is how can we deal with even order? Would you like speculate any idea? The design moment, right? How can we deal with even degree, or even orders? What do you think? You want to answer you own question with a guess?
No, a max degree is the number of children you have. Degree is the number of edges coming out. okay? Four is the number of keys that you have, because it's one less than the number of nodes coming out. So you can have five coming out. Let's fill one up and you'll see it. Well, oh this is so much fun. We need to insert a few values. I think it would be good if we insert a whole bunch of values over here for now. Just cause I want you to see it again, and then I actually want you to see what happens when we throw up. I love saying that. Throw up to the root when there's no room. Alright, I'm going to insert [gibberish]. Maybe shrink it just a little. Oh, there. Perfect. Insert thirty, insert i don't know, forty. Make sure that you are following where all these go, okay? Follow along. You all have the speculation. Insert forty. Oh, what happened? It threw up, that's right. Threw one up. Alright, fine. Now notice the degree of the root is four. Right? The degree of the root is four. It has four edges coming out of it and it has three things in it. So as I said, there is a child node between every pair of keys and one at each end. Notice that if I hide all this. If I hide this center thing, you pretty much have a binary search tree right? Or if I hide, you know if you have one node and two things on the side [gibberish] right? It just behaves differently. Alright, I think I want to do something like insert five, seven. Now what? Eight, okay, eight. Oh. Okay, got it? We gotta do this one more time right? We must. It's awesome. Alright, I think that middle child is feeling a little neglected. So, let's insert sixteen. That's a joke. Little child neglected, you know? I hate it when you miss my jokes. Especially when they're bad. Okay ready? I'm entering in twenty. Alright. Dun dun dun. Are you ready? Are you ready? Yes? Okay. I wish I could slow it down. Alright, I'm putting in twenty six. Alright. Okay. Insert twenty six. Oh. It threw up twice. Stupid, stupid. Okay, got it? Yes? This is a good question. It makes you giggle every time huh? Okay. Alright, so the question is, so I chose a maximum degree which was odd. In fact, when we talk about B-trees, it's called the order of the B-trees. The order of this B-tree is five. The question is, how do we deal with even orders. Would you like to speculate any ideas? This is a design moment. How can we deal with even degrees, or even orders? What do you think? Do you want to answer your own question with a guess?
There isn't wrong answer here. Oh introducing new key that's radical. All right, so here is, here is what you will do. There are actually structures that will do that, but not ours. Our implementation will be treat doesn't do that. Umm, so what you will do is you just chose median of whichever you want. You can choose though the less median, median or the greater median, ok, of the values. Right? It doesn't really matter. Umm, it creates a little bit of inaccurately and terms of number of keys of each one. But, umm, it just doesn't matter, all right? Does it make sense? So you still take as close as you can to the center value you use it to split the node at all. All right, any other questions about it, About this process? Ok, so, here is what I know to be true. Umm, we are gonna do analysis of this things and argue about their utility to us. Umm, excuse me as a data structure. Umm. And you are responsible for knowing about that analysis on your exam coming up. But, you won't be inplementing this untill next week and I believe you only implementing [insir]. I actually have never even played around with the lead. I don't know how you suck them back together after you remove from them. Will you waiting for that? All right, so, umm, so I I haven't even played around with that at all. All right, any questions about it? I suspected actually might be a process of you just go ahead and remove untill they get too small and then you reformat the tree sort of like resizing in arrays, sort of like when we use a linear structure we resize upward and downward. And I wanna say that in actualilty the implementation of this which isn't really cover the real implementation as an out of course structure, has to do fire lay out. How you lay out your data in a file. And that's more the subject of data base class than it is this class. I want you to know the system, I want you to know the structure exists that not all data. It's in memory and I want you to have the experience with the analysis of it. But the actual nitty gritty making this things perform, not so much for this class. Any question about that. All right, now I think if I do. Is [deeding] but if you have any queation about this structure it takes long time to change things now. Yeah? Delete 25? What you think will happen. Oh you know what, this is actually a reasonable thing. 25. I'm gonna shrink it just a little bit so we can see it as it goes. Ready? I don't know what's gonna happen here. What you think? 20 is gonna come up? Then this [famil] as 1 I don't know, I don't even know. Delete! It was a two child remove right? To put it back in? I can do this all day. I'm sorry if this is boring you. Oh see, it doesn't. No. Here. I got it I got this. I got this. Opps. And.
There isn't a wrong answer here. Oh if you insert a new key, that is radical. So what you do is you just choose a median whichever one you want, you can choose the lessor median or the greater median, of the values. It doesn't really matter. It creates a little bit of an iniquity in terms of the number of keys in each one. But uh, it just doesn't really matter. Does that make sense? So, still take as close as you can to the center value to split the node. That's all. Alright, any other questions about it? About this process? okay so here is what i know to be true. We are going to do analysis of these things and argue about their utilities to us. Excuse me, as a data structure. Um, And you are responsible for knowing about that analysis on your exam coming up. But, you won't be implementing this until next week. And I believe you only implement insert. I actually never played around with all these, I don't know how you can suck them back together after you removing from them. Where you waiting for that? Alright. So i have never play around with that at all. Any questions about it? I suspect there might be a process of you just go ahead and remove until they get too small and then you reformat the tree sort of like resizing an array. Sort of like when we use a linear structure and we we resize upward and downward. And i wanna say that in actuality the implement of this. The real implementation as out of course structure has to do with file layout. How you layout your data in a file. And that is more of a subject to the databases class than it is to this class. I want you to know the structure exists that not all data fits in memory and I want you to have the experience with the analysis of it. But the actual nitty griddy performant, not so much for this class. Any question about that? Did anybody have any question about this structure? Delete 25? What do you think will happen? Oh you know what. This is actually a reasonable thing. 25 and I am going to shrink it a little bit so we can see it as it goes. Ready? I don't know what is gonna happen here. What do you think? 20 is gonna come up. Then this one is gonna have.. I don't know. I don't even know. Delete. It was a two child remove right? Should put it back in? I can do this all day. I am sorry if this is boring you. Oh see, it doesn't. No. Here I got it. I got this.
Okay. Got it? Okay. So what we did see is that 16 came up right? If you remove 20, 16, the inorder predecessor will come up. But that one is too small. So I think it grabs one from... I just didn't see it. Should we do it? Alright. Last time, this is the last time, we should do analysis. 20, taking 16 up, okay throwing things down. Theres a lot of throwing down. So this one's quite. This one's quite combative. It's a throwdown. Okay. Alright. Can we go on? Please? Who said please? I love that you feel comfortable enough to admit that you said please. Okay. So here's the more formal description of what these things, the constraints on these nodes. And there are some key parts. So an internal node is a non-leaf node. Internal means non-leaf. Non-leaf. The number of keys in the node is the number of children 1. And, m-way tree, a b-tree of order m is an m-way tree. So maximum of m-way. You MIGHT have m children. All leaves are always on the same level, so this is new for us. All leaves hold no more than m-1 keys. So that's when throwing up happens. But the thing we didn't see very much, is that all non-root internal nodes have between, and this is the hm, ceiling of m/2, and m children, I believe. Let's see if that's written, is that right? Here? On your sheet it has it? Okay, good. That didn't make it through the various file transformations. Okay. So what does that mean about the number of keys? It's one less than ceiling of m/2. Right? The number of keys is then one less than ceiling of m/2 and m-1. Now, roots can be a leaf, so a single node, or it can have between 2 and m children. It's the only one that can have that few children. And the keys in the node are ordered. So, this is actually a key point. This piece right here, says that no node is very empty. So if this is as big as a node can be, notice that that says, that it is at least, one less than half full. Okay, so you can think of this, you can think of these nodes as being at least half full, about. It might be one less than that, but that's all. Okay, so all nodes, key observation is, that no node is very empty. No node, they changed the font, I don't know, is very empty. Except the root. Because we need some place to keep this [cuts off] Yeah? No! Aha! This is good. So let's reinforce that. This always confuses me too, I don't know why. Okay, it says here, the root can have between 2 and m children. There is a difference between the number of keys it holds and the number of children it has. How many children does this have. One, two. Even though it has one key. Oh yeah! There's this minus one thing. Okay, any questions about all of this? Of course, I have a question for you. I want you to infer, from this picture, the order of this tree. No, it's not four. Has to be bigger than four, why? Yeah, because this one has four keys in this. Right? If four where the order of this tree, we would've had vomited three. Five? Why not six? This is actually a hard question. Why not six?
Okey. Got it? What we didn't see is 16 not 20. If you remove 20, the in order predecessor will come up, but then that one is too small, so I'm thinking: grab... Should we do it? ok, there's a lot of throwing things down. This one is quite combative row down. Okay, right can we go on? Who said please? I love that you feel comfortable enough to admit that you said please. So here is a more formal description of the constraints of the nodes of some key part. So the internal node is the non leaf node, internal means non-leaf. Note that the number of keys in that node is the number of children minus 1. And a b-tree of order m is a m way tree. so maximum m way. so you might have m children. All leaves hold no more than (m-1) keys. That's why throwing up happened. But the thing we didn't see very much is this piece right here says that no node is very empty. so if this is as big a node can be, notice that that says it's at least 1 minus less than half full. So you can think of these nodes as at least half full, it might be 1 less than that but that's all. So the key observation is no node is very empty. except the root because we need some place to keep this structure. So let's reinforce that. This always confuses me too i don't know why. so it says here that the root can have between 2 and m children. How many children does this have? one, two! Even though it has one key. Oh yeah there is this minus 1 thing. Okay! Any questions? of course I have question for you. I want you to infer from this picture the order of this tree. no it's not four, has to be bigger than four why? yea? because this one has four keys in it. if four is the order of this tree we would have no more than three. five? why not six? this is actually a hard question. why not six?
Good, if you had 6, then these would all still live in the same node. Alright, let's see... Let's see what's I'm gonna ask... Oh, why not 7? This leaf implies not 4; this structure implies not 6. Why not 7? Same reason but also, these are 2 small. Any node with only 2 keys that's less than you can have for 7. 7 will have to have the ceiling of 7/2 4 children. So we need to have at least 4 children or 3 keys. So this is too small to be 7. I didn't look at the test, so I don't know if the instinct about this is good enough. Oh, how much detail we need to know about that definition. I think knowing that definition is reasonable. OK, here's B-tree search. Here's some code, represents B-tree search. I think it's kind of pseudo-code. It assumes some functions we have been articulated. In particular, it assumes a discrete function. So that we have access to some functions that when given a particular child we can find it. Now we are looking inside of B-tree node which you can sort of think of as an array. For a particular key, inside the array, x were looking for a key. Now, take a look at this code. And suggest any sufficiency, you'll find something that bugs you about this code. ...Pseudocode, I should say. What's it doing there? What's that while loop's goal? I'm asking all of you, I'm in conversation with [who?] but I'm asking all of you, what's that while loop's goal? [student answering] What's the efficient fashion. Look, we've made a big point, good job. So we have made a big deal about the fact that the keys in these nodes are ordered, right? You should never search through an ordered structure, especially an ordered array linearly. You should just use binary search, that's what you get for this. Here's the thing now. I don't care, and here's why. These are all.. each one of those is a super fast operation. They're super fast. These all happens in the CPU. The data is all sitting right there. It's this discrete that determines the running time of the algorithm. Very long running time.
Ok if you have six then these will all still live in the same. If you could have six then these will still live in the same node. Alright let's see. Will be shaped a little bit differently. Why not seven. This is implies not for these structure implies this structure not six. Why not seven will same reason these are too small any node within two key. That 's less than you can have for seven seven will have to have. The ceiling of seven over two will just have four children. or three keys. so this is too small. Too small to be seven. Okay any question about it. Alright, I am didn't look at the test. Instinct of this is good enough. I think knowing that definition is reasonable. Here is btree search. Here is some code that represent btree search. i think is kind fo pseudo code. It assume some function we haven't articulated. it assume some discrete function. We haven't access some function he can find data. we are looking insider a btree node. We can think of as an array. For a particular. So in inside array x we are looking for a key. Now take a look at this code for just a minute and suggest efficiency. You will find something that bugs you about this code. I should say. you will find something that bugs you about this pseudo code. What is doing there. I am asking all of you. What's that while loop goal. What's a more efficient point. We make a big point. We make big deal. These nodes are order. you should never search thought an ordered structure. That you should get for this. These are all. Each one of those is a super fast operation. These are super fast. These all happens very quick in the CPU the data is all sitting right there. It is statement. This discrete that determine the running the time of this algorithm very long running time.
Very long running is good enough, I think. All right, any question about that. So it doesn't really matter in the performance whether we do binary search in that case. Of course you could. And in fact, hack, these nodes, each one of them, they can be an avl tree if you want it and instead of keep your array. So you can build them into an avl if you want it, or whatever, right? Like the nodes themselves can be different structures, it's just an an array of data, just the question of how much it can hold. Okay, any question about this? All right, the height of btree determines this sort of the introduction to the analysis of this thing. Probably gonna do the analysis really quickly cause they only have 5 minutes. The height of btree determines the number of disk seeks and it's the number of the disk seeks that determines the running time. That's what we want to minimize and what we want to analyze here. We want to be able to say the height of the structure and thus the number of the disk seeks is no more that, How tall do you think these things are? How tall do you think these things are for n pieces of data? Log, did you say log, yeah, good. Log of the size of the size of the data. Now what the base of the log? M, good. Cause the each level basically allowing for dividing our data into, dividing our data by m. Okay. As we saw a case of avl tree finding an upper bound on the height is same as finding a lower bound for the keys. So that's what we are gonna do, again. Um, and we are gonna find the relationship. And this is what we are trying to prove here. All right, any question about this? Okay, fine. Um, we are going to look at, we are gonna look at this level by level. We are not gonna think recursively about this because I haven't actually define a btree recursively. Could, but I haven't define a btree recursively so we are not gonna look at it recursively. Okay, so n of h is again, we are going to say the minimum number of nodes in each level of a btree of order m. Now this is nodes in a level, not keys in a level, okay? Nodes in a level, not keys in a level. n of h is min number of keys in level h. Okay, so what's the minimum, oh, for your convenience, this will help you. Ah, yeah, this helps. We are gonna let t equals the celling over 2. So this is the number of children, the minimum number of children a node can have. We are gonna let t equal the ceiling over 2. Okay, what's the minimum of nodes, not keys, in a, uh, in the root? Minimum number of nodes, not keys, what's, what is it? How many nodes are there ever in a root. Thank you. Okay, now things get interesting, a little more interesting, what's the minimum number of nodes in the second level of the tree. If I got one in the root, how many nodes do I have? Not keys, nodes. Okay, now I lied, now things get interesting. okay? Okay, here's the root, here its children, here's the nodes, how many children might becoming off of here. Notice the degree of each of this is the number of nodes in the next level. What's the smallest value?
Very Long running time is good enough I think. Alright, any question about that? So, it doe not really matter in the performance weather we do binary search in that case. Of course, you could and in fact, hack! These nodes, each one of them, they can be a AVL tree if you want it instead of keeping you array sorted you could build them into an AVL Tree if you want it or what ever right? The nodes of themselves can be different structures, its just an array of data. Just a question of how much it can hold. Ok, any questions about this? Alright, the height of B trees determined the these sort of the introduction into the analysis of this thing. Prabobly gonna do these analysis really quickly because we only have 5 min.So the height the B tree determines the number of disk seeks determines the running time.That's what we want to minimize and that's what we want to analyze here. We want to be able the say the height of the structure and thus the number of disks seeks is no more than, how tall do you think these things are?how tall do you think these things are for n pieces of data? Log? Did you say Log? Log of the size of the data. Now, what's the base of the log? M, good Cause at each level basically we are allowing for dividing our data into, dividing our data by M. As we saw a case in AVL tree, finding the upper bound of the height is the same as finding the lower bound for the number of keys. So that's what we gonna do, again, Um and we are gonna find that relationship. And this is what we are trying to prove here. Alright, any questions about this? OK fine. Um, we are going to look at, we are going to look at this,first level by level. We are not gonna think recursively about this because I haven't defined a B tree recursively. Could but I haven't defined a B tree recursively so we are not gonna look at it recursively. OK, so, N of h, so again, we are going to say that the minimum number of nodes in each level of a B tree order m, now this is a node in a level, not a key in a level. OK Nodes in a level, not keys in a level. Ok, n of h is number of keys in level h. So what's the minimum? For your convenience, this will help you. Uh, this helps ok. We are gonna let T= the celling m/2, and so this is the number of children, the minimum number of children a node can have, so we are gonna let T= m/2/ Ok, so what's the minimum number of nodes, not keys in a root? Minimum number of nodes, not keys, what is it? How many nodes are there ever in a root?Thank you! Now things are getting interesting, what's the minimum number of nodes in the second level of the tree? If I've got one in the root, how many nodes do I have? Not keys, nodes. Now things get interesting. Ok, here is the root, and here its children, here are some nodes. How many children might be coming off here? Notice that the degree of each of these is the number of nodes in the next level. What's the smallest value?
t, good, t, thats right. the least number of nodes you should be flipping back your definition one more than the least number of t that can hold, so this is now two t, now lets do number three, note that for each node in level two, you might have these many children right? so how many are there in level three? two t squared, now we are gonna add all those up, how about level h, two t to the h minus one good, now i add those up, I'm gonna do it like this, I'm say that sum is one plus two times t to the k, remember k goes from zero to h minus one. thats my phrase of the day apparently. what is the sum, what is this. anybody know it just from top of their head, is t to the h minus one over t minus one. two times that. how many t s can be in each one of the nodes? so we counted nodes and how many t s was the smallest number of t s that can be in the root one right? but the rest of them can have how many t s do in terms of t, cause its lovely. so the totally number of t is then the number of nodes which is two t to the h minus one over t minus one, times the number of t in each node, which is t minus one. watch this. gone. gone. i love it when it works out like that, and we end out with two t square minus one plus one minus two plus minus one. two k h, two t h. any question about it? what are we gonna do next what's this results say. so this means n is at least that. is that what we want? no we want to argue about the height right? so how do we do that. Invert it. invert that inequality so the least totally number of t is t to the h minus one times two, two t to the h minus 1. write that as an inequality as I just did. rewrite that as an inequality about h, so i will race you. that means, we gotta do n over two plus one, wait, n plus one over two, log base what? log base t of that. and then i get is greater than or equal to h. so h is less than or equal to log base t of this thing. now all logs can be any other logs, right? so we have h is less as all logs are constant factors of one another, so we have h is less than or equal to log base t of some function n, so h is big o of log of n. m is considered fixed. you will go back and look at this. it doesn't tell you anything different than we already analyzed. there you go.
T, good, T, that's right, the least number of nodes you should have been flipping back to your definitions one more than the least number of keys it can hold. So, this is now to T, let's do level 3. Now, notice that, for each node in level 2, for each node in level 2, you might have this many children, right? So, how many are there in level 3? 2 t squared, okay, now, we're going to add all those up. How about level h? two t to the h minus one. Now let's add those up. I'm going to do it like this, I'm going to say that sum is one plus two times t to the k where k goes from zero to h minus one. Dun, dun, dunnnnn. It's my phrase of the day apparently, one plus, what is this sum? Oh my gosh, what is this? Does anybody know it, just off the top of their head? It's t to the h minus one over t minus one. We good? Two times that, good. Catch, good catch. Okay, how many keys can be in each one of the nodes? How many keys can be in each one of the nodes? Okay, so we counted nodes, we counted nodes, and how many keys were the smallest number of keys that could be in the root? One, right, but the rest of them can have how many keys? Do it in terms of t, because it is lovely. Okay, so the total number of keys, is then, the number of nodes, which is two t to the h minus one over t minus one times the number of keys in each node. Which is? t minus one. Watch this, gone! Gone! Ahhh, I love it when stuff works out like that! And we end up with two t squared minus one plus one? minus two plus minus one, okay. Two k h, two to the h. okay, sorry.Any question about it? What are we going to do next? What does this result say? So this means, n is at least that. So, is that what we want? No, we want to argue about the height, right? So how do we do that? Invert it, that's right, invert that inequality. So the least total number of keys is t to the h minus one times two, two t to the h minus one. Write that as an inequality, I just did, rewrite that as an inequality about h, so I will race you. So that means, okay, we gotta do, n over two plus one, wait, geez, ughhhh. n plus one over two, log base what? log base t of that and then I get is greater than or equal to h. So h, is less then or equal to log base t of this thing. Okay? Now all logs, can be any other log, right? And so we have h is, all logs are constant factors of one another, so we have h is less then or equal to log base t of some function of n, so h is big O of log of n. Okay, ummm. m is considered fixed. You will go back and look at this, it doesn't tell you anything different than we have already analyzed. Okay, right, there you go.
Okay, so we are gonna work today, I'm going to remain silent about the test because there are people still taking it so you can ask me about it all you want and I will look at you with blank eyes, like I'm not going to respond. So I think we are gonna focus on things going forward, on Friday I'll have a better grip on what the grading process is going to be like, but I just don't want to talk about it today. So MP6 is on your plate, I have a couple things to say about this point in your semester. I think yesterday was your worst day for this class for this semester because the exam was pending, MP6 was out, b trees lab, so you might not have known that yesterday was the worst day but yesterday was the worst day. And this week is kind of the hardest week. So the b trees lab is this week, and it is known to be the hardest lab. Rather than simplify it, I'm going to make it worth double credit, so if you are willing to invest the time into it, you are going to get a little bit of a bump for having done so. Okay so I don't want to shorten the lab, I think it is a good experience, worth the investment, but I'll give you credit for the extra time that it takes. So one of the points will be extra credit, so now instead of having fourteen points associated with the labs for the class, now we have fifteen so ten of those we are counting on you to get to get the A, now there are five extra credit points. So you won't be penalized for your decision making process, your just making a choice not to go for some extra credit. So finally today, we are done with trees, we are going to move onto hash tables. Probably, at least from my perspective, as somebody who likes to get things done using python, probably hash tables are the most important data structure, for the kind of things I do. Now if I were a scientist, if I were doing a different kind of computing day to day, I might be interested in being able to search regions of things, hash tables dont give you that we'll talk about that later, but suffice to say this stuff is important. Alright so, what does it mean when we talk about hashing? Well it simply means that we are going to use a data structure called a hash table to implement abstract data type dictionary.
okay. erm. yeah. we are going to talk about it. erm. so. we are going to work today. erm. im going to remain silent about the test because there are people still taking it so you can ask me all you want and i will look at you with blank eyes. like im not going to respond. erm. yeah. so er i want to focus on things going forward on friday i will ahve a better grip on what the grading process is going to be like. and but i just dont want to talk about it today. so i guess i ask for that courtesy. lets see, so MP6 is on your plate. i have a couple of things to say about about this point in the semester. erm i think yesterday was your worst day for this class this semester because the exam was pending mp6 was out its b-tree lab week you might not have known yesterday was the worst day but yesterday WAS the worst day okay and this week is kinda the hardest week so erm here's so the b-tree lab is this week and it is known to be the hardest lab. rather than simplify it, im going to make it worth double credit so if you are willing to invest the time in it so you get a little bit of a bump for having done so. i dont want to shorten the lab i think its still a good experience worth the investment but erm i give you credit for the extra time it takes. so one of the points on the lab is extra credit basically it contrivutes. instead of having 14 points associated for the lab the class we have 15 points assiciated with the labs for the class so that 10 of
Okay! Umm Yeah. We're gonna talk here of it. Ummm so we're gonna work today. Umm I'm going to remain silent about the test because there are people still taking it. So you can ask me all you want and I will look at you with blank eyes. I'm not going to respond. Yeah, so. So I think we're gonna focus on things going forward. On Friday I'll have a better grip on what the grading process is going to be like, but I just don't want to talk about it today. So I guess I asked for that courtesy. So MP6 is on your plate. I've a couple of things to say about this point in the semester. I think yesterday was your worst day for this class this semester because the exam was pending, MP6 was out, BTrees lab. You might have not known that yesterday was the worst day, but yesterday was the worst day. The BTrees lab is this week and it is known to be the hardest lab. Rather than simplify it, I'm going to make it worth double credit. So if you decide to invest the time in it, you get a little bit of a bump for having done so. I'm don't want to shorten the lab, I still think it's a good experience, worth the investment, but I'm going to give extra credit for the time you invest in it. So, one of the points on the lab is extra credit, basically. So now instead of having 14 points associated with the labs for the class, we have 15 points associated with the labs in the class. So that 10 of those we're counting on you in order to get your A, now there are 5 potential extra credit points. Does that clarify it? So you won't be penalized for your decision making process any more than if you decide not to go for some extra credit. Yes! It'll still be due on Sunday. Mike! Yup! That's right. Which is like almost up half a letter grade. This class is so cake. Hahahaha! Just kidding. Alright. We should work. Let's play school. Oh yeah! Ok. Alright, finally today is the day we're done with trees. We're gonna move on to hash tables. Probably atleast for my perspective as somebody who likes to get things done in python, probably hash tables are sort of the most important data structure. For the kinds of things that I do. Now if I were a scientist and I was doing a different kind of computing day to day, then this might not be true. I might be more interested in being able to search regions of things. Hash tables don't give you that. But suffice to say that this stuff is important. So, what does it mean when we talk about hashing. It simply means that we're going to use this data structure called hash tables to implement abstract data type dictionary. Okay? Let's see if we can get anything to work at all today.
I'm gonna say it like this, implement ADT dictionary, okay so, the minute I say that, you know already what the interface is. You need to be able to, given a key, find the key in the structure, and return it's value. You should be able to insert key value pairs and remove based on keys from the structure. So it's sort of a key-centric structure and all we do is put stuff in and take stuff out. Particular application beyond that is up to you. Okay, so I think we might have talked about this before, suppose this is what our data looks like. We have a student and a locker, how can I, where this is the key, and this is the value, or the data associated with the key, how can I implement insert, remove, and find, efficiently, if what I want out of the structures is names? Given this particular data set, what would be an efficient implementation of a dictionary? Yes!? A tree? Sure, we could do that, but it would take me a long time to like figure that out? What is this asking for? Ya, an array, look! These locker numbers, if you squint your eyes a little bit, or maybe you don't even have to do so. They look like array indices, right? They happen to not be in order, but they could be. So, it's perfectly reasonable to exploit the fact that our keys are smallish integers, and to place the values in the array entries. Okay, so, this implies use an array. Okay, any questions or comments about that? Okay, fine. But we know at this point that keys and values don't necessarily come so conveniently posed, that in fact our keys might be things that are more interesting. Okay? Wouldn't it be kind of cool, if we could take a key, that is say a flight number, and think of it as an array index. Hello? Wasn't going to smile today, I have no smiles in me today. Wouldn't it be cool, if we didn't constrain the indices, the kinds of things we use for indices, to integer? Wouldn't it be cool if we could use strings, or whatever else, objects of any particular type? Okay, any question about that? Well that's kind of what we are going to do. We are going to that among other things. A color you know as a key, that's usually a triple, you know an RGB value, especially for us, but maybe it's HSB we don't necessarily know what a color looks like, what it's representation is, but you should think of it as an arbitrary type kind of, it is an arbitrary type, a user defined type. So any questions about that, so wouldn't it be cool? The answer is, ya it would be cool. So let's see what we could do. So here is a dictionary, you are familiar with that, we are going to define this new interface, that mostly implements a dictionary, called an associative array. Now, all an associative array does, is that it overloads the square brackets, you can barely see it. There is like a one pixel space there, between those square brackets. So it overloads the square brackets, so that you can use them as if they were array indicators. So, for example, we could define a dictionary to be this associative array, which we are going to give a different name to in a minute, and use as a key, some string and store the data, and conceptually what you might have going on is that you have this array who's indices are like string and who's values, it looks like are ages and what conceptually what's going on is
The age of Miquel is 22. Any question about that? So that's kind of what the usage that you want. All right so what does return here what does value d? What's the value d? 22. That's right. Any time you refer to this thing. Any time you refer to your structure with square brackets you get the value out of the structure just as if it were an array. Now this is a model. This picture right here, this rectangle, this table is a model for what's going on. This is a programatic representation of your interface to your data, but it lives at the application level. So the question is? How do we implement this. That is what does this thing look like. What does the overloaded brackets look like? And we are kind of gonna go there. Okay. So we are gonna use a hash table to implement this thing. So I wanna talk broadly about hashing. So there a couple little definitions. I'm sorry you can take a nap during definitions if you dare. Alright, so what's a keyspace. It's simply a mathematical description for the keys for a set of data. It might be strings, like you might be able to say it is the union of characters or something like that. But it is usually defined over a set. A way to think about the keyspace here is as the domain of some function. So in any way you can articulate a domain effectively. You are articulating a keyspace. A potential keyspace. So whatever kind of thing a domain can be you can use it for keyspace. All right. So here is what we are gonna do. We are gonna use a function to map the keyspace onto a small set of integers and then we are gonna inturn use those as array indices. Now, what is this function. I mean a mathematical function. Some mathematical function.So you are accustomed to seeing denoted like this. F maps the key to, I'm gonna do it, what's the, is integers, small positive integers, is like this right? That's an I. That's a Z. There now it looks like a Z and it's small. So maybe this isn't so robust mathematically. It's a small set of positive integers. There will be no jokes today. Alright, so what's funny about this goal? What's fuzzy about is, we don't know how big small is. It's smallish. And what function are we talking about. What is that function? Well I don't know? It's just some function. Okay. What's the behavior of the function overall. So what's fuzzy about this goal is f is not obvious and this small set of positive integers is not well defined. Now here is where we are gonna use that small set of positive integers for. Array indices. Well how big is, well it depends on how much memory you have available to build this array, which depends on what your system looks like at execution. Now for the purpose of this course, we are not gonna think very hard about that. Now I encourage you to write a piece of code that allocates incrementally bigger dynamic arrays in see how big you can get Z positive to be. It will be big. You will be amazed at how big it is. But, now we don't care. We are gonna deal with that symbolically. Now, because you know any conversation we have about that right now, in two years that number will be obsolete. Probably next month that number will be obsolete. So this just means the size of an array. So this is reasonable array size.
The age of Miguel is 22. OK, any question about that? So, that's kind of what the usage that you want. Alright, so what is return here? What is the value of d? 22, that's right. Any time you refer to this thing, anytime you refer to your structure with square brackets, you get the value out of the structure just as if it were an array. Now, this is a model, this picture right here, this table is a model for what is going on. This is a programmatic representation of the interface to your data. But, it lives at the application level. So the question is: how do we implement this? That is, what does this thing look like? What does the overloaded bracket look like? And we're kinda going to go there. Ok, so we're going to use a hash table to implement this thing. And I want to talk broadly about hashing. So there are a couple of definitions. So what is a keyspace? It's simply a mathematical description of the keys or set of data. Now, it might be strings. You might be able to say it's the union of characters" or something like that. But it is usually defined over a set. The way to think about keyspace here is as the domain of some function. So any way you can articulate a domain effectively you are articulating a keyspace. So whatever kind of thing domain can be, you can use for keyspace. So, here's what we're going to do. We're going to use a function to map the keyspace onto a small set of integers, and we're in turn going to use those as array indices. Now, what is this function? I mean, a mathematical function, some mathematical function. So, you are accustomed to seeing it denoted like this. F maps the key to small positive integers. Ok, looks like a Z. And it's small. Maybe this isn't so robust mathematically. It's a small set of positive integers. Alright, let's see. What's fuzzy about this goal? We don't know big small is. And, what function are we talking about here? What is that function. I don't know, it's just some function. So, what's the behavior of the function overall. So, what's fuzzy about this goal is F is not obvious, and this small set of positive integers is not well defined. Now, here's what we're going to use the small set of positive integers for. Array indices. How big is it? It depends on the amount of memory you have available in which to build this array, which depends on how your system looks like at execution. For purposes of this course, we're not going to think very hard about that. I encourage you to write a little piece of code that allocates incrementally bigger dynamic arrays and see how big you can get Z positive to be. It will be big, you'll be amazed at how big it is. But, we don't care. We're gonna deal with that symbolically now. Because any conversation we have about it now, in two years, that number will be obsolete. So this just means the size of an array. So this is reasonable array size.
Okay. Alright, so this is what we are gonna do. We are going to create, so first of all we are going to call this f, a hash function. And we are going to take a value k from our key space. Feed it into this hash function h(k). We are going to define h(k). Please look at the characteristic of h(k). Out of that, is going to come some small index, i, and in that location, i, in some table, we are going to store some data. So this is for a k v pair. Okay, any question about that? This is our plan but it's still ambiguous because we don't know what this thing has to look like. So that is kinda what we are going. Alright, any question before we start. This is all set up. This is all leading us to the interesting part. Let me make sure I wasn't suppose to say something else. Yes? No, not necessarily, so the question is, are we assuming the value. Were you asking about the values? This is a plain O array. Good I am glad you asked. This is an array. This are the indicies and these are the values. So yes, this is 0 1 2 up to you know however big that array is. Okay and these are the indicies for that array. Alright, is that clearify it? Yes, it is a one-dimensional array. Good. Okay. okay, hmm so I wanna talk about just a second about this h (k) function. So your key might be you know whatever, a camera model or a flight, an airline flight or whatever. And what h(k) has to do is it has to take that thing that type of thing as input and produce a small value that you can use as an array index. Well this is what commonly done. it is very common to set up h(k) as the composition of two functions. Like this. h(1) of h(2) of okay where h 1 of k just make sure that your key fits into the array. So where h(1) of k h(1) of sorry, it is going to be an integer. So it equals x mod n where n is the table size, so it is very very common, take your key and map it to some integer whose value you are not worry about. And take that and shrink it, the mod so it fits into your table. So this is an example. These are the children in my neighborhood and their Halloween customs.
Okay. Alright. So here's we could do. We are going to call.. Okay so first of all, we are going to call this F a hash function. And we are going to take our value k from our key space. Fit it into this hash function. H of K. We are going to define h of k at least look at the characteristics of h of k. Out of that is going to come some small index i. And in that location i in some table we are gonna store our data. So this is for a k-v pair. Okay, any question about that? So this is our plan. But it's still ambiguous because we don't what this thing has to look like so that's kind of where we are going. Alright, any questions before we start. This is all set-up. This is all leading us to the interesting part. Let me make sure I wasn't supposed to say anything else. Yeah? No, not necessary. So the question is are we assuming that the value for you asking about the values? This is a plain old array. Good I am glad you ask. This is an array, where these are the indices and these are the values. So yes, this is zero, one, two, up to you know however big that array is. Okay, these are the indices for the array. Does that clarify it? Yeah, it's a one dimensional array. Yes. Good. Okay. Okay. Hmm. So I wanna just talk for just a second about this h of k function. So your key might be you know whatever, a camera model, or a flight.. an airline flight whatever. And what h of k has to do is it has to take that thing, that type of thing as input and produce a small value that you can use as an array index. Here is what commonly done. It's very common to set up h of k as the composition of two functions, like this, h1 of h2 of k. Okay. where h1 of k just makes sure that you keep fits into the array. So where h1 of k, h1 of, sorry, it's gonna be an integer. It equals x mod n, where n equals table size. So it's very very common to take your key and map it to some integers whose value, whose magnitude you don't, you are not worried about. And then take that, and shrink it via mod so it fits your table. Alright, so here's an example. These are the children in my neighborhood and their halloween costumes.
Okay, when you say when you see HP, raise your if you first think of Happy Potter. Raise your hand if you first think of Hewlett-Packard. What a phenomenon, right? What did you think of? Yeah! Right? Weirdest thing. The rest of the world, again, is what makes us unique. The rest of the world is very clearly Harry Potter, but not us. Nuh-uh. Embrace you geek-dom. I don't know what it means to dress as a Hewlett-Packard for Halloween, but I bet you guys could figure it out. It's a little scary these days. I wasn't gonna make any jokes today! Darn it! Alright. So these are the keys I'll change this back these are the keys and these are the values. Oh, I have a fun thing! So this slide was made when my seven, or six years ago probably. When my eighteen-year-old was twelve, okay, and he was the cereal-killer." Okay? And that was the perfect twelve year old costume. His name is Isaac and I didn't want to, like, tell everybody's name. Oh wait. Darn it! No jokes today! I'm telling you! Okay. And this year our smallest child wanted to be the cereal killer so it was like this our smallest child who is now eight it was like this legacy that you have to be hot gluing mini-wheats to a t-shirt the night before Halloween. I dunno. So anyway, so this is our data. They keys are people's names. You can think of them, generally as strings if you want, but I think it would be kinda crazy to call somebody a, I dunno, ice cream." "Hey Ice Cream Cone, come over here!" So we're not talking about general strings here. Presumably, for names we might have some, uh, type which is a name type and the elements of that set would be prescribed by some, uh, look-up table or something. Okay, so even though these look like strings. They look like strings. In fact, they may not be implemented to be such. Okay? Just as a, that's an aside, doesn't really apply to this example but it's something to think about. Okay, so our goal is to take my data including the keys and values and map them in some reasonable way so that the costumes live inside this table. Okay? So what's a good hash function for this? What's a good-- how can we take this key and create some function on it that maps each one of these things to a small integer value? Yes? Yeah, right. Okay. For just a sec we were super lucky. Right? We were super lucky because the people in my neighborhood happen ti have first letters that all go in order and so our hash function, the thing that can take the key that looks like this and map it to that is simply, uhm, k[0] minus capital A works. So this will be interpreted as values and that difference will return some small integer. Okay? Any question about that? And then that means we're gonna get black cat here, and HP here and spy and basketball player Oh, when you saw bball, did you think basketball or baseball?
Okay. When you see HP. Raise your hand if you first think of harry potter.Raise your hand if you first thing of hewlett packard. What a phenomenon right? What did you think of? Yeah right? Weirdest thing. To the rest of the world it's harry potter, but not us. Embrace your geek-dom. I don't know what it means to dress as a hewlett packard for Halloween. But I bet you guys could figure it out. I wasn't going to make any jokes today, darn it. Alright so these are keys, and these are the values. So this slide was made when my 18 year old was 12 and he was the serial killer. That was the perfect 12 year old costume. His name is Issac. I had to change his name because I didn't want to tell everyone his name. Oh wait. Darn it, not jokes today. Okay and this year our smallest child wanted to be the serial killer. Its this legacy in our family, that you have to be hot gluing mini-wheats to a t-shirt at 2 o'clock in the morning the night before halloween. Alright. So this our data. The keys are peoples names. You can think of them generally as strings if you want. It would be crazy to call somebody ice cream cone. So were not talking about general strings here. Presumably for names we might have some type, which is a name type and the elements of that set would be prescribed by some lookup table. Even though these look like strings, they may in fact not be implemented to be such. Okay so our goal is to take my data including the keys and values and map them in some reasonable way so that the costumes live inside this table. So whats a good hash function for this? How can we take this key and create some function on it that maps each one of these things to a small integer value? For this just this set we were super lucky, right? Because, the people in my neighborhood happened to have first letters that all go in order. And so our hash function, the thing that can take the key that looks like this and map it to that, is simply k[0] 'A'. This will interpreted as values and that difference will return some small integer. Any questions about that? That means were going to get black cat here and HP here and spy and basketball player. When you saw bball, did you think basketball or baseball?
K, raise your hand basketball? Raise your hand baseball? K, weird huh? I don't know. like, ok. butterfly, oh, here's another one! butterly, best friend, or boyfriend, I don't know. Cereal killer, etc. Alright, so, these keys have a fabulous hash function. In two different ways: there was no ambiguity; we did not have both harry and harmony in our neighborhood, right? K, moreover, our table was used efficiently. Now, what I want to know from you is the mathematical term that describes those two phenomena. K, so each one, each key hashes to a different integer by our hash function, and the collection of keys that we use, they hash to a consecutive sequence of integers that we happen to be able to use as a table. So what's the name for such a function? It is a perfect hash function, but there's a mathematical name too. What is it? One to one gets you this one, but what gets you this one? Onto, that's right. So, this hash function is one-to-one and onto, aka, a bijection. When such a function exists, we say, Oh, I've got a perfect hash function." Perfect hash function is a bijection (keys to table, k elements). Any question about that? So we're not usually so lucky as that, umm I want to know about this hash function. I haven't done this in this room before, so I'm not sure how this is going to work. I have another hash function that I want you to see. Let's see if it's this easy. If it's not super easy we just won't do it, it doesn't matter that much. Document camera, please make sure the document camera is powered on (talking to computer). Ok, so what we're going to do, our key space is a roll of five dice, k? A roll of five dice, like a yatzee roll, I've got them in my hand right here. And, uhh, here's how my hash function works. Now your puzzle is to figure out what my hash function is and then together we'll figure out whether it's a good one or not, k? And, let's see, we're probably going to want a way of writing this down. So for this dice roll, my hash function gives eight. So you might want to write that down. It's one two two five five, maps to eight. And your puzzle right now is to figure out what my hash function is. This is actually a parlor game. This is a I learned this at a puzzle party. Oh this one is two two two three four, that dice roll by my has function is mapped to two. Yes? K. Ready? two two two three four maps to two. Oh, this one one four four six six maps to zero.
Raise your hand basketball, raise your hand baseball. Okay weird huh? I don't know. Okay butterfly best friend or boyfriend, I don't know. Serial Killer etc. Alright, so these keys have a fabulous hash function. In two different ways, there was no ambiguity, we did not have both harry and harmony in our neighborhood. Moreover, our table was used efficiently. Now I want to know the mathematical terms that describes the two phenomena. So each one, each key, hashes to a different integer, by our hash function and the collection of keys that we use they hash to a consecutive sequence of integers. That we happen to use as a table. So what's the name for such a function. It is a perfect hash function but there a mathematical name too. What is it? One to one gets your this one. And what gets you this one? Onto, thats right. So this hash function is one to one and onto aka a bijection. When such a function exists, we say oh we have a perfect hash function. A perfect hash function is a bijection. So we're not usually so lucky, as that. I wanna know about this hash function. I have another hash function that I want you to see. If it's not super easy we just won't do it, it's not that big of a deal. Document camera, please make sure the camera is powered on. So what we're gonna do is our key space is a roll of five dice, it's like a Yahtzee roll. I got them in my hand right here, and here's how my hash function works. Now your puzzle is to figure is to figure out what my hash function is and then together we'll figure whether it's a good one or not. And let's see. So we're probably gonna want a way of writing this down. So for this dice roll, my hash function give 8. Okay so you might wanna right that. You're puzzle right now is to figure out what my hash function is. This is actually parlor game. I learned this at a puzzle party, okay. So this one is, 2 ,2 ,2 3, 4, that dice roll by my hash function is mapped to 2. Ready? 2,2,2,3,4 maps to 2. This one 1, 4, 4, 6, 6, maps to 0.
Okay Raise your hand basketball Raise your hand baseball Okay wierd huh I dont know, like Okay. Butterfly, oh here's another one Butterfly best friend or boyfriend right I dont know Uhhhhh Cereal Killer etc. Alright, so these keys have a fabulous hash function. In two different ways. in two different ways. There was no ambiguity, we did not have both hairy and harmony in our neighborhood. Right? Kay, moreover, the.. our table was used efficiently- our table was used efficiently. now, what I want to know from you is the mathematical term that describes the two phenomena. Kay, so each one, each key hashes to a different integer, via our hash function and the collection of keys that we use they hash a to consecutive sequence of integers that we happen to be able to use as a table. So whats the name for such a function? Ya? [Student], it is a perfect hash function, but there's a mathematical name too. What is it? one to one gets you this one. And, what gets you this one? onto, thats right. So this hash function, is one to one and onto a k[a] bijection. when such a function exists, we say oh we got a perfect hash function. a perfect hash function is a bijection. Keys... two table... elements... any question about that? We're not usually so lucky, we're not usually so lucky as that.um, I wanna know about this hash function, I haven't done this in this room before, so I'm not sure how this is gonna work. I have another hash function. That I want you to see. See if its this easy, if it's not super easy we just wont do it, it doesnt matter that much. Please make sure Document camera is powered on. okay, what we're gonna do is our key, our key, our keyspace is a roll of five dice. Kay? A roll of five dice, got it? Like a yahtzee roll, I have them in my hand right here. And, uhhh, here's how my has function works. Now you're puzzle is to figure out what my hash function is, and then together we will figure out if it's a good one or not. And let's see. So, we're probably going to want a way of writing this down. SO... so for this roll, my hash function gives 8. So you might want to right that down. It's 1, 2, 2, 5, 5, maps to eight. and you're puzzle right now is to figure out what my hash function is. this is actually a parlor game. Like this a.. I learned this at a puzzle party- a party. Uh.. so this one is 2234, that dice roll, by my hash function is mapped to tow. Yes? Okay? Ready? [Dice Roll]. 22234 maps to two. Oh. This one 1, 4, 4, 6, 6, maps to 0.
Okay, ready? you go one more time, you think you have a pattern, k, would somebody like to guess what this one maps to? who's saying two? two is correct. maps to two. should I do it again? are you intrigued? any guess what this maps to? yeah? it does map to four. yep. hold on to your thoughts a little bit. k. raise your hand if you see how it maps to four, I'm just kinda curious where we are with this. k. brownie points for you! ohhhh, what does this one map to? [gibberish] is right. no, it doesn't matter where I put them, doesn't matter where I put them in the end. This roll is two ones, a three, and two fives, that's what that roll is, not in any particular order. okay ready, wanna play again? okay. I have a hint for you. This one is six. This one maps to six. any observations about the keys or about all the hashes? any observations? they're always even. is that good news or bad news? bad news! it means that we're not ever, if we're using this as a hash function we're never gonna map to the odd numbers. we're wasting our table already. I've one more hint for you about this: the game itself is called petals around the rose. okay so this is called petals around the rose. This one is six, i'm gonna do it again. Okay this is called petals around the rose and this one hashes to two. do you see it? I could do this all day so you're gonna have to stop me. This one's eight. Petals around the rose; I get eight. raise your hand if you think you have it at this point. okay, half, right? raise your hand if you've given up and you don't care anymore. The other half! okay, I think you know it's a party game, you kinda gotta know when to give it up, right? alright, who would like to explain it? anybody? you got it? STUDENT: if it's an odd number, you see how many digits you have around it. if it's an even, there's nothing in between, so petals around the rose. good, so all the odd ones have a center pip; they're called pips the marks on dice are called pips. Odd ones have a center one and the hash function is simply the number of petals (or pips) around any center. Any question about that? Alright, so let's go back and evaluate whether or not this is a good hash function. alright, so is it a good hash function? no. why not? It's not 1-to-1 (one to one). right, like there are lots of different rolls that produce four. for example, [draws on slide, two threes and three twos] this produces four. but so does [draws on slide, one five and four ones].
K, ready? We'll go one more time... Do you think you have a pattern? K, would somebody like to guess what this one maps to? Who's saying two? Two is correct-- maps to two. Should I do it again? Are you intrigued? Any guesses what this maps to? Yeah? It does map to four! Yup. Hold on to your thoughts a little bit. K, raise your hand if you think you see how it maps to four, I'm just kinda curious where we are with this... K... Brownie points for you! Ohhh... what does this one map to? Ten is right. No, it doesn't matter where I put them, doesn't matter where I put them in the end. This roll is two ones, a three and two fives, that's what that roll is, not in any particular order. K, ready? Wanna play again? K. I have a hint for you-- this one is six, it maps to six-- any observations about all the keys, er, about all the hashes? Any observations? They're always even, right, is that good news or bad news? Bad news, right? It means that we're not ever-- if we're using this as a hash function, we're never gonna map to... uh... the odd numbers, we're wasting half of our table already. Um, I have one more hint for you about this. The game itself is called Petals Around the Rose. K, so this is called Petals Around the Rose. Should I do it again? This one is six, I'm gonna do it again. K, this is called Petals Around the Rose, and this one hashes to... two is correct. K, you see it? K... I could do this all day, so, you know, you're gonna have to stop me. This one's eight. Petals Around the Rose, I get eight. K, raise your hand if you think you have it at this point. K, half, right? Raise your hand if you've given up and you don't care anymore. The other half! Okay, you know, it's a party game, right? So you gotta, you kinda gotta know when to give it up, right? Okay, who would like to explain it? You ready? You got it? If it's an odd number you see how many digits you have around it. Yeah! And if it's even there's nothing in between, so, Petals Around the Rose. Yeah. Good. So, all the odd ones have a center pip, they're called pips-- the marks on dice are called pips. Um, odd ones have a center one, and the hash function is simply the number of petals, or pips, around any center. Okay? Any questions about that? Alright, so let's go back, and evaluate whether or not this is a good hash function. Alright, so is it? Is it a good hash function? No. Why not? Okay. It's not one-to-one, for one thing. Right? Like there are lots of different rolls that produce four. For example, uhh, umm, and then the rest of them might be even right? Here-- this produces four, but so does this.
you can change this right. like i can make that even, there is lots of them. Alright, it is not one to one, and it's now on to. ok? meaning that the table is not used efficiently. so this is paddles around the rose you can go show this to your roomates alright you have any questions? you need five dice though. You life will not be complete this is a college lesson, you life will not be complete unless you have a store of dice. You need a box into which you are going to keep dice because you are going to need them for you dice. For your life, you need a laptop and a bunches of dice. i don't know what else, compete lost, I don't know. ok? is this a good hash function. Are there any questions about this? Alright, I have a question for you. How big do you think is this keyspace, paddles around the rose for rolling 5 dice. big big! keyspace is huge. if you are going to figure this out, combinitorily, the counting lesson you want to look up is the start and bars displacements, if you are going to figure this out. Displacement. for stars and bars. Let me actually start with that next time with that, because it is kinda fun and we already have these life, we are going to figure this out how big is the keyspace. Alright, any questions about all this. yes? em... sure......one one one one five is the same as one one one one five, where i switched the first two. that is the same. yeah. [gibberish] right right yeah. alright we are going to count it right now. if we are going to do this next time, alright we are gonna do it right em.....i can't do it now. alright I have room. okay. keyspace. ok. so here is how we are gonna do this. we are going to transform a dice roll, a roll of different dice into a different model, ok? into a different model that is communicated in a way that it is easy to count. So we are going to take a dice roll like one, idk, give me a dice roll, somebody give me a dice roll. someone tell me, what you want this dice to be. the next die on my roll. ok three. what is the next one? six ok. what's the next one. don't say 7. okay that is 1 since mod six right. whatever. And then the next one? that's six. Yeah yeah you could use.......
And you can change this, theres lots of em, k? Alright so its not one to one. Umm and its not onto, meaning that the table is not used efficiently. So this is petals around the rose. You can go show this to your roommate. Any questions about it? You need 5 dice though. Your life will not be complete unless you have a store of dice. You need a box into which you're gonna keep dice because you're gonna need them for your life. For your life You need a laptop and a bunch of dice. I don't know what else, some flip flops. Is it a good function? Any questions about this? Alright, I have a question for u. How big is the keyspace of rolling 5 dice? Its biggggg!! Keyspace is huugeee. If you are going to figure this out combinatorially the counting lesson you want to look up is I believe stars and bars if you're going to figure this out. Displacement or stars and bars, and I'm actually going to start next time with that because its fun. We're going to figure out how big is the keyspace. Any questions about this? Umm sure. 1 1 1 1 1 5 is the same as 1 1 1 1 1 5, where i switched the first 2 dice. I hate this day! Okay we're going to count it. We either do it now or next time. Alright I have room, okay, keyspace. Okay, so here's how we're going to do this. We're going to transform a roll of 5 dice into a different model that is umm is communicative in a way that is easy to count. We're going to take 3. What's the next one? 6, okay! What's the next one? Okay 1! And the next one? AHhahahaha thats six. Yeah yeah you could do that.
and you change this. I can make this even. There is lots of them. Ok, alright, so it's not one to one, and it's not onto, meaning the table is not using efficiently. So, this is petals around the rose. You can go show this to your roommate. Alright, any questions about it? You need five dice though. Your life will not be complete unless you have a store of dice. You need a box into which you are gonna keep dice because you are gonna need them for your life. For your life you need a laptop and a bunch of dice. I don't know what else. Alright, any questions about this? I have a question for you. How big is the key space in petals around the rose? How big is the key space of rolling five dice? It's big. Key space is huge. If you are going to figure this out, combinatoriay. The counting list you wanna look up is, I believe starts and bars or displacement. I am actually start next time with that just because it's fun. We are going to figure out how big is the keyspace. Alright, any questions about all this? 11115 is the same as 11115. Ok, we are going to count it right now. Alright, I have room. Ok, here is how we are gonna do this. We are going to transform a dice roll, a roll of five dice into a model, into a different model that is communicative in a way that is easy to count. So we are gonna take a dice roll like 1 3 6 1 6.
Alright so there's a dice roll, it's kind of random right? Here's how we're going to transform any dice roll. We're going to give yourselves bins for each number. We're going to give ourselves bins for each number, so here are all the ones, here are all the twos, here are all the threes, here are all the fours, fives, and sixes. K, and then we're going to take the five dice and put them into one of the bins. So in this example, we're going to have two dice in the ones, uh, one die in the threes, and two dice in the sixes. OK? now, I assert that if I give you an encoding like this, you can tell me what the dice roll is, and if I give you any dice roll, you can give me the encoding for it, Yes? and so counting the number of encodings is the same as counting the number of dice rolls, Yes? just nod your head if you buy that. Alright, now how do we count the encodings? well how many different things are there to lay out in an encoding like this? There are... five dice and five divisions between dice, right? So there are ten positions in the encoding, half of them are going to be divisions between, and half of them are going to be dice. So how many different ways are there of creating such an arrangement? Ten choose five, very good. So it's ten choose five, k, is the size of the key space. Any question about that? I needed to do it quickly. So for example, I'm going to lay down a random one of these that contains five divisions and five dice. You want this one to be a division or a die? Yah ok, division. Die die division division division die division die. That corresponds to zero ones, two twos, zero threes, zero fours, one five, and two sixes. That make sense? See that? K. You're not going to be tested on this, this is for fun. So how big is this number, ten choose five? Ten times nine times eight times seven times six, you know, divided by a little bit but not by a lot, so about ten to the third, thank you. It's around a thousand, I'm guessing. Ok, ten choose five is only two hundred fifty two? Ok fine. Alright, so what we just figured out is that there are two hundred fifty two different dice rolls we can have, how many different mappings are there? How many different targets are there that they map to? Ten, right? you can have ten different values, so actually I have a slide for this, in this case, your key space is huge. Your key space is large relative to your table size. Alright, relative to, or the range of your hash table. So there must be collisions, there must be a lack of one-to-onedness. Alright, so let's talk about this, let's go backwards now. So what's a hash table? Let's go way back, let's forget pedals around the rows, this was all meant to give you a domain in which to think, but now let's go way back to the definition of a hash table. We need to create a hash table. Here's what we're going to need. We're going to need an array; that's kind of obvious. That's the table where in an implementation level, we're actually going to be storing our data. We need some hash function. You've seen a perfect one, a super-good one, and you've seen a bad one, and what we know right now is that this idea of a bijection is a good one, k? Mathematicians still to this day spend time thinking about good hash functions. Creating a good hash function is not a solved problem. So we're going to be using hash functions that other people create, largely. And then finally, we're going to need what we're going to call a collision a collision resolution strategy, and this is simply a true confession that most hash functions will not be one-to-one. so what do you do if two things do map to the same cell? Hash functions are not generally one-to-one.
Alright. There is a dice roll, kind of random, right. Here is how we gonna transform any dice roll. We are going to give ourselves bins for each number. Hey we are going to give ourselves bins for each number so here are all the ones, here are all the twos, here are all the threes, here are all the fourths, fives, and sixes. Okay. And then we are going to take the five dices and put them into one of the bins. So in this example, we are going to have two dices in the ones, hmm, one dice in the threes, and two dices in the sixes. Okay, now I assert that if I give you an encoding like this and you can tell me what the dice roll is. And if I give a dice roll, you can give me the encoding for it, yes. So counting the number of encoding is the same as the counting of dice rolls. Yes? Just nod your head if you buy that, okay? Alright, now how do we count the encodings? How many different things are there to lay out an encoding like this? There are five dices and one two three four five division between dices. So there are ten positions in the encodings, one two three four five six seven eight nine ten. Half of them are going to be divisions between, and half of them are going to be dice. So how many different ways are there of creating such an arrangement? Ten choose five. Very good. So it's ten choose five, is the number of the size of the key space. Any questions about that? I need to do it quickly. Hmm, so for example, I am gonna lay down a random one of these that contains five divisions and five dies. You want this one to be a division or a die. Yeah, okay, division, die, die, division, division, division, die, division, die, and this one has to be a die. That corresponds to 0 ones, 2 twos, 0 threes, 0 fours, 1 five, and 2 sixes. Does it make sense? See that? Okay, you are not gonna be tested on this. This is for fun. So how big the number, ten choose five? Ten times nine times eight times eleven times six divided by a little bit but not by a lot. So about, ten to the third, thank you, its around a thousand, I am guessing. Okay, 252, ten choose five is 252. Okay, fine. Alright, what we just figured out is there are 252 different dice rolls you can have. How many different mappings are there? How many different targets are there, keys, that they map to? Ten! Right? You can have ten different values. So. Actually, it's a slide for this. In this Ks, your key space is huge, your key space is large, relative to your table size. Relative to all the arrange of your keys, of your hash table, so there must be a lack of one to one there. So let's talk about this, let's go backwards for now. So what's the hash table? Let's go way back. Forgive tails around the rolls. This is all meant to give you some like a domain to which think. But now let's go way back, to the definition of a hash table, we need to create a hash table. Here is what we gonna need. We're gonna need an array, okay, it's kind of obvious, that's the tables where the implementation level where actually going to store our data. We need some hash functions. You've seen a perfect one, a super good one and you've seen a bad one. And we all know right now is that this idea of bijection is a good one. Okay? Mathematicians still to these days spend time thinking about good hash function. Creating a good hash function is not a solved problem. So we are going to be using hash function that other people create largely. And then finally, we are going to need, what we gonna call a collision resolution strategy. And this is simply a true confession that most hash functions will not be one to one. What you do is if two things do map the same cell. Hash functions are not generally one to one.
We need to be able to deal that. Okay, so. Uh. So lets me explain that last one a little bit. um, if you're keyspace is about the size of your table, then you can take elements from your keyspace and just give them a value in your table. Sometimes when I do this, like if I'm programming in python, and I know I'm gonna wanna-- I'm going to want to put data into this... an array. I'll append an index value, or some kind of identifier, on the front of my data. Just because i know I can; the table will be big enough, I'm kind of finding a hacky way of identifying a key with a particular location in the table. This is a perfectly reasonable thing to do if you're keyspace is about the same size as your table. That is if all your data, all the data that you could possibly have will fit in your table. But here's what hashing generally means. Here's what hashing generally looks like. Usually we will have a huge keyspace.Kay? Some huge mathematical description what keys could be. And we're gonna draw some sample from that keyspace. We 're gonna draw some reasonably sized sample from the keyspace. Kay? And what our hash function has to do is take this data and map it to some cell locations. Kay? In the table. And the table has to be big enough to hold this subset. But here's the thing. A general hash table, should work independent of what subset is drawn from the keyspace. So maybe the case, that instead of that circle, we draw a sample from our keyspace that looks like this. And the hash function needs to map those nicely into our table. Lets put them somewhere else. Now what we want to avoid is... what we hope to avoid is some sample from our keyspace, some sample from our keyspace, where all of the keys map to the same location. Because that would be bad. Right? That would be not using our table effectively, and we wouldn't know where our keys were really. Cuz they would be all in the same place. Any question about that? this is again more general how to think about hashing. This is a much harder problem. Okay, finding a general purpose hash function. It's where we're gonna start next time.
we need to be able to deal with that. okay. so uhh let me explain that last one a little bit. if your key space is about the size of your table then you can take elements from your key space and just give them a value in your table sometimes sometimes when I do this like when I'm programming in python and I know you know that I'm gonna wanna im going to want to put data into this into an array I'll append an index value or some kind of identifier on the front of my data just because I know I can the table will be big enough i'm kind of finding a uhh a hacky way of identifying a key with a particular location in the table. This is a perfectly reasonable thing to do if your key space is about the same size as your table. That is if all of your data if all the data you can possibly have will fit in your table. But here's what hashing generally means. Here's what hashing generally looks like. Usually we will have a huge key space some huge mathematical description of what keys could be and we're gonna draw some sample from that key space we're gonna draw some reasonably sized sample from the key space okay. and what our hash function has to do is take this data and map it to you know some cell locations in the table and the table has to be big enough to hold this subset but here's the thing. A general hash table should work independent of what subset is drawn from the key space so it may be the case that instead of that circle we draw a sample from our our uhh key space that looks like this and the has function needs to map those nicely into our table we'll put them somewhere else. okay. now what we want to avoid is what we hoped to avoid is some sample from our key space. some sample from our key space where all of the keys map to the same location that would be bad right that would be not using our table effectively and we wouldn't know where our keys were really cause they'd all be in the same place. alright any question about that? so again this is more of a general how do I think about hashing. This is a much harder problem okay finding a general purpose hash function and it's where we're gonna start next time.
Okay, Im going to start talking, because it is officially time to start while this gets going. I cant change it yet, it might be because the system is still initializing. Okay, I will yell for, woahhh, turn it off. Okay, we are for the first time scanning all of your exams and grading them online, so we dont know how exactly that process is going to go, we are working on it. Our intention is to get them to you by next week, so more in a practical time, now, if i were you my question would be, lets find for exam 2 when will exam 1 be finalized? Yeah, it shouldnt be funny right, thats so sad. There are still, we think the regrades are done, but we havent uploaded the scores to chara yet, so its a race, midterm 1 and midterm 2 are in a race to see who will actually be completely finished before next wednesday. Alright, I wanted to give you further clarification, so that was a non answer by me on midterm 1, Sorry. I wanted to give you a more complete explanation about how we are going to handle the b tree lab, because I told you last time that it will have a point of extra credit in it. We are going to score you as usual, so it will be out of 1 whole point and third of which is attendance and then we are going to double that score, so if you didnt go then the number of points you can get potentially is a little bit lower, but if you go to the lab then it is extra in the absolute sense, though the same relatively. Okay so any other administrative questions you would like me to address in this public forum? I can address the fact that it is friday. Yay!! Is that administrative? So the final is posted publicly. I haven't gone to look, but i got the little announcement saying that the final exam schedule is up for the combined exam, so you should be able to go to the registrar page and we will at some point also post it and make it loud, but I think the information is available to you. Actually, does anybody know the answer to that? When is the final? This is, I am giving you this with 80%, you know you should back it up, but, go ahead, Monday 7pm, the 14th. Did you want to say something? You were going to replicate that, was he right?
Okay, I'm gonna start talking because it is officially time to start, while this gets going, um... I can't change it yet. It might because the system is still initializing. Okay, I will yell- woah... turn it off- Okay we are- now you can whisper and you can still hear me. We're for the first time scanning all of your exams, um and grading them online. So we don't know exactly how that process is gonna go. Um, we're working on it. So, our intention is to get them to you, um, by next week, so more in a practical time. Now, if I were you, if I were you, my question would be: well that's fine for exam two, when will exam one be finalized? Yeah, it shouldn't be funny right? That's so sad, um... There are still, we think three grades are done, but we haven't uploaded the scores to chara yet, so it's a race. Midterm one and midterm two are in a race to see who will actually be completely finished before next Wednesday, so... I'm hoping, I'm hoping... Alright, I wanted to give you further clarification, so that was a non-answer by me on midterm one. Sorry. I wanted to give you a more complete explanation about how we're gonna handle the b-tree lab, because, uh, the, I told you last time that it will have a point of extra credit in it, um, and the way we're gonna do that, we're just gonna score you like usual. So, it will be out of one whole point, a third of which is attendance, and then we're gonna double that score. So, if you didn't go, the number of points you can get potentially is a little bit lower, but if you go to lab, then it's worth kind of extra in an absolute sense, though the same relatively. Okay, any other administrative questions you would me to address in this public forum? I can address the fact that it's Friday, yay. Is that administrative? Yeah? So the final is posted publicly, I haven't gone to look but I got the little announcement saying the final exam schedule is up for combined exams. So you should be able to go to the registrar's page and we will at some point also post it and make it loud, but I think the information is available to you. Actually does anybody know the answer to that? Alright, when is the final? This is, I'm giving you this with oh... 80%, you know, you should back it up, but, go ahead. Monday, 7 pm. The 14th, he thinks. Arman did you want to say something, you were going to replicate that, was he right?
We can talk about that later. So, the question is about the conflict exam and my understanding is that there are university rules for qualifying for the conflict exam and of course we are going to follow the university rules. So you probably either have a conflict or you don't, so I dont know where the fuzziness is. Oh, I, you know, our exams at this point are so consistent distribution wise. They're consistent over semesters even. In fact, I'm kind of anxious to see, so this semester is the first time in a very long time where i'm not writing the exams. So i'm really interested to see at the end of the semester whether the grade distributions over individual exams when we look at the whole semester if they deviate. I think they won't very much. You know, the first exam, from my perspective, had a pretty perfect distribution. So, you shouldn't expect wild differences in averages. Okay, should we work? Yes, let's get it over with, right? Okay, I'm going to ask you on Monday what you did this weekend that gave you joy, okay? So, I'm just going to ask you so I just want you to think about that for this weekend a little bit. Alright, so we were talking about hashing and I wanted to kind of clarify the perspective on hashing. I wanted to paint a picture for you. We were using these structures called hash tables to implement a dictionary, okay? Now, when we implement a dictionary it means we are providing to the client, that's this code, the users of the dictionary, particular functions. Now in a dictionary all those functions are key value centric, like they depend on having a unique key and they are a way of accessing values or data associated with that key. Okay, that should all have been review, you should practically be falling asleep in that particular discussion. Now, what needs to be clarified I believe is that a common interface to a dictionary is via an associative array kind of like this. Where we treat the key type as the type of thing that can be an index. Okay? Is that clear? Make sense? Alright so that's very very common so that an associative array is a particular interface to a dictionary. Now, all the stuff that we talked about last time is concerned primarily with the implementation of this ADT and its interface. And that implementation itself is referred to as a hash table. So this is the picture that we have. Here is the client code and here is what they know, they can do dictionary type things here. But here is what is what's going on behind the scenes. Behind the scenes we have a class Dict that receives via the functions, it receives a key and a value. Hold on, let me get there. It receives a key and a value. So input into the function, the member functions of this class, are k and v. Okay? So here is what happens, k is sent off to this hash function where a small integer is created and that integer is used to denote a place in the array that into which you're going to store the value. Okay? Yeah okay fine. Better? Yeah. Alright any question about that? Now the problem that we began to talk about last time, what happens if your hash function is not a perfect hash function, that is especially if it is not one-to-one, so we might ask a question, what if H(k) is not one-to-one? We are going to handle that and talk about that later today, this is foreshadowing. By coming up with a collision resolution strategy, that is what do we do when the lack of one-to-one-edness in our hash function appears, or is manifest by the particular set of data that we get. That is the stuff today, what do we do?
We can talk about that later. the question is about the conflict exam and my understanding is that there are university rules for qualifying for the conflict exam and of course we're going to follow those university rules, so you probably either have a conflict or you don't so i don't know where the fuzziness is. our exams at this point are so consistent distribution wise, they're consistent over semesters even. in fact, i'm kind of anxious to see. this semester is the first time in a very long time where i'm not writing the exams, so i'm really interested to see at the end of the semester whether the grade distribution over individual exams when we look at the whole semester if they deviate, i think they won't very much, you know, the first exam from my perspective had a pretty perfect distribution, so you shouldn't expect wild differences in averages. okay shall we work? yes, let's get it over with, right. okay, i'm going to ask you on monday what you did this weekend that gave you joy. so i'm just gonna ask you, and i want you to think about that for this weekend a little bit. alright, so we were talking about hashing, and i wanted to kind of clarify the perspective on hashing, i wanted to kind of paint a picture for you. We were using these structures called hash tables to implement a dictionary. now when we implement a dictionary, it means we're providing to the client that's this code, the users of the dictionary particular functions. now in a dictionary, all those functions are key value centric; they depend on having a unique key, and they are a way of accessing values or data associated with that key; that should all have been review, you should be like practically falling asleep in that particular discussion. now, what needs to be clarified, i believe, is that a common interface to a dictionary is via an associative array, kind of like this, where we treat the key type as the type of thing that can be an index. okay? is that clear? makes sense. alright, and that's very very common. so that associative array is a particular interface to a dictionary. now all the stuff we talked about last time is concerned primarily with the implementation of this ADT and its interface, and that implementation itself is referred to as a hash table. so this is the picture that we have. Here's the client code, here's what they know, they can do dictionary-type things here; but here's what's going on behind the scenes. Behind the scenes, we have a class Dict that receives via the functions; it receives a key and a value. It receives a key and a value, so input into the member functions of this class are K and V. So here's what happens. K is sent off to this hash function where a small integer is created and that integer is used to denote a place in the array, into which you're going to store the value. Now the problem that we began to talk about last time was what happens if your hash function is not a perfect hash function? That is, especially if it does not, if it is not one-to-one. So we might ask a question, what if h(k) is not 1-1?" we're going to handle that and talk about that later today this is foreshadowing by coming up with a collision-resolution strategy. that is, what do we do when the lack of 1-1'edness in our hash function appears, or is manifest by the particular set of data that we get? and that's the stuff today.
If two keys map to same small index, and by map to I mean via the hash function. Ok, any question about all of that? Alright. So the first part of our focus is gonna center on the hash function itself, the second part will talk about collision resolution strategies on Friday. Alright, any questions about all theres? Alright, so hash functions, this is the story on hash functions as I know it. It's going to necessarily be an incomplete story because guess what? There are people working on all kinds of different large entities spending their entire lives working on good hash functions. So in this hour, we are not going to touch on all of the complexities involved with creating good hash functions. So it's people who are interested in topographys are doing hash functions, mathematicians, people who deal with big data want really good hash functions with great characteristics. So this is just a glimpse to their world, there's a whole career there waiting for you centered on this material if you would like. I 'm intrigued by especially big data aspects of it. Alright, let's see. What is a hash function look like? Typically, consists of two parts: a hash which takes the key and finds some integer return some integer together with something that shrinks that integer down into a space small enough that we can store it. So a compression which is a function mapping that larger integer into the array, so zero to n-1, and this is almost always and it it will always be for our class just the mod function. This is mod N where N is the table size. Any question about that? OK, so turns out that choosing hash function is tricky, it's hard to choose good ones. and I will talk a little bit about it on the next slide. There's again a whole lecture of what our some classic bad hash functions that have been created over time and as the next greatest things for hash functions and then found to contain periodicity that actually results in very bad behavior, we will talk a little bit about that in a minute. So we don't want you to create your own. The yet is not really well stated. It should really be unless Where the unless is that you understand your key pace and it is small enough that you can create a bijection. unless you can create a bijection in which case you should make your own hash function. unless you know your data, well enough, to create a bijection. and notice that really means also that your data has to be small enough that you could create this bijection. Alright, so what characterizes a good hash function? So these are the characteristics of a good hash function. Computing how much time we are gonna give the function to run on the key? Constant time, that's right, very good. It must be computed in constant time. It must be deterministic. What's the opposite of deterministic? Probablistic", or another word for that is random, tight? So the opposite of deterministic in this case is random. Now think about what this means. What this means here is if i==j, then it must be the case h(i)==h(j). there is no dice roll that says what the hash of the index should be. We plug in 4, we are gonna get the same value out every time. We'll talk about what would happen if that was broken in just a minute. good hash functions also satisfy the SUHA. I like saying it, and so I will say it again and I will tell you what it means SUHA. simple uniform hashing assumption.
Um, if you're data is in a linked, if your data all maps to the same array cell, um, you have several different ways of handling it, which we'll talk about, all of which imply you have to search for your data within that cell. Okay? And so, you might as well just to put 'em in a big bucket or a list, or whatever. Okay? Yes, right, that's right. Okay, so I want to rehash things again. Is the moment for the hash brown joke? I don't know, it's not right now. Okay, alright. Um, so I wanna revisit a couple things just to convince you that hashing is hard. So this time I drew the same picture but with the key space small in the first example. So, I wanna reinforce the idea that if you happen to know exactly what you're data is going to be, then by all means figure out a way of mapping your data into an array via a bijection. Okay? That's on you. That's on you. You can do that, nobody's telling you, oh don't try to do that on your own. If your data is small enough, it's usually kind of a clever, you know, clever little puzzle to figure out ways of putting your data efficiently into a table. It's, um, it's figuring out identifiers for your keys that allow you to represent those keys using indices from an array. Alright, now why? nuuuuuung Okay. Uh, using indices as the representatives here. So, the punchline is if your key space is small, by all means, make your own bijection. Have fun, it's fun. Okay, on the other hand, if your key space is large or very general, that is you don't really even necessarily know what the key space looks like, which is the case for a lot of general purpose hash functions provided for you by a system, like C++'s hash map, then the puzzle becomes harder. Because, every set of data that you choose from that hash function, it might not be a very big set of data, certainly it should fit in your table, right? Certainly should have memory to contain all of your data, but you cannot control what subset you get. So it might be the case that one subset will spread the data out nicely over the table, but, and maybe that will be the case for couple different subsets that happen to constitute your data for an application, but what you cannot guarantee based on arguments related to the pigeonhole principle is that no hash function can do well on all subsets. There are just too many of them, too many possible subsets, especially of a large key space. You cannot guarantee good behavior from a, over all subsets... from a general purpose
Hash function. So that why it's an interesting problem even now. Ok. yeah. so the entire key space. So the question is what the difference between the entire key space and the sample key space. let's take phone models. cause nobody has a camera anymore. let's take phone model. so most phone model are expressed some numbers and some letters associate with them and some title so that's a key and you can have hundred of those. If I were making an application about phone. I might only draw samples of five of them from that entire keyspace so the key space is what generally describes the possible set of keys and the sample that you choose is the data that happen to appear at your door step asking to be stored. your hash function still has to work on different data. ok I want to show you how easy it is to have bad hash function. what book is this from? This is from huck-finn. It's actually might be from tom sawyer I don't know for sure. I don't remember what this is from. so here this is what I want to start with this. It turns out that it's easy to hash string if they only have 8 characters. You can come up with a bijecture of string to a reasonable size table. I don't want to hash 8 character string. What I want to do is to take a 40-character string and hash it and store the page number. so that I can type a bit of text of tom sawyer and my application would go and said that on page bla. so this is what I came up with. Hashing scheme for long strings. So what we want is a hashing scheme or hash function for longer string. Here this what we are gonna do. We are going to take 40-character string and select 8 positions from it and use that as the 8-character string and use the good hash function of 8-character to take care of it. Let's choose 8 positions and I'm going to this kind of quickly and not carefully. that one and that one and that one and that one 5 6 7 8. ok? Forgive the wavy line there.
Hash function So that's why its an interesting problem even now. So the entire key space so the question is whats the differences between the key space and a sample from the key space. Lets take an application, lets take camera model or phone models. Lets take phone models, okay. So most phone models are expressed as numbers and some letters associated with them and then maybe a title. That is a key and you can have a whole bunch of different one of those probably hundreds, right. But if I were keeping, if I were making an application about phones I might only draw a sample of five of them from that entire key space. Does that make sense? So the key space is what generally describes the possible set of keys and the sample that you happen to choose is the data that you have happen to appear at your door step asking to be stored. Right, and you would get different data next time but your hash function still has to work on it if your application should handle phones, for example. Okay any other questions about this? So I'm glad you asked that. Okay, I want to show you how easy it is to have bad hash functions. What book is this from? Yes, this is from Huck Finn. I once had a student, well ill tell you that anecdote in a minute. So it actually might be from Tom sawyer. So here's where I want to start with this, so it turns out it is easy to hash strings if the have only 8 characters that you can come up with a very nice bijection of 8 character strings to a reasonable sized table and I will leave that to you to go research if you want hashing 8 character strings you'll find a lot of stuff. Now I don't want to hash 8 character strings what I want to be able to do is to take a 40 character string and hash it and store the page number so that I can type a little bit of text from Tom Sawyer, Huckleberry Finn or what ever book this is and my application would go and that's on page blah" and that's my goal, 40 characters instead of 8. Any questions about that? So here's what I came up with for hashing strings or hashing scheme for long strings. So what we want is a hashing scheme for a hash function for longer strings. Here's what we are going to do, we're gonna take our 40 character string and select 8 positions from it and use that as our 8 character string and let the good hash function that we know exists for 8 character strings take care of that. Sounds kinda reasonable, right? So lets choose 8 positions and I'm going to do this kinda quickly and not very carefully. I'm choosing 8 random positions that one and that one and that one and that one [Counts] Forgive the wavy lines there
Cmon, I want you back, Michael Jackson, okay. Alright, and now I'm gonna look and see what characters exist in each of those positions for each of the strings so the first string then is sort of transformed into this character, this character, this character, etc. and it looks like [Leu, hi] and you know lets take this one this one is [Nmh'lser]. And now these are the things that we are going to send through our good hash function. Okay, question about that? And our overall hash function then for long strings, our long string hash function is the composition of these two. Take these eight positions and then apply that... apply the good hash function to that. Any questions about that? Alright, and for this kind of data, for data these long strings that we happen to have drawn from a novel works perfectly fine, right? These look pretty random over strings. There's no reason to believe that these wouldn't be spread out by this good string hash function. [student question, can't hear it]. So it depends on the hash function. So the question is how do you do a general SUHA check in your mind when you're looking at this. What's the intuition behind a SUHA? And I think the way I would approach that problem is to say, Hmm, can I come up with an example for which SUHA would fail? Can I come up with a subset of data from my keyspace that my hash function would do badly on? And that's exactly what we're going to do here. Any question about this? So here's what my hash function does. It takes forty character strings and it hashes it, spreads them out uniformly over a table so I can get them back forty character strings. Well my friend came to me and said, I've got some forty character strings that I would like to hash. Do you have a good hash function? I said, "Sure. I've got a forty character hash function, forty character string hash function. Would you like to use it? And my friend used that hash function on her data. Well let's look at how that hash function works. The first thing you do is you designate eight random spots. One, two, three, four, five, six, seven, eight. Kinda random, right? And then you hash those using this good eight (8) character string hash function. So what do these things look like? You already see the punchline here, right? They look like [h/eiagkC]. This one down here looks like [h/eiagkC]. Look we've got a collision there even. This one looks like [h/eiagka]. So, there was an there is an, in this case, an obvious subset of data of the set of forty character strings that create bad behavior by the hash function. Make sure that you see that this is bad behavior by the hash function. How many different results, how many different cells will our hash function map into? How many different small indicies will our hash function produce approximately? Fifty-ish, hundred-ish maybe depending on how many special characters you have, right? Not very many. Not very many even if you just look at the pages of wikipedia. Mapping all of the wikipedia URLs into eight different spots. I'm sorry, a hundred different spots. Bad. Bad. Bad. Bad. Okay, so good general purpose hash functions are hard to create. Any questions about this? Alright
So it turns out you can not avoid collision. You just can't. They are going to happen and the question is how do you handle them. The results you see here are classic approaches to handling collisions. You will have better ideas, but everybody in your world expect you to know these ideas. Ok, everybody in your world is gonna expect you to know these and in fact all of you better ideas are going to be modificative. Almost all of your better ideas are like to be modifications in some sense of these. So the first one we are gonna talk about is separate chaining. And thats the vocabulary associated with it. There's additional vocabulary. It is know as an open hashing strategy. Now the reason for that is we are not going to put all of our data in table. Ok. Instead we are going to use the table to gain access to the collection of our data. Alright. So here's what this looks like. So here's our particular set. Here's our set of data. We are gonna say in general that the set of data is size n. The size of the data is n. And our hash function is easy in this case. It's just k mod table size. It's the key mod table size. Now if you want to, you can imagine that our key spaces is actually more interesting. And we apply some other hash function to get down to this integers. And now all we are doing is making it fit in the table. Ok. If you want to think of it that way. Ok. So here's what we do. We take a key. We take it mod seven. And that's where we put the data. But we don't put the data in the table. Instead we put it in this various structure associated with the table. In this case, we are gonna use a linked list. So what is sixteen mod seven. Two. Alright. So sixteen goes here. And we are going to put it in the linked list. Tendered at cell two. Ok. Eight. How about eight? Where does eight go? Into the linked list. This is associated with cell one. Good. How about four? Ok. How about thirteen. I can do these easy. Any question about it? Ok. Twenty nine goes where? Where does twenty nine go? One. Good. Should I put it in the end or the front of the list? I wanna do this fast. So where should I put it? Front of list. Right. There's no reason not to put this thing at the front of the list. So forgive me for drawing it like this. Doing little bit of a. Doing a classroom hack here. Ok. How about eleven? Where does eleven go? Even I can take eleven mod seven. And twenty two. Oh brother. Alright any question about this? Make sense? Singly linked list. Alright. Do you like this? Why. What's bad about this? Feels like a doesn't it? I can handle your collision like collied. What could go wrong here? What could go wrong?
Yeah, alright. So, uh, it turns out you cannot avoid collisions, you just can't. They are going to happen and the question is how do you handle them. The results you see here are classic approaches to handling collisions, you will have better ideas but everybody in your world expects you to know these ideas. Okay, everybody in your world is going to expect you to know these. And, in fact, all your better ideas are going to be, almost all your ideas are likely to be modifications in some sense of these. So the first one that we are going to talk about is separate chaining. So that's the vocabulary associated with it. There's additional vocabulary, it is known as an open hashing strategy. Now the reason for that is that we are not going to put all of our data in the table. Okay? Instead we are going to use the table to gain access to the collection of our data. Alright, so here's what this looks like. Here's our particular set. Here's our set of data. we are going to say in general that the set of data is size n, the size the set of data is in and our hash function is easy in this case, its just k table size. It's the key table size. Now if you want to you can imagine that our key space is actually more interesting and we've applied some other hash function to get down to these integers and now all we are doing is making it fit in the table. If you want, if you want to think of it that way. Okay, here's what we do, we take a key, we take it mod seven and that's where we put the data. But we don't put the data in the table. Instead we put it in this auxiliary structure associated with the table and in this case we will use a linked list. So, what is sixteen mod seven? Two. Okay so sixteen goes here and we are going to put in a linked list. Tethered at cell two. How about eight? where does eight go? Into the linked list associated with cell one, good. How about four? Okay, how about thirteen? I can do these easy, okay. Any question about it? You good? okay 29 goes where? Where does 29 go? One, good. Should I put it at the end or the front of the list? I want to do this fast, so where should I put it? the front of the list, right. There is no reason to not put that thing at the front of the list so forgive me for drawing it like this, I'm doing a little bit of uh, oops, I'm doing a classroom hack here. Okay, how about eleven? Where does eleven go? You and I can take eleven mod seven. Okay, and 22? Oh brother. Alright, any question about this? Make sense? Stick them in a linked list. Alright... do you like this? Why? what's bad about it? It feels like a cop out, doesn't it? [gibberish] handle your collisions i'll let you collide. What could go wrong here? what could go wrong? yeah?
Uh, alright. So it turns out you cannot avoid collisions. You just can't. They are going to happen and the question is how do you handle them? The results you see here are classic approaches to handle collisions. You will have better ideas but everybody in your world expect you to know these and in fact all of your better ideas are going to be modificate and almost all of your better ideas are gonna to be modifications of some sense of these. So, the first one thatwe are going to talked about is theseparate Chaining" And that's the vocabulary associated with it. Um, there's additional vocabulary, it is as known as the Open hashing" Strategy. Now the reason for that it, we are not going to put all of our data in a table. Instead, we are gonna use the table to gain access to the collection of our data. Alright, so here's what looks like. So here's a particular set, here's our set of data, um we are gonna say in general, the size of our data is N, and our hash function is easy in this case. It's just k mod the table size. Its the key mod table size. If you could actually imagine that our keyspace is more interesting, and we apply other hash functions to get down these integers and now what we are doing is just making it fitting in the table if you want. If you want to think it that way. Ok, so here's what we do. We take a key, we take a mod 7 and that's where we put the data, but we don't put the data in the table. Instead we put in the obserialy structure associated with the table and in this case we are gonna use a linked list. So, what is 16 mod 7, 2! so alright, 16 goes to here and we are going to put a linked list beside uh titled at tail 2. How about 8, where did 8 go? Into the linked list associated with cell one, how about 4? ok, how about 13, I can do it easy easy! Any questions? good? So 29 goes where? where is 29 go? 1, good. Should I put it at the end or front of the list? I want to do it fast. So where should I put it? From of the list! Right, so there's no reason not to put that thing in the from of the list. So forgive me drawing it like this. I am doing a classroom hack here. OK, how about 11, where does 11 go? Even I can take 11 mod 7, and 22 ohhh brother. Alright, any questions about this? Make sense? Just a series of linked list. You like this? Why? What's bad about it? Feels like cope bat? Does it?Cock it, handle your collisions and I will let you collide, what could go wrong here? Yeah?
Good, very good. So the observation is that if you have a whole bunch of things in the same bucket. If you have a whole bunch of things in the same bucket and you go to get your data out, you have to essentially search that whole thing to get your data. OK you have to search your whole thing to get your data. So the cost here could be a lot. In the worst, we're going to record that observation in the worst case. So insert is always constant time cause we're just gonna plunk it in the front, but in the worst case we might have to travel all the way down the list and if it's true that everything maps to one cell you might have to search it all. Any response to that? Any idea about it? Yeah, it OK. Your agree with it? OK. So that's worst case but how about under SUHA. What does SUHA say is gonna happen here? How many do you expect if these things are uniformly distributed over the table si... over the table. How many do you expect in each chain? Yeah. At most two in the chain in this example but in general if I tell you the table size is n, big N and you sample size is little n. How many do you expect, and that's a probabilistic average, on average how many do you expect in each cell? Right, good so this is in this case little n over big n, and the insert is still constant time. What do you think about this? What do you think about this? This is foreshadowing, this is important foreshadowing. Are these two the same? They're not? Raise your hand if you think these two are asymptotically the same. Raise your hand there's you know this is discussion not competition OK. Um and raise you're hand if you don't think they're the same. The answer is it depends. Here's what I wante... Here's what I want to uh... Here's what I'm gonna use to answer this question OK. We control the table size. You and me we're the boss, we're the boss of that hash. How big that hash table is alright? So we can always make it big enough so that this value is whatever we want it to be yes? Yeah. So these two in this context are not the same because big N is not a constant. We control it and we're gonna change it. I think you might be able, this is foreshadowing. We might be able to image when we might change it. Alright any question about this? Any question about it? OK. Alright so separate chaining, you just plunk them all in and SUHA save you is the short story. Alright here is another one. Uh this is an algorithm that uh general is uh very big simplification of a class of uh hashing strategies. It's sort of the introductory one. It's closed hashing which means all your data will be in the table and here's how it works. Uh, if there's not a collision you just map the key to its position. So sixteen maps to two, eight maps to one, four maps to four, thirteen maps to six. And now life gets interesting, we're gonna hash twenty-nine to one. and it's full there's already something there so we increase our additive, our probe number. This is a probe number, and look at the next spot. Oh look, spot two is full too, but when you increase it again to three there's room and so we can put twenty-nine right there. OK any question about it? So where does eleven go? Into five, good. And how about twenty two? What's twenty-two's life like?
Good very good, so the observation is that if you have a whole bunch of things in the same bucket, if you have a whole bunch of things in the same bucket and you go to get your data out, you have to essentially search that whole thing to get your data. You have to search your whole thing to get your data, so the cost here could be a lot. We're going to record that observation in the worst case, so insert is always constant time because we're just going to plunk it in the front. But in the worst case we might have to travel all the way down the list and if it's true that everything mapped to one cell, you might have to search it all. Any response to that? Any idea about it? You agree with it? OK so that's worst case, but how about under SUHA? What is SUHA say is going to happen here? How many do you expect if these things are uniformly distributed over the table, how many do you expect in each chain? At least two in the chain in this example, but in general if I tell you the table size is N, big N, and the sample size is little n how many do you expect and that's an average. On average how many do you expect in each cell? Right. Good. This is little n over big N and insert is still constant time. What do you think about this? What do you think about this? This is foreshadowing, this is important foreshadowing. Are these two the same? They're not? Raise your hand if you think these two are asymptotically the same. This is discussion, not competition, okay? And raise your hand if you don't think they're the same. Okay. The answer is it depends. Here's what I'm going to use to answer this question, we control the table size. You and me, we're the boss, we're the boss of how big this hash table is. So, we can always make it big enough so that this value is whatever we want it to be, yes? So, these two in this context are not the same because big N is not a constant. We control it and we're going to change it. This is foreshadowing, you might be able to imagine when we might change it. Alright any questions about this? Any question about it? Okay. Alright so seperate chaining you just plunk them all in and SUHA saves you is the short story. Alright here's another one. This is an algorithm that is a very big simplification of a class of hashing strategies, it's sort of the introductory one, it's closed hashing which means all your data will be in the table and here's how it works. If there's not a collision, you just map the key to its position. So sixteen maps to two, eight maps to one, four maps to four and thirteen maps to six and now life gets interesting. We're going to hash twenty nine to one and it's full. There is already something there, so we increase our additive probe number. This is a probe number and look at the next spot. Oh look, spot two is full too, but when you increase it again to three, there is room. So, we can put twenty nine there. Any question about it? So, where does eleven go? Into five, good. And how about twenty two? What is twenty two's life like?
Anybody in this room love their surface pro 3? Not one single person, what does that tell you? Alright, I don't know what to do here. I'll let you share my pain, I'm fairly certain that I can connect. Connecting to class, yay! Nothing, I got nothing. You should quit your slideshow, if all else fails just quit your slideshow. Watch, are you watching? How do you restart it? Just power? It's going to have like 10 minutes of updates because I never restart it. What should we talk about? What did you do this weekend? I'll tell you what I did this weekend, are you interested? I watched Gilmore Girls for the first time with my daughter. I had never seen it before so it was great. Alright, anything else? Anybody want to share. Did anyone eat anything good? Unusual food? [student muttering] Who didn't eat chicken? you have to indulge me here, it's monday. Alright, where are we here? Updates are available, I bet you. [student muttering] Connected ha, ha, that's nice. An update is being installed yes! I'm almost there guys, this was the right advice. [video playing] I'm sorry. Yay! I can't believe you're late geez! Sorry everybody. Um, alright, we don't usually talk about hashing tables, that's the fastest way to get someone to go that person doesn't know what they are talking about". We usually talk about hash tables. Uh, so let's do that. I actually would like to hear what delightful things happened to you this weekend. I stayed overnight in Siebel for a slumber party and it was not the first time I stayed overnight in Siebel but it was the first time I had a pillow. So that was exciting. Alright, hash table consists of what? This is like waking up friday. What the heck is a hash table? By asking you about this, I'm asking you about the implementation. Okay, so how do we implement a hash table. What do we need for sure? Name 1 thing. Somebody raise their hand. Yes, an array, very good! So we need an array and that's just your plain old dynamic array right, indexed by numbers. It's the internals of the interface. This is for implementation purposes. Okay, what else do you need? A hash function. Good. We talked last time about that function's qualities. And what else do you need? Right! A collision resolution strategy.
Anybody in this room love their Surface pro 3? Not one single person, what does that tell ya? Alright well I don't know what to do here, we'll try. I'll let you share my pain. I'm fairly certain I can connect. Connecting to class", yay. Okay. Hahaha. Yeah, nothin' I got nothin'. Absolutely nothin'. So, you should quit your slideshow right if all else fails just quit your slideshow. No? Okay and so watch this. Watch. You watching? You got it? And.. show". Look, it even flashed.Okay, fine. How do you restart it? Just, power? Slide to shut down your PC. It's gonna have like 10 minutes of updates 'cause I never restart it. What should we talk about? Yeah what'd you do this weekend? I'll tell you what I did this weekend, are you interested? Yeah, okay I watched Gilmore Girls for the first time with my daughter. It was awesome. I'd never seen it before so it was great. Alright, anybody, anything else? Anybody wanna share? Oh, I wanna know what you ate. Did anybody eat anything good? Food. Unusual food. No unusual food? Chicken. Who didn't eat chicken? All weekend this weekend. No chicken this weekend? No chicken this weekend? You guys have to indulge me here, okay? This is just... It's Monday. Alright... uhhhh... let's see where are we here? Updates are available, I'll bet you. Welcome, don't even tell me welcome. Yeah, don't tell me good morning" either. Connected. Oh, that's nice. Okay. An update is being installed, YES! Okay. I'm almost there, guys. This was the right advice. I'm sorry. Where's my pen? Yaaaaay! I can't believe you're late. Jeez. Gah. Sorry everybody. Ummm. Alright, we don't usually talk about hashing tables, that'd be like the world's fastest way to get somebody to go Hah, that person doesn't know what they're talking about". We usually talk about hash tables so let's do that. I actually would like to hear what delightful things happened to you this weekend. Ummm. I stayed overnight in Siebel for a slumber party and it was not the first time I've ever stayed overnight in Siebel but it was the first time where I actually had a pillow to do so, so that was exciting. Alright, hash table consists of what? Okay, so this is like pulling stuff... this is like waking up friday or something. So what the heck is a hash table? And by asking you this I'm asking you about the implementation. Okay? So how do we implement a hash table? What do we need for sure? Name one thing. Okay, you gotta raise your hand because I don't know what you said. Somebody raise their hand that just spoke. Yes? An array, very good. We need an array. And that's just your plain old dynamic array, okay, indexed by numbers. Okay? It's the internals of the interface. This is for implementation purposes. Okay, what else do you need? Yeah? A hash function. Good. We talked last time about that function's qualities. And what else do you need? Oh... What did we talk about? Yes? Right, a collision resolution strategy.
Or a prescription for what to do if your hash function is not 1 to 1. Ok we talked about 2 different kinds of uh collision resolution. How did I know that was the 3rd thing you guys were gonna tell me, I don't know. 2 different kinds of collision resolution. One was uh open hashing and the example that we talked about was separate chaining. The other one was closed hashing. And the particular example that we talked about was called linear probing. Now we had just begun to address some problems with linear probing. We talked very briefly about the problems with linear probing um under allowing for removals from the structure and it's kind of a technical issue. You can get over it by augmenting your structure with flags that talk about the fact that data has been removed. It really really is the details of the implementation. The second problem that we're gonna talk about in probe based hashing is fundamental. It affects the idea of probe based hashing profoundly and makes you sort of question whether this is a good strategy for hashing. Ok so my inability to get us started today was not my first issue this morning. My first issue this morning came about when I tried to make sure that this link right there which has worked for 5 years in teaching this class still worked. And of course the internets relationship with java has changed since the last time I taught this class and that no longer works. Yeah, so what this means actually is that I have a project if anybody wants to reimplement this in HTML5 I'm happy to describe to you what this used to do. It was awesome, again, it was awesome. It was perfect but its gone. So you'll just have to take my word for it. Um here's sort of what it did. It loaded up a hash table with a bunch of data. Ok so i'm gonna do that, i'm gonna simulate that in this array here. Imagine that that array has 1000 cells or so and I load it up in such a way that you know these chunks are all filled. And then we've got some individual ones maybe. Ok and then we add more data to it. Ok and then we add more data to it. So say somebody says 200 and asks me to hash it in. I would put it right here. And we would have to wait for this much linear probing to happen to add 200 right? And as we hashed into that region effectively we're going to close up this gap, right? Now what's the probability I hash into this region under SUHA? There's a couple answers that would satisfy....be satisfying here. What's the probability? I understand its a nebulous question there are a couple ways of answering it. You could answer it under SUHA in the context of this table if you like. Or you could answer generally. What's the likelihood that a new hash function or that a new hash a new key gets hashed into that darkly shaded region. Anybody wanna talk about it or have a guess or want to clarify the question? Yeah? 1 over table size would tell you the likelihood of hashing into any 1 cell. Ok? So what is that... so the answer is sitting right there. So if this is a whole bunch of cells, contiguous cells, what's the probability of hashing into that collection?
one over the number of them, right? does that make sense? And, In fact, in the context of this particular example. What fraction of whole table is this about? There is no right answer here. We are winging it at this point. What fraction of whole table is that about? A tenth? So, the probability of hashing into that chunk will say is about a tenth. Okay? This happens with about ten percent probability. But look what happens if it does happen. Eventually, if that happens a few times. This gets all closed up. And in fact, that chunk becomes really big, right? Now what is the probability of hashing into that thing? Much larger. Let's say about 25 percent, right? Imagine what would happen? If we hashed into it. So, let's say we get a value that puts us right here. Okay? we would wait, right? wait wait wait wait wait until finally an open spot would be found. Okay. is there a question about that? And, a minute that an open spot is found. We increase the probability of hashing into that thing because we increase the size of chunk. All right? so this is the problem of primary clustering. It is the problem of primary clustering and the description of it is simply in linear probing. If you are linear probing, increases the size of occupied chunks of occupied cells. The magnitude of clusters of occupied cells, which increases the likelihood that you are going to hash into them in the future. The concrete analysis of this I believe is done in 174. not allowed to assume a probability prerequisite for this course. This is probabilistic argument. That says that in fact this comprises the performance and of linear probing. What are we going to do about this? The answer in stead of taking of steps of size 1 for looking for the next available cell. We are going to take steps of random size. Now, where would we get steps of random size? Where would we get the steps of random size? I think using a another hashing function would be reasonable. The remedy here is to take randomly size steps and I will show you what I mean by that in just a minute because it is not just randomly all over the place. It is controlled chaos. randomly sized steps for probing
one over the number of them, right? does that make sense in fact, in the context of this particular example what fraction of the whole table is this? about? there's no right answer here, we're wining it here at this point? what fraction of the whole table is that? a tenth? so the probabl say is about a tenth ok? so this happens with about ten percent probability but look what happens if it does happen? eventually if that happens a few times, this gets all closed up and in fact, that chunk becomes really big now what's the probability of hashing into that thing much larger, say 25 %now imagnine what would happen if we hash into it. that's say we get a value that puts us right here, we would wait, right? until finally an open spot would be found is there a question about that? and the minute that open spot is found, we increase the porbability of hashing into that thing because we increase the size of the chunk, so this is the problem of primary clustering. The problem of primary clustering and the description of it is simply in linear probing, so if you're using linear probing increases the size of chunk of occupied cells. magnitude of clusters of occupied cells which increases the likelihood that you're gonna hash into it in the future. The concrete analysis of this, i believe is done in 374, we are not allowed a probability prerequisite for this course. In fact, it compromises the performance of linear probing. So what are we going to do about tihs? Instead of taking steps of size 1, for looking the next available cell we are going to take steps of random size. Now, where would we get steps of random size?Where would we get steps of random size? I think using another hash function would be reasonable. So the remedy here is to take randomly sized steps and i'll show you what i mean in a minute. It's a control chaos. Randomly sized steps for probing.
Ok, so this is called, ah, double hashing. And hash function looks something like this. It probe based hashing, so you are going to count, umm, the number of probes that you need to do to find an empty cell. You are gonna count them using this index i. But this time, that number probes is going to have a coefficient which is another hash function. So, I'm gonna do the example with the following two hash functions. Our first hash function is gonna be what it was before h1(k) is just k mod 7. And h2(k) the one that determines the step sizes is going to be umm. Oh what was it. It's 5 minus k mod 5. Ok, and I pull that out here. I understand that I pull that out here. Ok. And that's just the example that we are gonna use. Umm, internally, umm but [reos]. Different hash function are used. But this is actually don't. Ok, so how does this work on our particular example. These are the same numbers as last time. So I know how to hash serval of the first ones of them fairly quickly, umm, that is, they work with i=0. 16 hashes to 2. 8 hashes to 1. 4 hashes to 4. 13 hashes to 6 and now let's look at what happens to 29, ok? I'm gonna show you explicitly the functions. h1(k) is 29 mod 7 which is 1. Ok? So we try hashing to cell 1. Umm, h2(k) here is. Oh no, I forgot that this happens. 5 minus 29 mod 5 which is also 1 shot. So in this case the step sizes are 1. Ok? how can I fix that, I don't know, not on the fly. So this right here the distance is h2(29). Ok? So then we have to, you know, that one is occupied too. So we have to do it again. And in that case we move on to i=2 and there is room so we plump 29 down there. Ok? Maybe we should do another one. Let 5, 11 mod 5, ok this one works. Let's do 11. h1(11)=4. h2(11) is 5 minus 11 mod 5 which is also 4. ok? But this time it's ok. So we attempt to hash 11 here. But we can't, so now where do we go? 1,2,3,4. Our second hash of 11 is here. Ok? Becuase, oh so we need, yeah, yeah there is gonna be a mod of 7 at the end of this. That is we wrap around. And now we do 1,2,3,4. 11 maps here the third time. Ok? Any question about this? Kinda mechanical. Kinda mechanical. Sort of unsatisfying a small example. So again, it will be nice to have that [appli] fixed. Send me an email if you love doing interactive web stuff. All right. Any question about it. Yes, 5 I chose, it works nicely if it's relatively prime to the table size. But those for number theoratically reasons, umm, you know, has to do with the group and the e... Just what happens when you have 2 numbers that is relatively prime in cycles within those numbers. So you will never get on cycle, with 5 in 7 you will always good of one of the numbers. Does that make sense? All right, so the hash function. I pull it out to here. You will not gonna ask you'd come up with that. We'll ask to deal with ones that we give you but we won't ask you to come up with them. Yeah Arman. Ah temporary variable? A variable that only exists only inside the hash function?
He thinks he can get to his data faster if he stores the number of probes it takes. If you could keep track of how many times you have to insert it, then you can save yourself time. You have to maintain it back at the original probe location. The process of that doesn't save you time. Lots of things can hash to the same spot. I can draw you pictures for that later. Double hashing is just adjustment to the step sizes you use for linear probing. So how well do these things do? Here are formulas. Don't memorize. Use analytical skills. Alpha is load factor of the table, equal to number of keys divided by table size. They run in time that depend on this load factor. Here's what they look like. Does your key exist in the table or not? Don't look at them to memorize. Tell me what that function looks like. It's undefined and alpha's limit goes to just more than 0. For less than 1, it's a really huge number. Im going to show you the funcitons in just a minute. As table fills, that expression goes crazy, goes to infinity.
No, no, no, no, no, no 
It's still big, right? Still big... Okay, and... Same here, especially if it doesn't exist. We'll talk about this in a minute. So the key thing to observe here is as alpha goes to 1, these functions are nasty. They go to infinity. These are the running times of these functions, okay? So-- that means we should not let alpha go to 1, which means we should not let the table fill. We should not let the table fill. Mmm, hmmm.... Mmmm... Hm... Alright. Finally, finally, notice that in the context of separate chaining, we are not constrained for alpha to be between 0 and 1. So in these cases, alpha is an element of, you know, 0 to 1. I guess it could be like this, where brackets, but then it's a mess... But here, alpha can be larger than 1, because it's open hashing, right? We can hang as many things off of one individual cell as we want. Alright, but, nonetheless, as alpha increases, those running times increase. Okay, let's look at some functions-- let's look at some functions now. Particularly in the case of probing... This is what those functions look like. So there is this sort-of inflection-- so here's alpha along the bottom; I can read them here better than I can actually read them on my tablet, so I'm gonna refer to these here. There is this inflection point beyond which-- jeez, you know, if alpha-- if the table is really close to full, we're gonna be looking a long time for each one of our data elements. That is the clusters that exist-- the clusters that exist are going to be large, okay? Particularly in the case of linear probing, you know, beyond... (laughs) I don't know, beyond alpha not all that big, the amount/number of probes you have to do to find an empty space is really quite large. Now, here's what I want from you: I want you to make a vertical line somewhere along here, that sorta reflects the, you know, the number of probes you're willing to accept in order to find an empty spot for a piece of data. Okay? So just draw a, you know, draw a line that corresponds to, well, I don't even care, right? You could do a horizontal line if you wanted to. The number of probes you're willing to accept. Just do it-- just sketch it on your paper. We'll do one, for example-- we'll do one for example and I'll do the one I can reach. The same exercise can be done on the other table. And that is-- look, if I say that: you know what? I don't care-- we don't mind looking at 4 different cells for every attempt at storing data, then when I do this, then if my alpha is below, you know, 0.75, I've got it, right? So this suggests-- this suggests that if the table is, you know, less than 75% full, then lookup is quick.
It's still big right? Still big, and same here especially if it doesn't exist. Key thing to observe is as alpha goes to 1, functions are nasty. Go to infinity. That means we shouldn't let alpha go to 1. Shouldn't let table fill. Hmmmmm. Alright, finally notice in context of separate chaining. In these cases, alpha is an element of 0 to 1. Here, alpha can be larger than 1. Because its open hashing, can hang many things. As alpha increases, those running times increase. This is what they look like. There is inflection point beyond here. We're going to be looking for a long time for these clusters that exist since they're large in case of linear probing. Beyond small alpha, number of probes is quite large. I want you to make a vertical line that reflects number of probes willing to accept. Draw a line corresponding to number of probes. Then, when I do this, if my alpha is below .75 Ive got it. This suggests if table is less than 75% full, then lookup is quick.
Even if, even if uh the thing I'm looking for is not in the table. Okay. This one is for successful this one is for unsuccessful. Okay. Uhm up there, that same value, we would have to keep our, for that same number of probes, we have to keep our table only half full. Table only half for example. Any question about that? I'm used to having this discussion in the context of that applet. So I don't pretend this is particularly smooth. Alright. Uhh any questions? Is it good? So the idea is that this, these, probe based strategies work by, if you don't let your table get too full. Yeah, Nathan? No. That was just, you know, four doesn't seem like too many. Four's a constant number, seems like it would be quick right? And I can say to somebody, Oh we'll never have to go further than four." Okay? It's a arbitrary choice. But it turns out, well, I'll save that punchline for a minute. Alright, any questions about this? Yes? So successful is if it's in the table, unsuccessful is if it's not in the table. So if you're looking for key that is actually there somewhere, versus if you're looking for a key that is not there, that's the only difference, okay? I, I question, maybe I shouldn't even break them out. Maybe they should, we should, just look at the unsuccessful numbers. Alright, any other questions about this, alright, any other questions about this? The takeaway is that if your table is not, if your table gets full, look how fast those val- those functions go up. But if your table isn't very full, you're in kind of a good shape for these things. Alright, so, uhh, let's be a little let's think about this a little bit. Alright, so, when we were talking about queues, and I, if I asked you, we've got this queue, what do I do if it fills, what do you say? What's your answer? What if the array fills? I should double the array, and copy the data, very good. Okay, that's what we used to have. Here's what we have now. I'm gonna change it up a little bit. So look, we're not going to let the array fill. We're only going to let the array get up to some alphabet we control, some load factor that we control. In practice, the reasonable load factor that is used is approximately two thirds. K, there's an analytical reason for using this, uhm, load factor but in practice, it's about two thirds. So. What if the array becomes more than two thirds full replaces the questions of what happens if the array fills. What if the array, um, is more than two thirds full? Alpha greater than two thirds. Now we don't exactly double the array and copy the data. We find the first prime greater than twice the array size, find first prime greater than twice array size. Because we like prime numbers, but we're not gonna, I'll explain that if you want. Umm and then, instead of copying the data, we do something a little bit different, okay? So I wanna do this example, so that we see what we need to do. So suppose we have hashed our values into this table, and we this hash function, h of k, is a hash of some kind mod table 5, which is 5. K? And we've hashed these three values into it. And another piece of data comes along. Now we're going to find the first prime bigger than twice the array size, oh look, there it is, and copy the data in, okay? So it's just a straight copy. What's the problem with that? What is our new hash function look like? What is the new hash function look like? It's H 1 of k, mod 11, now. Which means that you will never get these guys back, we changed the hash function. So instead of copying the data, so instead of copying the data, we rehash the data with our new hash function.
Even if-- even if, uhh, the thing I'm looking for is not in the table... This one is for successful, this one is for unsuccessful. Okay. Up there, that same value, we would have to keep our finesse-- same number of probes, we'd have to keep our table only half full. Okay, our table only half full, for example. Any question about that? I'm used to having this discussion in the context of that applet-- I don't pretend that this is particularly smooth. Alright. Any questions? Is it good? So the idea is that these probe based strategies work fine if you don't let your table get too full. Yeah? Nathan? [question being asked]. No, that was just-- four doesn't seem like too many; four is a constant number, and it seems like it'd be pretty quick, right? And I can say to somebody, oh, we'll never have to go further than four." Okay? It was an arbitrary choice. But it turns out-- well, I'll save that punchline for a minute. Alright, any questions about this? Yes? [question being asked]. So, successful is if it's in the table, unsuccessful is if it's not in the table. So if you're looking for a key that is actually there somewhere, versus if you're looking for a key that is not there. That's the only difference, okay? I question... Maybe I shouldn't even break them out. Maybe we should just look at the unsuccessful numbers. Alright, any other questions about this? Any other questions about this? The takeaway is, if your table gets full, look how fast those functions go up. But if your table isn't very full, you're kinda in good shape for these things. Alright, so, uhhh... Let's be a little-- let's think about this a little bit. Alright. So, when we were talking about queues, and if I asked you, you know, I've got this queue, what do I do if it fills-- what do you say? What's your answer? What if the array fills? I should double the array... and....? Copy the data. Very good. Okay, that's what we used to have. Here's what we have now. I'm gonna change it up a little bit. So, look, we're not going to let the array fill. We're only going to let the array get up to some alpha that we control-- some load factor that we control. In practice, the reasonable load factor that is used is approximately 2/3. There's an analytical reason for using this load factor, but in practice, it's about 2/3. So, 'what if the array becomes more than 2/3 full' replaces the question of what happens if the array fills. What if the array is more than 2/3 full? (Alpha greater than 2/3). Now, we don't exactly double the array and copy the data. We... find the first prime greater-than twice the array size. Find first prime greater than twice array size. Because we like prime numbers but we're not gonna-- I'll explain that if you want. And then, instead of copying the data, we do something a little bit different... Okay? So, I wanna do this example so that you see what we need to do. So, suppose we have hashed our values into this table, and this hash function h(k) is a hash of some kind, mod table size, which is five. And we've hashed these three values into it. And another piece of data comes along. Now, we're going to find the first prime bigger-than twice the array size-- oh look, there it is, and copy the data in, okay? So it's just a straight copy. What's the problem with that? What does our new hash function look like? What does the new hash function look like? It's h 1 of k, mod 11 now. Which means that you will never get these guys back-- we changed the hash function. So instead of copying the data, so instead of copying the data, we rehash the data with our new hash function.
so we run each of this though the new hash function and they may end up in a completely different location in a new array. but when we go looking for them we know we can find out. ok, any questions about that? So, of the right, those are exactly parallel. we don't fill the array, we don't exactly double the table size, we don't copy the data. But we have parallel things to do in each of those cases. Alright any questions about it? Process called rehashing. Questions? twice array size. so in my worried about having to find the first prime, greater than twice the table size, we can find a prime in a table very quickly. You can store a lot of primes to look up, you don't have to compute them. Certainly enough to create an array of that size. so the question is where does the two thirds comes from. Does it strictly apply to linear probing in double hashing? It's the load factor that corresponds to probe base hashing strategy generally however they are implemented. In general, you want your table to be two thirds full. It's gives you sort of feeling or what's going on behind the scene when you use hash map as well. Alright, any questions about this? So the question is is there any way of escaping the fact that we are intentionally allocating memory that we are going to use, we admit going in that a third that space is not going to be use. I believe the answer to that is no. You have to allow for data to be mapped in to those cells, otherwise you got a different problem. I mean that to sort of equivalent to get a full array and then you got an issue. So we are we? Without these two collision resolution strategy, one of them just pain out the data. The other one use probing to place it in the table. There are others you might be used. For separate chaining, why not using another hash table?or why not use an avl tree? Why not use something else instead of just singly linked list? so the number of variety in that particular structure is astounding. so these are just sort of basic idea. Now given these basic ideas which one is better? The structure speed is weigh faster for probe based hashing, that is, if you can actually fit all your data into an array, that structure will be much faster. But if your data is big, then you can't create an array that's very big using your memory effectively. And so you want to have the ability to hang your data off your structure. So you have big records, then separate chaining is a better strategy. And of course this is a huge simplification. ok, What's structure do hash table replace for use? What do we use to implement dictionary before?
So we run each of these through the new hash function and they may end up in a completely different location in the new array. But when we go looking for them, we know we can find them. Okay any question about that? Otherwise though its exactly parallel. We don't fill the array, we don't exactly double the table size, we don't copy the data, but we have analogous parallel things to do in each of those cases. That process is called rehashing. Twice the array size. So am I worried about having to find the first prime greater than twice the table size? No, we can find primes in a table really quickly. you can store a lot of primes for lookup, you dont have to compute them. Certainly enough to create an array of that size. So the question is where does the 2/3 come from and does it only strictly apply to linear probing and double hashing? It's the load factor that corresponds to probe based hashing strategies generally, however they are implemented. So probably its a double hashing, in general you'll let your table be 2/3 full. And it gives you sort of a feeling of what's going on behind the scenes when you use a hash map as well. So the question is, is there any way of escaping the fact that we are intentionally allocating memory that we aren't going to use. We admit going in that 1/3 of that space is not going to be used. I believe the answer to that is no. You have to allow for data to be mapped into those cells, otherwise you got a different problem. That's equivalent to having a full array, and then you got issues. So, where are we? We got these two collision resolution strategies, one of them just sort of hangs out the data, the other one uses probing to place it in the table. There are a gazillion others that you might use. For example, for separate chaining, instead of a chain, why not use another hash table, or why not use another AVL tree? Why not use something else instead of just a singly linked list. So the number of variability in that particular structure is astounding. So these are just sort of the basic ideas. Now, given those basic ideas, which one is better? The structure speed is way faster for probe based hashing. That is, if you can actually fit all your data in an array, that structure itself will be much faster. But if your data is big, then you can't create an array that's very big using your memory effectively, and so you'll want to have the ability to hang your data off the structure. So if you have big records, then separate chaining is a better strategy. And of course this is a hugs simplification. What structures do hash tables replace for us? What do we use them to implement? Dictionaries. What did we use to implement dictionaries before?
So we run each of these through the new hash function, and they may end up in a completely different location in the new array. But when we go looking for them we know we can find them. Okay, any question about that? Alright so otherwise though it's exactly parallel. We don't fill the array. We don't exactly double the table size and we don't copy the data but we have analogous, parallel things to do in each of those cases. That process is called re-hashing. Questions? Is it okay? Twice the array size. So am I worried about having to find the first prime? Greater than twice the table size? No. We can find primes in a table really quickly. You can store a lot of primes for lookup, you don't have to compute them. Certainly enough to create an array of that size, yeah? So in practice it's about two thirds. So the question is where did the two thirds come from and does it only strictly apply to linear probing and double hashing? It's the load factor that corresponds to probe based hashing strategies generally however they are implemented. So probably it's a double hashing. In general you let your table be two thirds full. It gives you sort of a feeling for what's going on behind the scenes when you use a hash map as well. So the question is, is there any way of escaping the fact that we are intentionally allocating memory that we aren't going to use we admit, we admit going in that a third of that space is not going to be used, and I believe the answer to that is no". Right? That you have to allow for data to be mapped into those cells otherwise you've got a different problem. That's sorta equivalent to having a full array and then you've got issues. Alright any other questions about this? So, where are we? We got these two collision resolution strategies. One of them just sort of hangs out the data. The other one uses probing to place it in the table. There are a gazillion others that you might use, that might be use.d For example. For separate chaining instead of a chain, why not use another hash table, or why not use an AVL tree? Why not use something else instead of just a singly linked list? So the number of variety, the amount of variability in that particular structure is astounding. Okay, so these are just sort of the basic ideas. Now, given those basic ideas, which one is better? The structure speed is way faster for probe based hashing. That is, if you can actually fit all your data in an array, that structure itself will be much faster. But if your data is big, then you can't create an array that's very big using your memory effectively, and so you'll want to have the ability to hang your data off the structure. So if you have big records then separate chaining is a better strategy. And of course this is a huge simplification. Okay, what structures do hash tables replace for us? What do we use them to implement? Dictionaries. What did we use to implement dictionaries before?
AVL tree,B tree yeah sort of but if our data is so big it doesn't fit in memory it is not going to fit in memory here either.Mostly AVl trees maybe a linked list but those have been bad for a long time.So primarily it replaces an AVL tree. I need to go backwards and reemphasize something.I need to go back here.What is the running time of finding something in a hash table?If alpha is constant,what are these running times? They are constant, that's right.When somebody tells you hash tables have constant time access it's because that load factor is held constant in this strategy.Okay so, this re-sizing strategy is used to hold alpha constant.Which means find is constant,insert is constant. And those are probabilistic results so those are average results.Yeah? Sure. No it calling re-hashing,yeah.Seperate chaining is open hashing where you just hang your data out,we talked about it last time.Okay it is the first collision resolution strategy.Alright lets do a lecture like this today okay.Yeah Mike, umm you are not going to because your table is going to be fairly empty,just over half full or so.Yup.Yes.We are gonna put an upper bound on alpha, alpha is never gonna be worse than 2/3 so the functions are never gonna be worse than whatever that is.What else? the absolute worst case is just ignored.If I were implementing a hash table from scratch I would put fault tolerance in it right? Like use two different hash functions and take the better of them say for example. So the question is if alpha is one one less than tablesize/N, if I still take N-1/n and I keep it there that running time is gonna be constant but really bad. So I am still gonna keep alpha fixed relative to the table size so there is no n in the expressions for running time coz alpha is gonna be constant even if it N-1/n close to 1. I am gonna control alpha.I owe you guys alright. I have a puzzle for you. Lets go to a puzzle. So there is a constraint when we use AVL trees, there is a constraint on key space that does not exist for hash table and I am going to constraint on the keyspace for any BST in our case AVL tree that does not affect hashing. To evoke the idea I am going to do this. And ask you what did I do at every vertex here in an AVL tree. What do you do at every opportunity of branching in an AVL tree, what do you do. You decide it is bigger or smaller, you make a comparison. AVL trees require comparable keys.That constraint doesn't apply to hash tables.So AVL trees, BST in general, require comparable keys.
AVL Tree. Anything else? A b-tree, yeah. Sort of. But, if our data is so big. If our data's so big, it doesn't fit in memory. It's not gonna fit in memory here either. So, mostly AVL trees, maybe a linked list. But those have been bad for a long time. Okay, so, primarily. Primarily it replaces an AVL tree. you know what, I'm sorry. I need to go backwards. I need to reemphasize something. I need to go back to here. What's the running time of finding something in a hash table? If alpha is constant. If alpha is constant, what are these running times? They're constant. That's right. When somebody tells you hash tables have constant time access, it's because that load factor is held constant in this using this strategy. Okay, so, this resizing strategy is used to hold alpha constant. Which means find is constant. Insert is constant. And those are probabilistic results so they're average results. Yeah? Sure. No, it's what we're rehashing. Separate chaining is open hashing where you just hang your data out. We talked about it last time. Okay, it was the first collision resolution strategy. Alright, anything else about this? Let's do a lecture like this today. Let's do this. Yeah, Mike? You're not going to because your table is going to be fairly empty. Your table's just gonna be over half full or so. Yup. Yes. We're never... yes, it gets smaller. So we're gonna put an upper bound on alpha. Alpha's never gonna be worse than 2/3 which means those functions are never gonna be worse than whatever that is. Alright, what else? Yes? The absolute worst case is usually just ignored. Yup, and if I were implementing a hash table from scratch, I'd like put full tolerance into it like use two different hash functions and use the better of them say, for example. Yeah? So the question is if alpha is one less than the table size over capital n. Still, if I take big n over little... I mean if I take n-1 over n and I keep it there, that running time is gonna be constant but really bad. So, I'm still gonna keep alpha fixed relative to the table size. So, there is no n. There's no n in expressions for running time. Because alpha is gonna be constant even if it's n-1 over n. Even if it's really close to one. I'm going to control alpha. Alright, what else? Alright, I have a puzzle for you. Let's go to a puzzle. Puzzles are always safe. So there is the constraint. When we use AVL trees, there is a constraint on the keyspace that does not exist for hash tables. And I'm going to... uh, so there's a constraint on the keyspace for any binary search tree, in our case, BST, that does not affect hashing. And to evoke the idea, I'm going to do this. And ask you what did I do at every vertex here in an AVL tree? What do you do at every vertex, every opportunity of branching in an AVL tree? What do you do? You decide if it's bigger or smaller, you make a comparison. So, AVL trees require comparable keys. That constraint doesn't apply to hash tables. So, AVL trees... BST in general. AVL trees require comparable keys.
And the implication there is less than is defined on heaps and we don't have that constraint on hash tables. So why do we talk about binary search tree at all if hashing is so great? The answer to that is simply that in avl trees get us something else. They get us data nearest neighbor search They give the ability to, if we have distance defined we can evaluate how close we are to a particular key. Where as in hashing, two keys that are close in distance could be way far away from each other in the table BST assures that similar keys are close to each other in the tree. Hashing doesn't give you that. No such assurance. Hashing can make no such assurance. Now, what does this mean? It means that I can saving an AVL tree, okay here's a key, I know its not in the tree, but give me the closest one. You can't do that in a hash table. If I come to a hash table with a key and say I know this isn't here give me the closest one" it will go "what?" and not able to respond efficiently. Alright, ahhhhhhhhhhh! Bleh!
Okay we're in the middle of it. We have no exams coming up. I'm hoping to have the histogram for exam 1 on Friday. You should hear from us about your exam results sometime between now and then. I haven't looked to see the progress of grading, but I do know that one grad student gave us their rubric only yesterday or so. So grading is not done, but it's happening, we'll get there. That's all I have in terms of announcements. Are there any administrative questions or issues that you know of? Finals monday night, 7-10. That might be the ideal final time. So the question is, will there be an MP over the break. And the answer is no, we didn't count break as time you would put towards an MP but there will be one that's assigned. So our intention is you start working on it before you leave, and then take a week off, and then come back and you'll still have plenty of time to work on it. So that's the intention. But it is out there so it's not quite true for me to say there isn't one, there kinda is. So I have a secret mystery data structure today, here it is, here's a picture of it. So that's supposed to be a bag. It doesn't look like a bag. First what I want you to do is experiment and ask me what kinds of things I am willing to put into my bag. I'm not going to put anything in right now, but I want you to query me and say can I put this in your bag? We're thinking of types of things. So here's the yes column and here is the no column. So go ahead, I'm willing to entertain suggestions. Oh can I put... Ohhhhhhh I wish I had a cookie to give to you. thats a really good and deep question. Ohhhh can you give him a cookie? Now I wish I had a kitten to give to you. Whose got a kitten? Alright, a bag, I don't think I can put another bag in my bag. I don't think I can. So this is my bag. That might be the question of the semester right there. Yeah? Fruit, no I can't put fruit in my bag. I'll even generalize, I can't put food in my bag of any kind. Okay? Ask yes? No I don't have a way of putting people in the bag, it's not big enough. Can I put nodes? I can't put nodes in. You guys stink you can't figure out what I can put in my bag. Come on. Yeah? I can put real numbers in my bag. Anything else? that is not the only thing I can put in my bag. Yeah? I can put pointers in my bag yeah. sure. I think i can put strings in my bag yeah. yeah mike? yeah I can put chars. yeah nathan, PNGs? no I don't think I can put PNGs into my bag.
Okay. We're in the middle of it, we have no exams coming up, I'm hoping to have histogram on exam 1 on Friday for you should hear from us about your exam results sometime between now and then. I haven't looked to see what the progress is of grading, but I do know that one grad student gave me their rubric only yesterday. So, I think that they gave us rubric only yesterday or so. So, its grading is not done but it's happening. So, we'll get there. Let's see. That's all I have in the way of announcements. Are there any administrative questions or issues, that you know of, what you wanna ask? Finals on Monday evening, is that right? Monday night. seven to ten. That might be ideal time for final actually. So, the question is, will there be a MP over the break? and the answer is no, we didn't count the break as time that you would put toward MP, but there will be one that's assigned. So, our intention is that you start working on it before you leave and then take a week off, and then come back and you will still have plenty time to work on it. So, that's the intention. But it is out there. So, it's not quite true for me to say there isn't one cuz there kind of is. All right. So, I have a secret mystery data structure today, here it is, here's the picture of it; that's supposed to be a bag. First, what I want you to do is experiment and ask me what kinds of things I am willing to put in my bag. I'm not gonna put anything in right now, but I want you to query me and say can I put this in your bag". We're thinking of types of things. So, here's the yes colum, I'll put these in my bag, and here is the no column; I will not put these in my bag. So, go ahead, I'm willing to entertain suggestions. Oh, I wish I had a cookie to give to you! That's a really good and deep question. Oh, can you give him a cookie? Now I wish I had a kitten to give to you! Who's got a kitten? Alright. A bag, I don't think I can't put another bag in my bag. And I don't think I can't. So this is my bag. Good question. Wow. That might be a question of semester right there. Fruit. No, I can't put fruit in my bag. I'll even generalize I'll not put in food in my bag of any kind. Ask! Yes? No, I don't have a way of putting people in the bag. Yeah? Can I put nodes? I cannot put nodes in. You guys stink! You can't figure out anything I can put in my bag, come on! Yeah? I can put real numbers in my bag. Okay? Anything else? That is not only thing I can put in my bag. I can put pointers in my bag. Yeah! I can put pointers in my bag, sure. I think I can put strings in my bag. I can put chars. What did you say? PNGs? No, I think I can put PNGs in my bag.
Okay. What's different about these lists? These are some good lists, what's different about these lists? What distinguishes one list from another? No, these are more than primitives. Strings are not primitive, we treat them as primitive because we use them so much but they certainly are not primitive to the language. In fact, I could put booleans in there but that wouldn't be very intersting to do so. They have a somewhat obvious ordering. Very good observation. So, the English description that he used was a somewhat obvious ordering and I really like that. The way that we capture that observation using a vocabulary word of our domain is that the keys are comparable. So, this list is consists of key types that are comparable. Any question about that? So what does that mean implementation-wise for something to be comparable? This is a review from last time, I actually said the answer to this question last time. What does it mean for things in keyspace to be comparable? That's right. operator less than is defined. So, comparable means a.. I don't know why... okay. So this means less than operator is defined. You will write will more neatly on your own notes. Anybody need clarification of that? It's not written very well. Don't look at where I wrote it, just think about what I wrote. Less than operator is defined. Now, do you agree with me that the things in No list are not comparable? You agree with me? What do you think? Good. Very good. So, this quick response from me to say nah, those are not comparable, I didn't think deeply about it and you can impose a metric on lots of different types that force them to be comparable. But these just as they stand are not. For example, for PNGs, in fact, this is going to be relevant in MP6, you end up using average color value of PNG to enforce sort of comparability in it. So you use an average over the set of pixels to create color value that you can then evaluate distances with. Alright, any questions about that? So, pick your favorite one of these and start asking me to put them into the bag. Pick your favorite one. Which one you like the best? I know, I'll just add one. How about just numbers. real numbers. We'll just take the first one. So, I'm willing to, at this point, to say that my bag is templatized to contain real numbers. You even wanna do imaginary numbers? We could. We'll do real numbers. So suggest something that I put in my bag. Did somebody say four? Did you say four? Well, I'll put four in because that's what I was thinking, I don't know anybody said that actually. I'm willing to put four into my bag. I'll put two into my bag, sure. Anything else? A thousand, sure. Just reminding you that we're talking about real numbers here. Pi? okay. Pi is real, right? Anything else? Good enough? I'm gonna put negative fourty two, because that's fun. So, it doesn't feel like there's anything I'm not willing to put into bag, right? And it's true. Across the keyspace, I'll put everything into bag that you ask me to do so. Insert is just, here it is, put it in.
Ok. What's different about these lists. These are some, these are some good lists. What's different about these lists. What distinguish one list from another. Yeah. No, these are more than primitives. Strings are not primitive. We treat them as primitives because we use them so much, but they certainly are not primitive to the language. In fact, I could put booleans in there, but it wouldn't be very interesting, wouldn't be very interesting to do so. Yeah. Uh, they have a somewhat obvious ordering. Very good observation. So the English description that he used was a somewhat obvious ordering and I really like that. The way we capture that observation using a vocabulary word in our domain is that the keys are comparable. So this list is consisted of types, key types that are comparable. Ok, any questions about that. So what does that mean in implementation. What does that mean implementation-wise for something to be comparable. This is a review from the last time. I actually said the answer to this question last time. What does that mean for things in the key in a key space to be comparable. Yeah. That's right. Operator less than" is defined. So comparable" means, "comparability" "comparable" means. I don't know why. Ummmmm. OK. So this means less than" operator is defined. You will write it more neatly on your own notes. Ok, anybody need clarification of that. It's not written very well. So don't look where I wrote it. Just think about what I wrote. Less than" operator is defined. Now do you agree with me that the things in the NO" lists are not comparable. Do you agree with me What do you think. I'm sorry. Now you trick me. Now you are in the dog house. Yes, Mike. Good, very good. So this, this quick, quick, quick response from me to say no, those are not comparable. I didn't think deeply about it and you can impose a matrix, you can impose a matrix on lots of different types that force them to be comparable. But these just in standard are not. For example, for PNGs, in fact, this is going to be relevant in MP6. You end up using the average color value of a PNG to enforce a sort of comparability in it. Ok. So you use average, an average over the set of pixels to create a color value who, that you then can valuate the distances. Wow, that wasn't English. Alright, any questions about that. Ok, so pick your favorite one of these and start asking me to put them into the bag. Pick your favorite one. Which one you like the best. I know. I'll just add one. Well, how about numbers, real numbers. Ok, we'll just take the first one. So I'm willing to, at this point, say that my bag is templatized to contain real numbers. OK. Do you even wanna do imaginary numbers. We could. OK. Alright, we'll do real numbers. Alright, so suggest something that I put in my bag. Suggest something. Oh. Did somebody say four. Did you say four. Somebody said four.Well I'll put four in, cuz that's what I was thinking. I don't know anybody said it actually. Alright, I'm willing to put four into my bag. Anybody wanna suggest something else. Two. I'll put two into my bag. Sure. Alright, anything else. A thousand. Sure. I'm just reminding you we are talking about real numbers here. Pi, ok. Pi is real, right. Ok, anything else. Good enough. I'm gonna put negative forty-two, cuz that's fun. Ok, good. You are fine. So it doesn't feel like there's anything I'm not willing to put into the bag, right, and it's true. Cross the key space I'll put everything into the bag that you asked me to do so. Insert is just: here it is, put it in.
ok, what's different about these lists. These are some good lists, what's different about these lists. What distinguishes one list from the another? No these are more than primitives, strings are not primitives. We treat them as primitives, we use them so much but they certainly are not primitives to the language. In fact I could put boolean in there but it wouldn't very interesting to do so. they have a somewhat obvious ordering. Very good observation. So the english description that he use was a somewhat obvious ordering. And i really like that. They way we capture that observation using a vocabulary word is that the keys are comparable. The list is consist of types that are comparable. Any question about that? so what's that mean in an implementation, for something to be comparable? I actually said the answer last time. Operator less than" is defined. You will write it more neatly on your own notes. Anybody need clarification? It's not written very well. Do you agree with me the things in the No list are not comparable? This quick response for me to say, no those are not comparable. I didn't think deeply about it. Now you can impose a matrix on lots of different types that force them to be comparable. But this is not. For PNG, in fact, this is going to be used in MP6, you will use the average color value of the PNG to enforce a kind of comparability. A average of a set of pixels to create a color value that you can then evaluate distance with. So pick your favorite one of these and start ask me to put them into the bag. I'll just add one. How about numbers? So I'm willing to at this point my bag is templatized to contain real numbers. Even wanta do imagery numbers? We could. We'll do the real numbers. So suggest thing that I put in my bag. Did somebody say 4? Well I'll put 4 in. I'll put 2 in my bag. A thousand? sure. Just reminding you we're talking about real numbers number? Pi? Pi is real. A negative 42 is fun. So doesn't feel like there's anything I;m not willing to put into bag. And it's true. I will put anything into the bag that you ask me to do so. Here insert is just here it is, put it in.
OK, so how long does it take to insert an unsorted list? Unsorted list, I just want to be putting values in. How much time should that take? Oh, constant time! look at that! There is a mistake already. This should be constant time. Good. How about removeMin? Is order n correct? I want to find in an unsorted array the minimum value. Yeah? That's fine, right? So, order n is correct. I would have to go on a hunt through the linear collection of data, looking for the minimum. Ok, fine, how about for a linked list? If we implemented this functionality in insert and removeMin, using a singling linked list. How much time would it to take to insert? Constant, but we want to put the new one back here, right? No, no reason to do so. It is unsorted, so when you insert, you would insert at the front. You can do this at constant time. Or, you have a tail pointer you can do it at the rear. Ok, fine. How about removeMin? Still big O of n? We would have to go search for it. OK, fine, let's suppose, we decided that we can fix this, we will fix this by using a sorted array. In that case, how long does it take to do an insertion? A sorted array. 2,3,4,8,13,21, and I want to insert 11. How much time does it take? Log(n) right? How come it is logn? why are we thinking logn? Binary search, very good. You observe the opportunity of binary search. So, we use binary search to determine the 11 goes here, but we have to shift the data. This is not true. Oh gosh! I swore when I came to school, today would be a better lecture than Monday's. That's a low bar. How about a linked list? a sorted linked list. Can you do binary search? No, you cannot do binary search in this case. It is big O of n to find. Ok, this is the moment where oh boy, this is for find and this is for shift. Ugh, how about removeMin? How about removeMin? Are these correct? They constant in both cases? Is this correct? Could this have been correct if I put those differently? So, ok, I should have done 21, 13,8,5,3, and then it would be constant time. Because we always remove frome the end of the chunk of the data. Ok, how about for a singly linked list? Does it take constant time to remove the minimum? Yes, if you keep the minimum where? At the head of the list, right? What if you kept the minimum at the tail pointer? So, I am going to keep the minimum here, and I have a tail pointer. What do you think? Removing that guy. No, because I can get to it in constant time, but resetting this tail pointer while the traversal of the structure. OK, everybody good? Ok, so, take a look at this messy table, and it looks like there is trade-off going on, right? So, we got constant time, for on of the functions, and linear time for the other function. What would be better than this? What would be better? Log(n)? Log(n) would better especially if we were able to replace the linear time functions with Log(n). Well, I am not going to tell you how good it gets, instead, I am going to switch gears, so that's a reasonable goal. The question is, whether we can do log(n) here and constant time here. Just how good can we do using a different structure. Ok? Now. I want to leave this one hanging, OK? Because I want to show you something completely new. This will be more fun for you. If you focus here instead of your paper. Ok, don't look, I know you want to look, right? but don't. Ok? Alright. So, here is a new structure, what I want you to do, is tell me, everything you can about it. Tell me everything you can about it. Everything you might be think interesting, everything you think characterize it.
Okay. So, how long does it take to insert into an unsorted list? unsorted list I just want to be putting values in. How much time should that take? Oh constant time. Look at that. There is mistake already. This should be constant time. Good. How about removemin? is Order(n) correct? I want to find in an unsorted array the minimum value? Yeah? That is fine, right? Okay. So, order(n) is correct. I would have to go on a hunt through the linear collection of data looking for the minimum. Okay. fine. How about for a linked link? if we implemented this functionality, insert and removemin using a singlylinked list? how much would it take to insert? constant? I would put the new one back here right? No, no reason to do so. It is all unsorted. So, when you insert, you would insert at the front. you could do that at constant time. Or, you have a tail pointer, you could do it at the rear. Okay. Fine. How about removemin? Still O(n). we would have to go searching for it. Let's suppose. we decided we can fix this. we will fix it by using a sorted array. In that case, how long does it take to do an insertion into a sorted array. two three five eight thirteen twenty-one. And, I want to insert eleven. How much time does that take? Log(n), right?? Log(n) to. how come is it log(n). Why are we thinking log(n)? Binary search. Very good. You observed the opportunity for binary search. we used binary search to determine that eleven goes here but we have to shift the data. So this is not true. Oh, Gosh. I swore when I came to school. Today would be a better lecture course than Monday's. Of course, that is a low-bar. All right, How about for a linked list? sorted linked list? Can you do binary search? No. Can't do binary search. In this case, it is big O(n) to find. Okay, So this is the moment. This is for find. This is for shift. How about removemin? how about removemin? Are those correct? They are constant both cases? Is this correct? Could it be correct, If I have put those differently? Okay. So, I should have done, twenty one, thirteen. eight, five, three, and then it would be constant time. It would always remove from the end of chunk of data. Okay. And, how about for a singlylinked list? Is it constant time to remove minimum? Yes, if you keep the minimum where? At the head of the list, what if you keep the minimum at the tail and you have the tail pointer? So, I am going to keep the minimum here and have a tail pointer. What do you think? Removing that guy? No, because I can't get to it in constant time. Resetting that tail pointer requires a traversal of structure. Everybody, good?? Okay, so take a look at this messy table. And, it looks like there is some trade-off going on, right? so we got constant time for one of the functions and linear time for the other functions. What would be better than this? What would be better? log(n). log(n) would be better especially if we were able to replace the linear time function, log(n). Well, I am not going to tell you how good it will get. Instead, I am going to switch gears so that is a reasonable goal. The question is whether or not we can do log(n) and constant time here. Just how good can we do? Using a different structure. Now, I want to leave this one hanging because I want to show you something completely new. This will be more fun for you if you focus here instead of on you paper. No. Don't look. Don't look. I know you want to look, right? but don't. All right. So here is a new structure. What I want you to do is tell me everything you can about it. Tell me everything you can about it. Everything you think might be interesting. Everything you think characterizes it
Ok. How long does it take to insert into an unsorted list. Unsorted list. I just want to put values in. How much time should that take? Oh constant time. Look at that. There's a mistake already. Constant time. Good. How about removeMin? Is o(n) correct? I want to find in a unsorted array the minimum value. Thats fine right? Ok. o(n) is correct. I would have to go on a hunt through the linear, a collection of data looking for the minimum. Ok. Fine. How about for a linked list. If we implemented this functionality insert and removeMin using a singly linked list. How much time would it take to insert? Constant. I would put the new one back here right? No. No reason to do so. It's all unsorted. So when you insert, you would insert at the front. You want to do that in constant time. Or if you have a tail pointer you can do it at the rear. Ok, fine. How about removeMin? Still o(n). We would have to go searching for it. Ok fine. Let's suppose we decide we can fix this. We will fix it by using a sorted array. In that case, how long does it take to do a insertion into a sorted array? Two, three, five, eight, thirteen, twenty one. And I want to insert eleven. How much time does that take? Logn right? How come its logn? Why are we thinking logn? Binary search. Very good. So you observe the opportunity for binary search. So we use binary search to determine that eleven goes here, but we have to sit the data. So this isn't true. Oh gosh. I swore when I came to school today. Today would be a better lecture. Of course then Mondays. That's a low bar. Alright. How about for a linked list, a sorted linked list? Can you do binary search? No. Can't do binary search in this case. It's o(n) to find. Ok so this is the moment where. This is for find. This is for shift. How about removeMin? Are those correct? They are constant in both cases. Is this correct? Could it be correct if I have put those differently? Ok. So I should have done twenty one, thirteen and eight, five, three. And then it would be constant time. Cause we always remove from the end of the trunk of data. Ok. How about for a singly linked list? Is it constant time to remove the minimum? Yes. If you keep the minimum where? At the head of the list. Right? What if you keep the minimum at the tail and you had a tail pointer. So I'm gonna keep the minimum here and have a tail pointer. What do you think? Removing that guy. No. Because I can get to it in constant time but resetting this tail pointer requires traversal of this structure. Ok. Everybody good? Ok. So take a look at this nasty table. And it looks like there's some trade off going on. Right? We got constant time for one of those function and liner time for the other function. What would be better than this? What would be better? Logn would be better especially if we are able to replace the linear time function with logn. Well. I'm not gonna tell you how good it gets. Instead I'm gonna switch gears so that's a reasonable goal. And the question is whether not we can do logn here in constant time. Just how good can we do. Using a different structure. Ok. Now. I want to leave this one hanging. Because I want to show you something completely new. This would be more fun to you. If you focus here instead of on your paper. Ok. Don't look. I know you wanna look. Right. But don't. Alright. So here's the new structure. What I want you to do is tell me everything you can about it. Tell me everything you can about it. Everything you think might be interesting. Everything you think characterizes it.
You guys are like on it today, yes? Aye! It's a complete tree, a complete binary trees. So good observations. So, I'm gonna write that down. It is a complete binary tree. Ok, anything else?Yes? It's what? Ordered in its levelS but it isn't OHH! It isn't ordered in its levels, that kind of a interesting in itself, right? yeah? OHHH---, Very good, ok? So this is a complete tree, where each parent is less than its two children. Each parent 's key, each parent's key is less than the keys of its 2 children. Ohh, that's new, we haven't seen such a thing before. This two things together actually characterize the structure compeletely, though typically we will take an input implication of the second, and that implication is the following: that every path from the root to a leaf is monitonically increasing. Very good. So the implication of the second one that we're gonna use is- every path from root to leaf is increasing. Ok, this structure that you've now characterize has~ a special name, it's called a heap. It's acutally a binary min heap, but we just very quickly refer to it as a heap. Ok. So I want to do a quick recursive definition, ok? So the quick recursvie definition is a binary min heap is a complete tree, with a following characteristics: T equal an empty tree is a binary min heap. And if T equals a root together with a left subtree and a right subtree, ok? then the key of the root(the key of r) is less than the key of TreeL's root and TreeR's root, if they exist, and furthermore, TL and TR are heaps.
So this characteristic is true, recursively. OK but, but.. were actually not going to end up relying very much on this particular depth definition. The focus of the algorithms that we write on this structure are going to rely on this and on this. OK. Any questions about that so far? Here's a quick question are complete trees full? Is every complete tree a full tree? No, good. Is every complete tree a perfect tree? No. Is every perfect tree a complete tree? Yes. OK good you see where that conversation is going right? OK so let's talk about implementation of this thing and what I want to know. What i'm going to ask you to do is imagine how you would implement this thing and then, huh, tell me what the primary private member would look like in your implementation. OK so think about what your, how you would implement it and then tell me what the primary member or the the primary private member of that implementation is. Anybody want to offer something? Tell me what you think. What do you think? It's a treee! So what is, how are you going to characterize this tree in code. You're not going to, you don't want right? I don't wanna. Have you done things like this in the past? You're not talking to me? It's OK to be wrong. In fact lets day something that is wrong. I'm going to implement this tree using an integer. OK that's wrong. OK now that's out of there. So now somebody venture were we're past that, so somebody venture something. You're implementing a structure like this that has two functions what is your primary private member going to be? How are you going to hold the data? A tree node? Is that what you said? Thank you so much. Now I owe you a cookie. Did you say that? He said it? OK now he owes you a cookie. OK. Alright very good. Well.. so a tree node pointer called say root, perfectly reasonable implementation, perfectly reasonable implementation, except that we don't have to do it that way instead. ooohhhh. What's the implication? We can use an array. We can use an array. Now the thing that gets us this, is that the tree is complete. OK. We know everything there is to know about the structure of the tree. That is not so true in AVL trees and BSTs in general OK. But in this case we know everything there is to know about the structure of the thing. So we're going to exploit that and say Hey I know where the children and parents are". We're just going to lay it flat out in memory. Now in MP6 that is true as well. We are going to use a vector an array to implement the tree but it is slightly different. Where is the root in this implementation. Where is the root? Right. Early on in the array, the front of the array. Right. In MP6 the root is kind of in the middle and all the nodes in the left are less and all the nodes to the right are greater in some sense. OK. So it's a little bit different of an interpretation of using a flat, a flattening the tree. But it sort of takes advantage of the structure speed of an array in a, for similar reasons. OK now. Huh in a pointer based implementation of a tree. It's important to have the following pieces of information. You need instant access to a left child
But we're not going to end up relying very much on this definition. Here's a question: are complete trees full? Is every complete tree full? No. Is every complete tree a perfect tree? No. Is every perfect tree a complete tree? Yes. Ok, so lets talk about implementation of this thing. What I'm going to ask you to do is imagine how you would implement this thing and then tell me what the primary private member would look like. So think about how you would implement it and tell me what the primary private member of that implementation is. Tell me what you think. What do you think? It's a tree! How are you going to characterize this tree in code? Have you done things like this in the past? We can implement this using a TreeNode. A TreeNode pointer calls say the root. Perfectly reasonable implementation except that we don't have to do it that way. Instead, we can use an array. We know the complete structure about the tree. Now, in MP6 that is true as well. We're going to use a vector to implement the tree but it's slightly different. Where is the root in this implementation? Early on in the array, at the front of the array. In MP6 the root's in the middle. Ok, now in a pointer based implementation of a tree, it's important to have the following pieces of information: 1. You need instant access to a left child
I'm gonna leave it like this. I don't like leave off by one error there. How would we prove that was true? this is my best out here. This height is log N? Not induction yet. First of all what we are gonna do is twist the question around to the minimum number of nodes in the tree of height h. Answer is that and then do induction and invert it. The maximum height of a complete tree containing n nodes, we are going to say the minimum number of nodes in a tree of height h. Ask the inverse question. Algorithms that traverse the root to leaf are going to be log n. How do we insert into this structure. I'll draw like this. Here's what I wanna know from you. Tell me a number that would be a key to e super easy to insert into this structure. 13 would be super-easy to insert. Where does it go? It goes into 7. right here. The reason it's super easy to insert is it's greater than 7 so it's correct and easy to insert because it's something that goes right here in the array. Anything that is greater than 7 can go that spot and that spot corresponds to this cell. The smallest one would be 8 but it's already in the tree. So 10 would be fine. I'm gonna insert 5. I want to insert 5. you don't like it because it breaks the key property, where that property is an order, a monotonically increasing path from the root to a leaf. So how can I fix it? Swap! very good observation. I can just, it is safe, for me to swap 5 and 7 here. Because if 5 is less than 7, then it is certainly less than 11 because 11 is greater than 7. It is okey parent for its sibling. It is an okey parent for the other side of the tree. So that was a safe thing to do. Do it again! Is it safe to swap 5 up to here? 2 things are going on. I believe you understand it's ok to bring 5 up. But is it ok to bring 6 down? Anything less than the previous key is ok. And we know 6 is less than 7. But we know 6 is less than 7 because it was above it and it was a heap to start with. So it's okey to bring 6 down. Now the heap property this property about increasing path from root to leaf is restored. That process, that swapping process, we refer to as heapifyup.
Questions? you good? Okay. Let's see. I don't know if this is right. I'm gonna leave it like this. I don't want to like leave off by one errors there. Alright, how will we prove if that was true? This is my best out here. How do we prove that that's true? That this height is log n? No. Not induction yet. Not induction yet. First of all, what we're going to do is twist the question around to the minimum number of nodes in a tree of height h. Right? So twist the question around, answer that, prove that by induction and then invert it. So the maximum height of a complete tree containing n nodes. We're gonna say the minimum number of nodes in a tree of height h. We're gonna ask the inverse question. Alright. Fine. Log n. Algorithms that traverse height to to top root to leaf are going to be log n. Fine. How do we insert into this structure? Now here i'll draw this like this. This zero. This doesn't work anymore. Don't look at it. alright here's what i want to know from you. Tell me a number that would a key would be super easy to insert into this structure. Super easy to insert. Tell me a key that would be super easy to insert. Yeah? 13 would be super easy to insert. Where does it go? It goes into seven's right. Right here. Right? The reason it's super easy to insert is. it's greater than seven so its correct and its easy to insert because it's something that goes right here into the array. Okay fine. Anyhting that is greater than seven and is gonna be can go in that spot and that spot corresponds to this cell. Okay. Good observation so three thousand would be enough. The smallest one would be eight but it's already in the tree. Alright so 10 might be the smallest one. Okay fine. I'm going to insert ohhh i don't know. You want five? That's what I was going to say. Really? okay. Yeah I'm telling you, the E.S.P runs strong in this room. I want to insert five. Do you like it? (Crowd says no). Okay you don't like it because it breaks the heap property. Where that property is an order a monotonically increasing path from root to the leaves. So how can I fix it? Swap. Very good observation. Look. I can just. it is safe. it is safe for me to swap five and seven here. right? Because if. if five is less than seven then it's certainly less than eleven because eleven is greater than seven. right. So if five is less than seven then it's an okay parent for it's sibling. Wait. It's an okay parent for the other side of the tree. Okay. Alright fine. So that was a safe thing to do. Are we done? Oh what should we do? Do it again. That's right. Is it safe for me to swap five up to here? Wait a minute. Two things are going one. I believe. I believe you understand it's okay to bring five up but is it okay to bring six down to this spot. Is it okay? Anything less than the previous key is okay. And we know six is less than seven because we learned it when we were two. But we know six is less than seven because it was above it in the tree. And this was a heap to start with. Okay. So it's okay to bring six down. And now the heap property. This property of a path increasing path from root to leaf is restored. Any question about it? That process. That swapping process we refer to as heapify up.
OK. My question is what is running time. log(n). It was constant time to put the original value in place and then you gonna to swap all the way up. Let's write some code. So here is insert. It is if the size is equal to. Wait a minute. This is we got an array has big size. How big is that array ever going to be. If that array is full. We better grow it somehow. Then we are going to increment the size. The current biggest location place our value into that position. So that was putting five at the end of the existing chunk of data in previous example. We are gonna call a helper function heapify up from that location. That is exactly what we wanna did in the previous page. Double the size and copy the data. Here is the beautiful thing. Doubling the size means opening up the next row of the heap. Is that awesome? So let's talk about heapifyup for a minute. So the cIndex is the current index, and basically I want to know if I should keep going. I wanna know if I should keep going and so it is basically the cIndex is more than zero. Cindex is relative to its parent. If it is less than its parent then I am gonna call some swap function, swap those keys. May be I am gonna swap intems[c] index with items[cparrent]. And then I am gonna call heapifyup on the parent.
And my question is what's its running time? log(n)! That's right, right? It was constant time to put the original value in place and then at worst, you're going to do swaps all the way up. All right, any question about it? Yes? I didn't fix the array, I know, I was being lazy and you called me on it. Fine. This is five. This is seven. This is five. This is six. Now? Now we're good? Is it good? Okay. All right, any question about it? Okay, fine, let's write some code. Okay. So here's insert, okay? It is, if the size is equal to oh, oh wait a minute. Wait a minute. This is, you know, we've got an array. It has fixed size. How big is that array ever going to be? Well, we don't know necessarily, but if that array is full, we better grow it somehow. Talk about that in a minute. Then we're going to increment the size. Increment the current biggest location. Place our value into that position. So that was putting the five at the end of the existing chunk of data in the previous example. And then we're going to call a helper function called heapifyUp from that last location. Okay? Any question about that? That's exactly what we did on the previous page. Now, I want to show you something truly beautiful. Okay? If the size is the same as capacity, it means the array is filled. So, our remedy is.. What is it? Double the size and copy the data. Right? So like this. Double the size and copy the data. Here's the beautiful thing. This is the thing that gives me goosebumps. Okay? Doubling the size means opening up the next row of the heap. Isn't that awesome? It's beautiful, right? We're so lucky. All right, any questions about it? Okay. So that's what we'll do. We'll open up the next row. We filled up this row, we'll double the size, copy the data it corresponds to, adding another row. Any questions about it? You're good? Okay, so let's talk about heapifyUp for a minute. Um. So, the cIndex is the current index and basically I want to know if I should keep going. I want to know if I should keep going, and so it's basically if the cIndex is greater than zero. And maybe it's one here, actually, because of our particular implementation. Okay? If the uh item at cIndex is what relative to its parent? If it is, it's less than its parent. Right? Because we're trying to move it up. So if it is less than its parent, then I'm going to call some swap function that swaps their keys. Swaps those keys. Uh, so maybe I'm going to swap items[cIndex] with items[parent(cIndex)], and then I'm going to call heapifyUp on the parent.
Ok,any question about it? Simple code, complex, complex ideas, simple code. Alright, any questions? You good? Ok I wanna start with remove, we've got, according to my watch, we have 3 minutes, and so I wann leave you,I wanna leave you hanging in the middle of remove min, ok? So where's the minimum, always? At the root, I will return it everytime. The heap is broken!! We have broken the heap by removing the minimum. What are we gonna do? It's like cutting off you're right an left arm. What on earth are we gonna do? We need some glue, we need some glue to glue it back together. Where might the glue come from? In this case, ok, so I am gonna do this in red, and that's a little bit of a hint, that is gonna get abrase later, ok? So, uhm, we might say: Oh look! we can just move 5 up, right? and then we can just move 9 up, right? and then we could just move 12 up. But then, its not a complete tree. Ohhh---, Ok, so I am gonna earse all that beacuse that breaks the completeness, which kind of breaks our whole reason for using the array to begin with, ok? The only element of the tree, the only node in the tree that I have easy acess to, that I can grab without breaking anything else is-11, ok? So, here's the justification, I know I need to remove something from the structure, I know I need to remove something from the structure. The easiest thing to remove from the whole thing is 11. So I am gonna remove 11 and use it as the glue, ok? where the thing I really wanna remove lives. Ok, so I am gonna remove 11, oops! I shouldnt do this part in red beacuse it's actually gonna work, usually. Ok? So we gonna remove 11, perfectly fine, use it as the glue up here, and we're good right? No! what are you gonna do? how are you gonna fix this? Swap 11 with- 5 in this example. In general, it's minimum child, ok? So we are gonna swap with the minimum child. So we swap 11 with 5, and then we swap 11 with 9. Oops! And then we swap 11 with 12. Uhm, No! no! no!, then we observe that 11 is greater than both of its parents, so we can quit, ok? Any question about that? yeah? Hey you guys! He can't talk if you are loud, go ahead. Not necessarily, not necessarily, and first of all, anytime you say the word shift", I am gonna go "hargh! hargh! hargh!, right? Uhm, but, but also you can also messed up the order by doing that: you dont know anything about the relative values of these keys with these keys. Alright see you next time, we will implement it next time.
Okay.. any question about it? Simple code, complex... complex ideas, simple code. Alright, any questions? You good? Okay. I wanna start with remove. We've got, according to my watch, we have three minutes and so I wanna leave you.. I wanna leave you hanging in the middle of removeMin, okay? So where's the minimum, always? At the root. Dunk! I'll.. I'll.. I'll return it every time. [GASP] The heap is broken! We have broken the heap by removing the minimum. What are we gonna do? It's like cutting off your right and left arms, what on earth are we gonna do? We need some glue. We need some glue to glue it back together. Where might the glue come from? In this case, okay so I'm gonna do this in red and that's a little bit of a hint that it's gonna get erased later. Okay? Okay? So.. uh.. we might say oh look! We can just move five up, right? And then we could just move nine up, right? And then we could just move twelve up, but then, it's not a complete tree! Ugh..... Okay. So I'm gonna erase all that cause that breaks the completeness which kind of breaks our whole reason for using the array to begin with. Okay. The only element of the tree, the only node in the tree that I have easy access to, that I can grab without breaking anything else is... eleven, okay? So here's.. here's the justification, I know I need to remove something from the structure, I know I need to remove something from the structure. The easiest thing to remove from the whole thing is eleven. So I'm gonna remove eleven and use it as the glue, okay. Where.. I.. where the thing I really want to ..[gibberish].. remove lives. Okay so I'm gonna remove eleven. Whoops. I shouldn't do this part in red cause it's actually gonna work. [Gibberish].. usually. Okay so we're gonna remove eleven. Perfectly fine. Use it as the glue up here. And we're good right? No..., what are you gonna do? How're you gonna fix this? Swap eleven with... five in this example, in general it's minimum child, okay. So we're gonna swap with the minimum child. So swap eleven with five. And then we swap eleven with nine. Oops. And then we swap eleven with twelve. Uh.. no. No. No. Then we observe that eleven is greater than both of its parents so we can quit, okay? Any question about that? Yeah? Okay you guys, he can't talk if you're loud. Go ahead. Not necessarily, not necessarily and first of all anytime you say the word shift, I'm gonna go [gibberish]... right? Um.. but, but also you can mess up the order by doing that. You don't know anything about the relative values of these keys with these keys, okay? Alright see you next time, we'll implement it next time.
Alright, let's start. I never get it, it must not me. Okay, um, I have no news on the exams. I just don't know yet. I was there yesterday afternoon, and there were still two blank columns or largely blank columns for problem 22 and 24 something like that. So I have absolutely no clue about averages. All I heard is we should draw a picture for perfectify. I don't know, I am not even make a promise when those exams are going to be available. Not gonna to promise anything because you know what course staff tole me. I said I want to get this done by Friday, we can get this done by Friday. And they said you shouldn't promise Friday. And I said no, if I promised Friday we will make it Friday. And they said you shouldn't promise Friday. And I completely ignore them, and they were right. So, I'm sorry. Always listen to the course staff. Hmmm.... Alright, um so, mp6, oh let's see there is a social announcement is the semi-formal tonight. Raise your hand if you're going to the semi-formal tester street art? Nobody in this room? It's like WCS, IEEE, ACM. Every student organizations between ECE department and CS department combing to do this fancy party tonight. Suppose to be really fun and I think they still have tickets. Look like there is about a hundred people going. So, including some cs225 course staff. So, you don't have anything do tonight um it's a facebook event you can get there. Is anybody going? really? nobody? Didn't know about it. Alright, nevermind, don't go. It's your thought there, what kind of party possibly be. Um, alright, let's see. So, give me one more description of that thing. It's heap, that's right that's a heap. A two words description, I want a two words description of the abstract data type where considering using a heap for? A priority queue, very good. So, this structure right here is our latest, greatest, attempt, and clever cause we are also clever implementation for a priority queue. okay? what uh abstract data type, I'm sorry, what implementation do we try before? What are we trying to improve over? Do you remember from last time? We first implement a priority queue with just give me one. A bag? right, yeah the bag didn't work out so well. What was the implementation? A linked list, sorted or unsorted? Either we try both. The other linear structure we try is an array. Sorted and unsorted. And those all you know they have things that we liked about and they also have things we didn't like about them. Alright, that's all about last lecture in the show right there. Alright, this thing is a heap, how do we implement it? how is the, what is the implementation of a heap? What structure did we use to implement a heap? An array, that's right. So that's a piece that the first length is a little counterintuitive because this thing is a binary tree right? And all the binary tree we talked about so far have tree node pointer, and been recursively traverse etc. This one is a little different. Characteristic of a heap allows that. Allows this implementation what characteristic of a heap allows an array based implementation.
[exam discussion] [social announcement] So, give me a one word description of that thing. It's a heap, that's right. A two-word description of the abstract data type we're considering using a heap for. A priority queue, very good. So, this structure right here is our latest, greatest attempt at a clever implementation for a priority queue. OKay? What implementations did we try before? What are we trying to improve over? Do you remember from last time? We first implemented a priority queue with...? A bag. Yeah, the bag didn't work out so well. What was the implementation? A linked list, sorted or unsorted? Either, we tried both, the other linear structure we tried as an array, sorted and unsorted and those all, you know they had things we liked about them, they also had things we didn't like about them. Alright, so that's all of last lecture in a nutshell, right there. Alright, so this thing is a heap, how do we implement it? What's the implementation of a heap? What structures did we use to implement a heap? An array. So that's a piece that at first glance is a little counter-intuitive. Because this thing is a binary tree, right? And all the binary trees we've talked about so far have had tree node pointers and have been recursively traversed, etc., and this one is a little bit different. What characteristic of a heap allows an array-based implementation?
What characteristic of a heap allows an array-based implementation? You've got it, yeah? That's right it is a complete tree. Now, what that means in fuzzy land is -you know- this tree has no gaps in it. It is like we took all our data and laid it out in level order until we ran out of data. Right? Okay, so it is the complete nature of this tree. Alright then finally, what is the characteristic ordering of a heap? How do you know when you look at this, that this thing is a heap? Yeah? Increasing, what's increasing? That's a key word, what's increasing? Uh, kind of. Yeah? Every path from... root to leaf. That's right. Every path from root to any leaf is an increasing path. Alright, so I am going to wave my magic wand here. For every observation we have made about these min heaps, we can make a parallel observations about max heaps. Alright, so there are parallel explanations for max heaps. And you may see them if you are doing online studying for things. Some people -almost no instructors will use both min and max heaps, but some instructors will use max heaps instead of min heaps. Okay, lets see. So, last time we talked about an algorithm for removing from such a structure, but we never wrote the code to do that. Alright, where's the minimum in the heap? Where's the minimum in the heap? At the root, that's right. It is always at the top. So, if one our functions in our abstract data type is remove min. All we have to do is grab that node from the top. Easy-peezy right? But the problem is, if we actually move it, we break the heap. So, our algorithm was tot take this last value, because it doesn't ruin the completeness of our tree to do so. Take that last value and swap its key up into the spot previously occupied with the minimum. Now, do you like that? Okay, you like it, but only partially like it, right? Cause in a way, it breaks the heap property of the tree. Yes, you see that? So do you remember how to fix it? Yeah, heapifyDown, that's right. So this notion of heapifying the tree is one of restoring this path ordering characteristic. So we are going to the heapify that 11 down. Should I swap a 5 or 6? I should swap with 5 because it is safe to put 5 above 6, but not safe to put six above five. So I am going to always swap with the minimum child. Alright, so 5 comes up 11 comes down. Swap with the minimum child. It is always safe to do so. 9 comes up 11 goes down, and then, 11 is smaller than either of its children, so we're done. Okay, any questions about that? Is it good? Okay, let's right some code, or at least look at some code. I can't remember how much is here.
what characteristic of a heap allows an array based implementation, got it? yeah. [student answer]. That's right it's a complete tree. now what that means in fuzzy land is you know this tree has no gaps in it, it's like we took all our data and laid it out in level order until we ran out of data", right? ok, so it's the complete nature of this tree. alright. and then finally, what is the characteristic ordering of a heap. how do you know, when you look at this, that this thing is a heap? do you know? increasing, what's increasing? that's a key word, what's increasing? kind of, yeah. every path from... root to leaf. that's right. every path from root to any leaf is an increasing path. alright, so i'm going to wave my magic wand here and uh... For every observation we've made about these mean heaps we can make a parallel observation about a max heap but i;m never gonna talk about max heaps, oh wait. alright, so, there are parallel explanations for max heaps and you may see them. you may see them in. um... if your doing online studying for things. some people, some instr... almost no instructors will use both min and max heaps, uh.. but some instructors will use max heaps instead of min heaps. okay! let's see. so. last time we talked about an algorithm for removing the minimum from such a structure but we never wrote the code to do that. alright, so, where's the minimum in the head? where's the minimum in the head? at the root, that's right. it's always at the top. so if one of our function in our abstract data type is remove min, that means all we have to do is grab that node from the top? easy peasy, right? but the problem is, if we actually remove it, we break the heap. ok. so our algorithm was to take this last value because it doesn't ruin the completeness of our tree to do so. take that last value and swap it's key up into the spot previously occupied by the minimum. okay. now do you like that? okay, you like it, but only partially like it, right? cause in a way it breaks the heap property of the tree, yes, you see that? so do you remember how to fix it? yeah. heapify down, that's right. so this notion of heapifying the try is one of restoring this path ordering characteristic. so we're going to heapify that' eleven down. should i swap a five or six? i should swap with five because it is save to put five above six but not safe to put six above five. so i'm going to always swap with the minimum child. alright, so five comes up, eleven comes down. swap with the minimum child, it's always safe to do, so nine comes up, eleven goes down and then eleven is smaller then either of it's children so we're done. ok. any questions about that? was it good? okay, let's write some code, or at least look at some code. I can't remember how much is here. ok.
So, our keys are type T here, and we are basically going to grab the root of the tree for returning. So, this is the value that we are going to return. Then, we are going to replace that value at the root with the last value. In this case, that was 4 replaced by 11. Then, we are going to decrement the size effectively removing the last element from the tree, but we have kept it, so we didn't remove it, we just removed something. And then, heapifyDown from the root, and then return that minimum value. Any question about that? Is it okay? Alright, so now lets do heapifyDown from an index. Now, keep in mind that that index is the location of the key. So we are always going to be comparing our array at location index to get the key values. So if cIndex has a child, what is has- oh- I'll ask that in a minute. For a minute, just assume that hasaChild just works. It will tell you true or false based on whether or not cIndex is a leaf. I could of put isALeaf there. If not isALeaf(cIndex), that would of been fine. It is just the opposite. Alright then, I am going to grab the index of the minimum child. Okay, so I am going to make this function deal with finding the minimum child. And we'll talk about why I did that in just a minute. And then if the location is okay- which way does this go? Which way does this go? If the thing we are heapifyingDown is... what inequality goes here? Greater than the minimum child than we should shove it down. Right? Good. Yes, if items[cIndex] is greater than the minimum child, then we should swap the values. So we should swap items[cIndex] with items[minChild]. Yeah, what? Alright, indexMin items[minChildIndex]. Ahh! Swap those two, and then heapifyDown on minChildIndex. Okay, does this seem okay? Okay, we used two helper functions to make this code look beautiful. Beautiful code at all costs and I am not actually going to expand this, but I am going to know what that code looks like. How am I going to check if cIndex has a child? Yes, Ian? Excellent, that's excellent. What is 2 times the current index? It is where the left child would be if it existed. So if that value is greater than the total number that we have, greater than size, there is no left child. And that is all that code is, so this is 2 times cIndex I should be able to spell that- greater than size. Or you could say- no you shouldn't say left child. You should say 2 times cIndex greater than size. Yeah?
yes. exactly, exactly. yeah, remember that this is a one based array, right, like that, starting the root at one gained us the efficiency of being able to use two cIndex, two times the index as our last child. that's in last lecture. ok. alright any other questions about... OH! I know. So. this min child. actually when i wrote this code. i think i remember spending the very most time debugging this part of the code. and the reason for that is because... notice that i don't deal with the case, at all, that it has only one child. right, i don't deal with that. that one strange incident. one strange case in a complete tree where there actually aren't even two children. i don't deal with that here, at all. i only deal with it in this function. so this function, minChild, actually hides this test to see if there are even are two children, and in either case, if there are only one child it returns it, if there are two it returns the minimum of the two. ok. alright and because of that little ugliness, i shoved it into the helper function. alright, any other questions about this code? what questions do you think i'm going to ask you? i've just shown you some code, what do you think, i'm going to ask you? exactly every good. what the running time of this, we've got the running time, we completely understand how it works. whats the running time of this thing? of removing something from a heap? logn, log n, and please justify that. the running time is big o of logn, O(Logn), because, that is the height of a complete tree. it happens to also be a lower bond. ok, any questions about that? ok. so, i love this discussion because, um, oops, wow. I love this discussion because our original goal here was to implement priority queue. our goal was to implement priority queues with the assumption that that abstract data type would some how be useful to us. ok. and we proposed a whole bunch of implementation. and this last one, that we'll actually compare more carefully to the other ones, a little bit later. this last one is a structure that is beautiful in it's own right called a heap. but a heap really has, you know we a discussion about implementing this implementation, right. and in the end the, uh, the heap was... the discussion about the heap was well should we implement is using pointer or as an array." and we decided it should be clever use of an array. and this notion that an abstract data type can actually lead to this sort of unfolding discussion of implementation in incre... decreasing abstraction more specificity is fascination to me. more over, there are tons of structures and algorithms for which priority queues are an extremely important, um, element. so for example the event queue in every single video game that ever exists. so this an event queue. uses a priority queue. it which one need to come next. it's the. it is prioritized by time. even if all the events were created at the same time it can be thrown into a priority queue so that the next one with respect to time could be handled. um. another application. i'll bet you won't be surprise that original systems that allocated memory, dynamic memory, used a priority queue, right. implemented as a heap, yes. i don't know if they put the priority queue level. but that, i bet they did. so memory allocation... where in this instance. the size of the block of memory to be used typically was, in very early implementation, when they were just doing things, um, sort of in an add... without a lot of resources. when they were just developing these algorithms. that memory allocation was based on how much memory a block of memory had. that size of the block. oh my gosh, english, speak english. ok, so the priority was the size the block there of memory. ok, another one is, oh your to do list. right. what key do you use for your todo list?
Due date, so you do next due next, the thing that is due next gets your attention. It's some strange weighted average, right? Of due next, worth most, you know. Oh, this, it's, like most, the one that makes you happiest. Oh that'll be us, you know. Um. Uh, alright. So, you know, this is this function that determines the keys, the ordering in the priority queue can be lots of different things. Also, when we talk about graph algorithms, we'll be using a priority queue to order the uh to order the uh to order the order. To plan the order in which we visit edges of a graph. So this is uh graph search. Graph algorithms in general tend to have a lot of priority queues. And that's foreshadowing. That's, where are we going with this? Why did we talk about it at all? Alright, any questions about that? So I love this. I love that it's a rich conversation that has many different levels. And yet, somehow inherently safe because it's just computer science, not it's not like philosophy. Alright, okay, so is that thing a heap? Is it? If I'm keying on the characters, the alphabetic order of the characters. No. What's your evidence? B U oh the U is greater than L and D, right? Okay. Alright, so I believe it. That that one is not a heap. Now what I want to know is what would be an algorithm for making that into a heap? What could you do? I'm giving you the data. You can assume basically that your data is laid out in array. Here's an array with all your data. Make it into a heap. What are you going to do? Yeah? Oh, why not sort it, right? You can use mergesort. Perfectly fine, perfectly reasonable idea. But we can do better. What is it mean to do better? What's the running time for mergesort? Big o of woah. Okay, you guys gotta write this down and put it on your mirror, okay? This can even if you don't know the proof of this, it should just roll right off. You can, you can be talking about stuff you don't know, but this one should just roll off. The running time of merge watch me get it wrong here the running time of mergesort worst case is nlog(n). So you're guaranteed nlog(n) for mergesort. It's not a great sort because it's very hard to do in place, especially if you're doing it in an array. But you actually did it in place in for mp3, I think, but your memory was all over the place. Alright, uh let's see. So, okay, so we could sort it, that would work. What else could we do? Yeah? Oh use heapify. How would you use heapify? What would you do? What is, what what how would you use heapify here? How would you use heapify? Oh, heapify down through the it turns out that doesn't work. Okay? Yeah? Very good, very good. So the other thing you can do is pretend like, pretend like this is just data that happens to be sitting in memory and do repeated insertion into the structure. So first we've got, an empty heap. And we're going to add B to it. Okay? Well, there. We did heapify up from here. Fine. Done. Then we're going to add U to it. And now we can look at this part and say okay that's a good heap. Then we can add I to it. And that's a heap. And then we add L to it, and what happens? No it's fine, this is fine. You have to swap, right, but you're inserting. So you get heapify up for free. So L and U should swap. Okay. And now that's a heap. And now everything up to here is a heap. Okay, so do you see how this would play out in the end? One at a time, you're just going to add each one of these. It's like uh you know however many vertices there are here, inserts into the structure. Okay, do you like that?
Due date so do you next, do next, the thing that is do next gets your attention. It's some strange weighted average, right? Of do next, worth most, you know. It's like most the one that makes you happiest, right? Well that'll be us, you know? Alright, so, this function that determines the keys in the ordering in the priority queue can be lots of different things. Also, when we talk about graph algorithms, we'll be using a priority queue to order the order to plan the order in which we visit edges of a graph. So this is graph search. Graph algorithms in general tend to have a lot of priority queues and that's foreshadowing. That's where are we going with this? Why did we talk about it at all? Alright, so any questions about that? I love this. I love that it's a rich conversation that has many different levels and yet somehow inherently safe because it's just computer science and not, like, philosophy. Alright, okay, so is that thing a heap? Is it? If I'm keying on the characters, the alphabetic order of the characters. No, and what's your evidence? The U is greater than L and D, right? Okay, alright, so I believe it. That that one is not a heap. Now what I wanna know is what would be an algorithm for making that into a heap? What could you do? I'm giving you the data, you can assume basically that your data is laid out in an array. Here is an array with all your data, make it into a heap. What are you gonna do? Yeah? Oh, why not sort it, right? You can use mergeSort perfectly fine, perfectly reasonable idea. But we can do better. What does it mean to do better? What's the running time for merge sort? Big O of? Whoa, okay, you guys gotta write this down and put it on your mirror, okay? Even if you don't know the proof of this, it should just roll right off. You can be talking about stuff you don't know but this one should roll off, okay? The running time of merge, watch me get it wrong here, the running of mergeSort, worst case, is nLogn. Okay? So you're guaranteed nLogn for mergeSort. It's a great sort because it's very hard to do in lace, especially if you're doing it in an array. You actually did it in place for MP3 I think, but your memory was all over the place. Alright, let's see. So, we can sort it, that would work. What else could we do? Yeah? Oh, use heapify! How would you use heapify? What would you do? What is, how would you use heapify here? How would you use heapify? Oh heapifyDown at the root? It turns out that doesn't work. Yeah? Very good, very good. So the other thing you can do is pretend like this is just data that happens to be sitting in memory and do repeated insertion into the structure. So first we've got an empty heap, and we're gonna add B to it. Okay? Well, there we did heapifyUp from here, fine, done. Then we're gonna add U to it and now we can look at this part and say okay that's a good heap. Then we can add I to it and that's a heap. And then we add L to it and what happens? No, it's fine, this is fine. You have to swap, right? But you're inserting so you get heapifyUp for free so L and U should swap, okay. And now that's a heap. Now everything up to here is heap. Okay, so do you see how this would play out in the end? One at a time, you're just gonna add each one of these. It's like however many vertices there are here inserts into the structure. Okay, do you like that?
Yeah, Nathan what are you thinking? It is also n log n, good observation. Yeah this is n log n. Now let's talk about why, okay? Let's talk about why. This you're affectedly calling heapify up, yes? And you're going to call it on every single piece of data, okay? Look at all of these leaves down here for they're going have to make a trip. Potentially, all the way up the tree right? Each one of these, so that's a lot. This is like effetely have data, could be have a data. And they're going to go all the way up the tree. So that is, big O of n log n because it's n/2 things or big O of n things each of which go log n of the tree okay? Alright that's not satisfy, so why are we having this conversation if the best you can do is n log n? okay, so......it isn't the best you can do. what is better? what's better than n log n? Big O of n that's right. What are we going for is the ability to take a an array of data like this and create a heap out of it in linear time. Alright, so, I have a way of uh.. kind of giving you a hint about this. Uh, I need a volunteer. Any volunteer to come to the front of the room? This make this thing up on a Friday. Hurry up, now, yes you know you want to do it. Raise your hand if you want to do it you are kind of afraid to. Raise your hand if you're afraid to raise your hand that you're afraid. Okay, you're up. Okay, and what I want you to do is point not to, well, you can choose whether point to the n-tree in the array or a vertex in the heap that is already a heap. It's already a heap. A root of some subtree which is already a heap. D, okay, that's lucky. Alright, D is already a heap right? Okay, fine uh point to another one. That's already a heap. okay good H is already a heap. Point to another one. This is a lot of pressure isn't it? I will giving you hint, there aren't any more higher up the tree. Okay, very good, no no no, higher up of the tree. You're not done! There are no more higher up of the tree. Oh! look those, all of those are already heaps. Okay good, thank you. Oh yes, they're already heaps. Do you see that? Yes, thank you very much for doing that. Do you see they're already heaps? And they're guarantee to be heaps right? Where as D is just lucky and H is just lucky. So the leaves are already heaps. Okay? Alright, so stop me when I running to a node that is no longer heap. You're heap, you're heap, you're heap,you're heap you're heap, this one is already a heap right? These are already heaps, yeah? How about L? Is L already....thank you. How can I fix it? How can I make it so that this node this vertex right here might hold different key, but it is the root of something that is already a heap. Do heapify......down. Let's right, heapify down on L. Okay? Heapify down on L. What happens? A comes up. Okay fine, then we have to do it here heapify down on I. Then we have to do it here heapify down on U. And then eventually heapify down on B. Okay? Any question about that? Is this n log n? Feels like it could be right? Feels like it could be because B is trip to the bottom could go all the way down, B could go all the way, this could've been a Z sitting here right? B could go all the way down to the bottom. The difference in this case is, only one vertex that has to go all the way to the bottom, instead of all the leaves have to come up in the other instance. So, let's see if this actually does our linear running time. Before we do that, here are the three things, here are the three alternative. That was going to planing on my part, there is answers on the other side. Okay, sort the array big O of n log n okay. Sort the array, and then you can argue. uh oh, No, don't say the class is over. No.....no no no. It's not that much Friday.
And nathan what are you thinking? It is also n log n, yea this is nlog n, Lets talk about why. You're effectively calling heapify up and you are going to call it on every single piece of data. Look at all of these leaves down here that are going to have to make a trip all the way up the tree, right? But this is what you successfully have the data and they are going to go all the way up the tree. So that is, you go up log(n) cause this is n over two things or big oh of n things each of which goes log(n) up the tree. Alright so that is not satisfying so why are we having this if the best we can do is nlog(n)? Okay, So It is the best we can do, what is better? What's better than nlogn what we are going for is the ability to take an array of data like this and create a heap out of this in linear time. So i have a way of giving you a hint about this. I need a volunteer. I need a volunteer to come to the front of the room. Oh this is good on a Friday, hurry up, now you know you want to do it. You are just kind of afraid to. Raise your hand if you are afraid to raise your hand because you are afraid. Okay you are up. Okay. Now what I want you to do is point not to well you can choose what you point to between entry in the array or a vertex in the heap that is already a heap. It is already a heap, so the root of a sub tree that is already a heap. Okay that is what good alright, so d is already a heap right, okay fine. Put another one. That's already a heap. Okay good h is already a heap, so point to another one. This is a lot of pressure isn't, Ill give you a hit there are more higher up in the tree. Okay, Very good no no. Higher up in the tree. There are no more higher up in the tree. All of those are already heaps okay good, thank you. Yeah they are already heaps. Can you see that? yeah thank you very much. Can you see that they are already heaps? And they are very cheap heaps. Right? You know with H are just blocks. The leaves are already heaps. So that means when I run into a node that is no longer a heap. This one is already a heap, Already a heap. How about L, is L already a heap? Thank you. How can I fix this? How can make it so that this node this vertex right here, might hold a different key, but it is the root of something that is already a heap. Heapify Down that's right. Heapify Down on L. Okay? Heapify Down on L. A comes up, right? Okay fine, then we have to do it here, heapify down on I. Then we have to do it here, heapify down on U then on V. Okay? Any question about that? Is this nlog(n)? Feels like it could be right? It feels it could be because V's trip to the bottom is going to to go all the way down. This could go all the way down to the bottom. The difference in this case is only vertex that has to go all the way to the bottom. Instead of all of the leaves coming up in the other instance. Okay? So let's see if this actually gets us linear running time. Okay? Before we do that here are the three things. Here are the three alternatives. That is good planning on my part. Have the answers on the other side. Okay, sort the array big oh of nlog(n). Sort the array, then you can argue. Uh oh. No don't you cross over. Huuuh. Nooooooooo. Noooooo nooo nooo. It's not that kind of Friday.
haha just a minute alright
2 to the h plus one. I can do this really fast. 2-h uh. Alright, any questions about it? It's like the easiest time to [gibberish]. Somebody magically gave you the answers. Okay? Alright, but we don't want this thing in terms of h we want it in terms of n. So what we know is that umm that height is big oh of log(n). Or n is greater than or equal to two to the n. I can do this. So h equals. What's the exact expression for h. h is at least [gibberish]. I'm going to do it like this. Ill figure out the inequalities in a minute. So I know s(h) so it is the sum of the pathways is equal to 2 to the h plus one. minus 2 minus h. But I also know that h is at most some constant time log(n) and so this thing is at most 2 to the constant time log(n) plus 1 minus 2 minus constant time for log(n) yeah. Okay which is we do all of this math big oh of n. The only salient piece is this first term. Only salient piece is this first term. Oh the big C matters in this case. I'm going to figure this out. I am. I think I have to do that. Alright. Only one more little thing. So. Here is what I want to do. I made a heap and now I want to use that heap so that the data can be skimmed in a particular order. I started off data in no particular order. And [gibberish] and then I built a heap out of it. Now I want to view this heap to sort of finish the sorting of the the sorting of original data that was in no particular order. How would I do that? How might I do that. How would I sort this thing. What could I do? How do I get this data from that. I mean yes. I think the biggest hint I have is selection sort if you remember correctly remember selection sort? Without a heap how can I create. I can make another array if I want to. How can I make a sorted array if I got a heap?
It's two to the h plus one. I can do this really fast. Minus one. Minus eight. Alright. Any question about it? It is the easiest the indeption you need to do. It is easy recurrsion. Somebody magically gave you the answer. Just to prove it is true. But, we don't want this thing in turns of h, we want this thing in turns of n. So what we know is that the height is O(log(n)). So I know the s of h which is the sum of the path length is equal to two to the h+1-2-h, but I also know that h is at most some constant times log(n) there. So this thing is at most two to the c*log(n)+1 minus one minus c*log(n). If you do all the math O(n), the only failure piece is this first term. Here is what I wanted to do. I made a heap and now I want to use that heap. So I started of with data that was in no particular order. I started of with data that was in no particular order. And then I build up a heap out of it. I want to use that heap to finishing sorting of that data that was in no particular order from which I built a heap. How may I do that? I wanna sort using this thing. How do I get sorted data from the heap. I think the biggest hint I have is selection sort if you remember selection sort. How can I make a sorted array if I got a heap?
you guys are thinking way too hard. the heap past to function has insert and removed min. Remove min... etc.. until you are down. Remove the minimum, remove the next minimum, remove the next minimum. So, this is the sorting algorithm. I'm gonna talk about the benefit in just a minute. So the first thing you wanna do is with your data that came in unsorted. So this is given and unsorted array. First thing you wanna do is build the heap. Okay. Now. If I remove the minimum, if I remove A what am I gonna do with it where am I gonna put it? In front of some other array. Build it up. Now it will be fine. I don't wanna use the space so where is the room for A? If I remove A, if I pull A off, first thing I'm gonna do is get rid of w so I can use it to plug in for whole, So guess what. I have room for A so I'm gonna put it here. So do that again, remove it. Then B's gonna be here eventually then remove the minimum. We have room and B's gonna be here. This is a do a repeated remove min, keeping values in the structure. And then the last thing is you wanna reverse the order of your array if you want it to be an increasing order. What's the running time of each of the step? Running time of step 1 is big o of n. We just showed it. We almost showed it. Repeated remove min. Darn it. This is not better than n log n. And then to reverse the array is big o of n. The whole running time is big o nlogn. We don't need another one because this one is in place sort with worst case nlogn, whereas quicksort dosen't give you worst case nlogn. I have one last thing before you go because it's fun. Why did I choose this picture for our closing thought? it's a fun a picture but why is it for today? When you are together with your friend and you decided to make a human pyramid. Who goes on top? The lightest person. So this is like a physical representation of heap. We will talk about it next time.
are thinking way too hard. The heap has two functions: it has insert and it has removemin. yeah? yeah, removemin. removemin. removemin, etc. until you're done. remove the minimum, remove the next minimum, remove the next minimum. alright! this is a sorting algorithm. so, the and I'm gonna talk about the benefits the running time the benefits in just a minute. um, so the first thing is to... the first thing you wanna do with your data that came in unsorted so this is given an unsorted array first thing you wanna do is build a heap. mkay. now, if I remove the minimum, if I remove A, what am I gonna do with it? Where should I put it? in the front of some other array, right? build it up, that'll be fine. but you know what? I don't wanna use this space? so where is there room for A? yeah, look! if I remove A, if I pull A off, first thing I'm gonna do is swap up W, right? I'm gonna get rid of W so I can use it for plugging the hole. so guess what? I have room for A. so I'm gonna go ahead and put it here. okay? and then do that again, remove then B is gonna be here eventually, then remove the minimum. we have room and so B is gonna be here. okay? so this is do a repeated removemin... uh, keeping values in the structure.and then the last thing is you might want to reverse the order of the array if, if you wanted it to be an increasing order. so you might want to reverse if you depending on what sorted order you want. okay, and what's the running time of each of those steps? running time step one is O(n), we just showed it. we just well, haha, almost showed it. repeated removemin, darn it. this one isn't better than nlogn. this one is, you know, you may have to lots of data may have to go pretty far. and then to reverse the array is again O(n). so the whole running time is O(nlogn). and the answer to why did we need another is that this one is an in-place sort. with worst case nlogn, whereas quicksort doesn't get you uh worst-case nlogn. okay, it does it in place, but not worst-case nlogn. okay, alright, I have one last thing before you go 'cause it's fun. we'll uh why did I choose this picture for our closing thought? it's a fun picture, right. but why is it the picture for today? when you're together with your friends, not at the semi-formal, and you decide to make and you decide to make a human pyramid, who goes on top? the lightest person, right? who's on the next layer? the next-lightest. so this is like a physical manifestation of a heap. there you go, it's not quite right though, we'll talk about it next time. alright, bye. what's up? I decrement size, but I'm not freeing the memory, so um what I'm doing by decrementing size is kind of moving that wall over. so that I don't in fact that, that, that means that space is available to me. yeah. yup. has a child, it has this code. oh, it has that, oh yeah, you're right, you're totally right. it's less than or equal to, right? yeah. yeah, oh, is it, okay. yes, there. okay. uh huh. about what? oh yeah. yeah. it's like. okay. so I can say less than or equal to. logn. okay, excellent, okay. thank you. that was exactly what I was gonna untangle.
Ok. So lets start. I'm waiting for a. Well, I'll tell you configuring update for win 10. 96% complete do not turn off your computer. I have high hopes. There is a second to go with 70% complete. Alright. I have new update on the exam. Thank you. But I do have quadruplet battery. Do you know quadruplet battery exist? I don't know. And there are like tiny. Thank you. Let's see. Updating windows. 0% percent. Your pc will restart several times. Ok you have handouts. We are gonna do this. We can do this. This is ok. MP6 is due tomorrow night. Let's see. Grading has been happening. So you should get some feedback on how it's going generally or have available to you some feedback on how it's going generally. Alright, so. Oh Mattox Thank you very much. And the question is can I do anything about my machine? Oh good. Eight. Alright. So there's a picture on slide one. And there are some blanks following it. I want you to get into the zone and figure out what that at the bottom is intend to say, so this is the fill in the blanks exercise at the bottom of the first slide. Raise your hand if you make a human pyramid this weekend. Just to see. Oh no. Nobody. Gosh. Just to see what is was like. If you don't know what the heck I'm getting at here. Please to feel free to wander around looking for somebody who has a clue what I'm getting at with that particular picture using that particular context. Sixteen. Raise your hand if you have written a word in some blank. Ok. Ten percent. Way to go. Come on guys. You can do this. What word goes there? Very good. Will you say that first word into the mic? Heap. There you go. Thank you. Excuse me while I change the battery in my pen. Did you replace battery in your pen? I was gonna give you my another one do you want it? Alright. How's it going? You should be approximately one forth of the way through your dots cause that's how far it's to your blank. Cause that's how far I'm through my updates. I'm making you nervous. It's my job to make you nervous. What abstract data type have we been working on? Priority queue. That's correct. Very good. That's the thought too. Ye Barbecue that right. Anybody has questions about it? What are the two main functions of a priority queue? First one is. Insert is correct cause we have to be able to get some data into it. And of course if you have insert, you'll have remove right? RemoveMin is correct or removeMax.
okay um
Alright fine, what are the running times of those functions? Oh, they are Big O of n, but you can say something tighter. You can say something faster. So remember, Big O of something is like less then or equal to, and so yes, you could say that they're Big O of 2^n too. The question is what's the very least thing you can say, what's the very tightest thing you can say, log(n) is correct, that's right, we showed, we argued that these things run in time log(n) because the height of the tree is log(n) and the navigation for the code is the height of the tree. OK, fine, this structure can be built in time, how long does it take to build a heap out of previously unordered data, do you remember? This was all of last time's class, pretty much, or a huge portion of last times class meeting. Yes, linear time, so we can build a heap really really quickly. Big O of n is the next blank and that helps us do it's the first step in doing a sort, an in-place sort called heap sort, and the running time of that in-place heap sort is nlog(n). That's right. Good. So that's the summary of last time, anybody want to close the loop for me on why the picture reminds us of a heap? Yeah, if you build a human pyramid, you put the lightest person on top. That's right. And if they get removed, then you have somebody climb up to be, wait no, not that. Ok, let me see how were doing here, oh my gosh, oh it's going to be a long day, OK, so I'm actually flipping my page, if I were on, if I actually had my laptop, I would advance the slide, and so you're going to move to the slide that says remembering CS 173. DUN! DUN! DUN! and the verbage says let r be an equivalence relation, raise your hand if your stomach turned just a little bit there. On the set of students in this room, OK, I say a couple hands go up over there. Hey, so we have an equivalence relation on us, except that I'm not a student, so on you, there's an equivalence relation where any pair of you are related to one another if you have the same favorite among this set. Now, before we actually talk about the equivalence relation itself, I want you to help me figure out what goes in the blank in that set. What goes in the blank in that set? So I, the set contains a,fb,tr,cc,pmc what's the last one? It depends what those other's are right? There might be an obvious one if you can figure what those others are. fb is not Facebook, though it might be I guess, no its not Facebook. Its not football either. First blood, did you say first blood? That's what we say when you guys are taking exams if somebody finishes their exam and leaves the room, we call it first blood. yeah. Is it cruel, I don't know, it's funny it's like a little incite, what are these things? what's cc, not carbon copy, what is cc? name something that's cc. Closed caption, not carbon copy, not closed caption, not nearly so boring, these are fun, come on! that's a big hint. What did you say? Captain crunch, so you think they're cereals, no. That would have been good though, next year I'll do that. What are they?
I'll give you a hint. the A used to be a B. oh. but I changed it to A for this year. and we're at 83 percent. yeah? what? oh, jeez. yeah. it's rather embarrassing actually. we'll talk about it later. okay. alright, what are these things? c'mon, we gotta get going. what's CC? you can get this. creep what? creepy commune, no. no. alright, fine. how about PMC? how about just MC? you know what? this tells me you work too hard. is that a clue? it's a clue. anybody have something for me, any guesses? master summaries, no. these are fun. oh it is? what? they're not beers, darn. next year. no, cause that's just a that's just like an old fart trying to be cool. like if I use a lot of beers in here, it's just I'm just trying to be cool, right? so no, this is way more fun than that. we got nothing? I'm not gonna tell you. I'm just not. alright, so just choose one, just choose choose one that you think might be your favorite. choose one you think might be your favorite. now, uh I wanna talk to you if you decide arbitrarily and I'm not telling you what you have chosen here. uh if you think your favorite might be uh denoted by A. okay? alright. so I have the two of you. guess what? since you both chose A, you are related to one another under this equivalence relation. okay? now uh that means that you are part of the same equivalence class, okay? so everybody who chose A relate raise your hands please. everybody who chooses A. just the two of you? I don't even believe it. okay, it's your grade for this class, how about that? alright, there you go. we're at 97 percent, thank god. yeah, about. alright. uh, okay, so they're related to one another. now, are you related to anybody else under this equivalence relation? oh, anyone else who has a different favorite. no, the answer is no. so nobody is related to anybody else who has a different favorite among the elements of this set. it's killing you, isn't it? I'm not telling you, I'm not. I'm not gonna tell you. oh. I need to be able to write. I don't know. companies? no. The machine is dead. it's dead. fine, oh. yeah but. we've updated your PC. all your files are exactly where you left them. I am so sorry, you guys. but I can't have them apparently. not Apple, full banana, there is ref uh. oh I removed a reference to fruit, though. yeah. I took one out that was that had the word fruit in it. it was FN. yeah. who said they're games? yeah. yeah, they're games. they're games. A is agario, duh. oh. I took out fruit ninja. 'cause it's old, right? so what's FB? what's TR? or temple run, right? okay, what's CC then? or candy crush or? cookie crunch. cookie crush. cook or candy crush wait. CC is like all of them or something. PMC? no. candy crush I think is what I intended. alright this is just we've got some feet newf let's start. oh yes, let's. I'm so sorry you guys. okay. alright. oh, I'm cortana, ask me anything. this is gonna be awesome.
I'll give you a hint, the A used to be a B. But I changed it to A for this year. And we're at 83%. Yeah? What? Oh. Geez. huh. Yeah. It's rather embarrasing actually. Okay. What are these things? We've got to get going. What's CC? You can get this! Creep what? Creepy Commune? No! No. Alright. fine. How about PMT? How about just MC? You know what? This tells me you work too hard! Is that a clue? It's a clue! Anyone have something for me? Any Guesses? Master of Ceremonies? No, these are fun! They're not beers! Darn! Next year! No, cuz that's just like an old fart just trying to be cool. Like if I use a lot of beers in here, I'm just trying to be cool. So no, this is way more fun than that! Ain't got nothing? I'm not going to tell you. I'm just not. Just choose one that might be your. Just choose one that you think might be your favorite. Okay now, I want to talk to you if you decide arbitrarily and I'm not telling you what you have chosen here. If you think your favorite might be denoted by A, okay? Okay, so I have the two of you. Since you both chose A, you are related to one another under this equivalence relation. Okay, now that means you are part of the same equivalence class. So everyone who chose A, raise your hands please. Everybody who chooses A. Just the two of you? I don't even believe it. Okay its your grade for this class. How about that? There you go! We're at 97%! Thank god! Yeah, about. Alright. Okay, so they're related to one another. Now, are you related to anybody else under this equivalence relation? Oh, anyone else who has a different favorite. No! The answer is no! So, nobody is related to anybody else who has a different favorite among the elements of this set. It's killing me isn't. I'm not telling you! I'm not!I need to be able to write. I don't know. My whole machine is dead! It's dead! Oh. Yeah but. We've updated your PC! All your files are exactly where you left them! I am so sorry you guys. But I can't have them apparently. Not apple, full banana. Uhhh. Oh I removed a reference to fruits though. Yeah. I took one out that had the word fruit in it. It was FN. Yeah. Who said they're games? yeah! They're games! A is Agar.io duh. ohhh! I took out fruit ninja cuz it's old right? So what's FB? What's TR? or? Temple Run! Okay, what's CC then? or? Candy Crush or? Cookie Crunch? Cookie Crush? or Candy Crush? Wait? CC is like all of them or something. PMC? Alright, this is just, we've got some. Lets! I'm so sorry you guys. Alright. Ohh! I'm Cortana! Ask me anything. This is going to be awesome.
I owe you twenty minutes of your life I'm so sorry. Alright, Aight sooo, (s,t) is O and my pen works. (s,t) is an set of element R so equivalent relations are just sets of pairs of things that are related to one another. If these two students have the same favorite among all of those so I used to do this. I used to do that and I'm thinking that that's still like, you know, is there anything that is better than plants verses zombies? I dont know, I don't know. So a couple of you one of your initials. a, m, and and who, what're your initials, AB? These two students told me that they shared an affinity for a agario. They didn't know that that's what they were doing, so what i want to point out to you at this point is that there are lots of different ways of representing an equivalent relation. One of them is the a set of pairs, where the set of pairs have a particular characteristics. And those characteristics are the pairs are reflexive, symmetric, and transitive. RIght? Remember all that? Okay, so now what I want you to do is raise your hand if A is your favorite among those video games, those handheld games. Okay, what are you initials? Also AB? Okay I'm going to make you the OAB, and know that he's related to everybody else in the set, right? no matter what, take somebody else? One more person for whom agario is the best ever? Ok, I'm going to make somebody up, this is our local ghost, and note that that person or that ghost, that entity will be related to everybody else in that set. Okay? Now, among these choices what, oh raise your hand if your favorite is flappy birds. Okay, there's a bunch of you right? How would you characterize if I drew that graph, that graph represented your collective relationships, how would you describe that graph? It is a complete graph, right? Can you see? A graph containing every possible edge, and tons of students, we could figure out how many as to there are, we don't have time for this. Okay? But that's the complete graph, and the key thing to observe is there is no edge that crosses over from one complete subgraph to the other. Such an edge doesn't exist. Alright, and moreover we could make a set of things corresponding to the temple run people, and the cookie clicker people, who don't want to admit people, and the pocket minecraft people, but oh, did I not say that yet? The p is confusing, if I just put mc it woulda been oky? Okay any question about that? Now, the fact that I, moreover, moreover if I say choose a favorite, choose a favorite from among that set, then I can rest assured that everybody in this room will be in one of the subsets. Yes? Right? because I'm going to insist. Do you like any of those game? laughs". Do you like any of those games? Who doesn't like any of those games? I insist that you choose one though. so I'm asking a question that I can be assured that everybody in this room, as begrudgingly as they may be, they would have an entry somewhere, a vertex, somewhere on this table. What I'd like to point out is that on this diagram here, on this roughly sketched out diagram is a collection of disjoint sets. Okay, representing
BLANK I owe you twenty minutes of your life, I am so sorry, alright so on my pen works, life is good s and t are elements of set R so equivalent relations are just a set of pairs of things are related to on another if these two students have the same favorite among all of those so I used to do this I used to do that and I am thinking that that's still like you know is there anything better than plants vs zombies I don't know so a couple of you, what are you initials AM, what are your initials? AB? OK These two students told me that they shared an affinity for a Garrio they didn't know that's what they were doing so I want to point out to you at this point is that there are lots of ways of representing equivalent relations one of them is via a set of pairs where the set of pairs have particular relations particular characteristics and those characteristics are the pairs are reflexive, symmetric and transitive remember all of that? so now. what I want you to do is to raise your hands if A is among your favorite video games what are your initials? also AB? So I will make you the other AB And note he is related to everybody else in the set no matter what somebody else, one more person for Garrio is the best ever? OK, I am gonna make somebody up This is out local ghost Note that person or that ghost that entity would be related to everybody else in that set among these choices raise your hands if your favorite is flappy birds ok, there are a bunch of you right? How would you characterize if I drew the graph that represented your collection of relationships how would you describe that graph it is a complete graph so it is a graph containing every possible edge and there are tons of students and we can figure out how many edges there are oh my, we don't have time for this but it's a complete graph and the key thing to observe is there is no edge that crosses over from one complete subgraph to the other so such an edge does not exist and more over we could make a set of things corresponding to Temple Run people and the Cookie Clicker people who don't want to admit it, pocket minecraft people didn't I not say that yet? It is the P confusing, if I just left MC it would have been ok? Any question about that? now and moreover if I say choose a favorite from among that set that I can rest assured that everybody in this room will be in one of these subsets, yes? because I am gonna insist? Do you like any of those games? Who doesn't like any of those games? I insist that you choose one though I am asking a question where I can be sure that everybody in this room as grudgingly as they may be would have an entry somewhere have a vertex somewhere on this table on this slide ok? Alright, any question about that? What I would like to point out is that the diagram here the roughly sketched nervous diagram is a collection of disjoint set, representing
the equivalence relation now every equivalence relation has a set of equivalence classes now the notation for math says that you take the square brackets you denote what relation what you are talking about and you throw between the square brackets some representative of the set. so for example if i am expressing if i want this equivalence relation to represent that set then i would throw the student into other ab the student into the square brackets and what we would understand that means the set of everybody that is related to oab under the equivalence relate. now what is the difference between that set and this one what's the difference between that set and this one what's the difference say nothing there is no difference those are the same set right and so it feels like it feels like by choosing this person i playing favorites a little bit right oh i prefer you over the ghost right but in fact the identifier that you happen to choose to represent the group is somewhat arbitrary. it could be any it could have been any of those students all we mean by a choice here is the collection of people who are related to this student any question about that it could be anybody it doesn't have to be any of these two it could be am or ab or anybody else who like agario any question about that and that's notation for math that is not i am not making that up that probably came from 173 okay. one more thing to point out is that really there is nothing in the mathematics that indicates the names of the games usually when we talk about equivalence relations we just use the identifiers that correspond to the domain of the relation that is we use the identifier of the students in this example. the games itself they don't appear in the math i put them here the equivalence relation would not change a bit if i erased all of these little helps at understanding and understanding diagram okay any question about that so really there isn't a lot of meaning necessary to equivalence relation except to say that these pretty much the same these are all pretty much the same etc.. that additional meaning is not part of the math is part of the application ohhh okay alright. one more thing okay, so we are going to create and abstract data type that will help us ahh maintaining an equivalence relation okay. we are going to define and maintain an equivalence relation across the members of some set so what that means for example is that i would be able to tell immediately given a student what their membership was across the collection of sets okay and in fact one key thing what we wanna be able to do is given two students tell immediately whether they are in the same set the same disjoint sub okay set any questions about that this is supposed to be just kind of reminding you about how these things work okay. and sort of setting us up for umm for actually working with that abstract data type okay so that is the intro let's do some examples oh i didn't change all of the sets i only got the first page alright, so R is the same equivalence relation but i have chosen about oh looks like about 10 students and i am drawing the picture a little more carefully i think so here is what i want to be able to do i want to be able to use to functions one is find and ah and one is union now if i say find 4 what are you going to do
The equivalence relation. Now, every equivalence relation has a set of equivalence classes; the notation for math says that you take these square brackets, denote which relation you're talking about, and you throw between the square brackets the representative of the set. So, for example, if I'm expressing this equivalence relation to represent that set, then I would throw the student into the square brackets and what we would understand is that that means that set of everybody that is related to OAB under the equivalence relation, okay? Now, what's the difference between that set and this one? There is no difference; as they are in the same set. It feels like choosing the person I'm playing favorites; but, in fact, the identifier that you happen to choose the group is somewhat arbitrary it could have been any one of those students. All we mean by a choice here is a collection of people who are related to this student, and it could be anybody. That's the notation for math; I'm not makin' that up. It probably came from CS173! Okay, one more thing to point out is that there is nothing in the mathematics that indicates the names of the games. Usually when we talk about equivalence relations, we just use the identifiers that correspond to the domain of the relation; that is, we use the identifiers of the students in this example. The games themselves don't appear in the math. I put this here the equivalence relation would not change if I erased all of these little helpers at understanding the diagram. There isn't a lot of meaning to an equivalence relation except to say that these are all pretty much the same, these are all pretty much the same, etc. That additional meaning is not part of the math it's part of the application. Okay, alright, one more thing. We will create an abstract data type(ADT) that will help us maintain an equivalence relation. Let's define and maintain an equivalence relation across the members of some set. So, what that means, for example, is that I would be able to tell immediately, given a student, what their membership was across the collection of sets. And in fact, one key thing that we're gonna wanna be able to do; given two students, is to tell immediately whether they are in the same disjoint subset. This is supposed to be just kind of reminding you about how these things work, and it sets us up for actually working with this abstract data type. Okay, that's the intro. Let's do some examples. R is the same equivalence relation, but I have chosen only about ten students. I'm drawing the picture a little more carefully here(I think). Here's what I want to be able to do: I want to be able to use two functions one is find(), and one is union(). If I say find(4), what will you do?
You want to go, there it is! Right? It's right there. I see it. What I really mean by find(4) in this context is, tell me what its equivalence class is. Tell me some representative of the set in which it resides. So this is very different than find from the past, right? In the past when we did find, we pointed right to it, or return its key. We're gonna do something different here. In this case, you are going to return, you're gonna return a representative from the set containing 0, 1, 4 and 8, and anyone of them is fine. Wow, what? Okay. Okay? Anyone of them is fine. Feels very ill defined at this moment. What must be true, I'll answer your question in just a minute. What must be true, is if two things are in the same set, they must return the same representative. So I don't care which one of these you use to represent this set. But I want to be sure of, is if two things are in the same set, it will tell you. You will get a true because the representative is the same. Okay, was there a question? Did you have a question? Yeah. I can return 4, yeah. Yeah, it does, doesn't it. But when when I do a find(8), then I can't return 8, okay? So sure I can return 4 but that means I am gonna know when I know where 8 is, then its representative is 4. Mike? Yes. Okay, so the question is what if you have a 12 and it belongs to the blue and green. It can not. 12 can not be an element in two different equivalence classes. Equivalence classes partition set. There is no intersection, the intersection between every pair of set are disjoint, are empty. Okay, is that clear? Alright, so good question, I am glad you ask it. But that can not be, okay? Alright, fine. Here is an example of typical use of this structure. If it's not the case that 7 and 2 are in the same set. If it's not, if 7 and 2 are in different sets, then take the union of the sets represented by the find(7), and the find(2). So take the union of these two sets. Alright, so find(7) is going to essentially give us some representative of that set. Find(2) is going to give us some representative of that set. They can not be the same because these are disjoint sets. And so we are going to, as a result, the then" is going to be to take the union of these things. Now we are going to assume that find, I am sorry, the union operates on representatives. So assume the union operates on reps. Representative. Any question about that. Alright, fine. Here is little bit of a more formal description of the abstract data type. Each set has a rep, so we are going to maintain a collection of disjoint sets. In this example here, we have three of them. We have three of them, obviously. Each set has some representative member, we are not gonna to try to prescribe who that is. We are gonna let that, just kind of flow out of the application somehow, the implementation somehow. And we need to be able to support the following functions. We are gonna need to make a set, from a particular key. So this is a key. We are going to need to be able to take the union of two things, where these things are representatives. Okay? Sometimes you don't have to, sometimes you can just. Well, we'll talk about that later. And then find will return a representative.
Just like we said before. Okay, so I thought about this for a minute and I came up with this idea for a data structure to support this abstract data type. I set up this example into an array where every array entry is an identifier for one of the elements in the set. Now that's perfectly reasonable to do because we could either make this an associative array or we could keep a map of each of these identifiers to a richer key type. So it's pretty reasonable, actually, to be able to say, Well, I'm gonna use the indices as indicators, as element identifiers." Okay? So the indices are element identifiers and now, take a look. 0, 1, and 4 have 0 as their data indicating that they all belong to 0's set. So in this case, 0 is the representative. Any question about that? Is it good? Okay, and you can see 2 and 7, oh look, and then 3, 5, and 6 perfectly fine. Alright, so what I want to know is from you what is the find algorithm? So I want to know a representative of the set containing 5. I wanna know a representative of the set containing 5. How fast can you give it to me? Some representative of the set containing 5. Okay, well, I've got it stored here, that's true, but 5 itself is, too, but then I can't be sure if I use those, then I can't be sure 3 and 5 have the same representative, right? So, if I ask for the find of 5, I'm going return 3. How long does that take? Constant time, that's right. So, I can, if I get things set up like this, then I can implement find in constant time, because the find of 5 will return 3. Any question about that? Yeah? Yep, these are the indices, I'm going to call them IDs, but they're just indices, and then these are the representative here. Reps. Okay? Any question about that? Now that seems to work pretty great, right? Now, how about if I take a union? Uh, I don't know, it doesn't really matter. We're going to take a union of those two. So this is going to be the union of the find of 1, and the find of 2. Because I want to take unions of representatives. Just clean to do it that way. Alright, how do I go that in this case? What's my algorithm going to be? Yeah? Yeah, so I'm going to change the representative of the sets to be the same. That's right, they all have to have the same representative. I don't care which one it is but they all have to have the same one. Okay, fine. What am I going to change it to? What do you think? Raise your hand if you think I should change the representative of all of them to 0. Okay, raise your hand if you think I should change the representative of all of them to 0. Of all the ones in the new set. Okay, doesn't matter, but, how am I going to find them to change them? What's the algorithm for doing this union? Yeah, look. I've got to go, Hey, should I change you?" "Should I change you?" "Should I change you? Yeah, I probably should. I don't have to change 3, right? Don't have to change this one. And I do have to change this one. I can't think of another way. I can't think of another way of knowing what elements are in a particular set without just actually going through and looking. Right? So the union in this case is big o of n. Groooaaannnn. That's a groan. Okay, so let's see if we can do better.
alright I love this alright so these structures are called up-trees and they are awesome! okay? The first diagram that is drawn here is a forest of up-trees one of each up-trees has a single node and by conventional we draw it pointing we draw this little arrow point up to indicate that is the root okay? now how do we implement this thing? we implement it by denoting it as a root as negative one in a little table or array okay? any question about that? so I know if you give me a table that looks like that then I know to draw this collections of up-trees now here's the thing we are going to use one up-tree per set so right now I've got four different sets each with one element each of which is the root of up-tree okay? alright so now this is not interesting it's more interesting if I take an union so the question is what happens if I take a union of zero and one, for example? here's what I'm going to do here's zero ok here's my up-tree that's zero here's my up-tree that's one I'm going to do this okay? I am going to take it and point it to this other element so in the picture I'm going to take it like this so zero points to one and in the table one is going to become zero's parent so this is the new representation of that okay? are you doing ok? now if I do a find on zero here's what's gonna happen I'm going to zero ok? who's your mama? it says oh! one it goes to one and then who's your mama? I have no mama I'm a root so one is returned ok? so Find(0) returns one after a walk up the tree ok? any questions about it? assure yourself if you do a find of zero and find of one you get the same thing by do find a zero I got one if I find a one yeah! alright so let's do another union because this is interesting this is new lets' do another union let's do union wanna say something? ok zero and two this is actually really one to do ok? so this is the point which I'm going to make it important to do a find of zero and the find of two because the only arrows that we are going to change is going to be the roots arrows ok? so we are going to start here we are going to start with this representation and effectively we have got a picture there we gonna to a find of zero to get one and a find of two to get two and we gonna to do this so zero is still going to point to one one is going to point two two is a root and three is a root ok? any questions about it? yea (student asking questions) yep they are roots right? they are roots of the top yes yep that's right but we have more than one now that picture is accurate as our last example ok? is it ok? alright yep? (students asking) zero points to one still see zero points to one? one now points to two and two is a root ok yea? (students asking) yes unions only happens at root unions only happens between things whose value is negative one ok? any question about that? yea? (students asking)
Alright, I love these. Alright, so these structures are called uptrees, and they're awesome, k? The first diagram that is drawn here is a forest of uptrees, OK? Each one, each tree there has a single node, and by convention we draw it pointing, we draw this little arrow pointed up to indicate that it's the root. Now how do we implement this thing? We implement by denoting it as a root as negative one in a little table or array. OK? Any question about that? So I know that if you give me a table that looks like that, then I know to draw this collection of up trees. Here's the thing, we are going to use one up tree per set. So right now, I've got 4 different sets, each with one element, each of which is the root of an uptree. So now, this is not interesting, it is more interesting if i take a union. So the question is if I take a union of zero and one, for example. Here's what I'm gonna do. Here's zero, k here's my uptree at 0, here's my uptree that's one, I'm going to do this. I'm going to take it and point it to this other element. So in the picture, i'm going to take it like this so zero points to one, and in the table one is going to become zero's parent. so this is the new representation of that. Ok ,you doing Ok? Now if I do a find on zero here's what gonna happen. I'm going to go to 0, k, whose your mama, it says, oh, one, it goes to one, says whose your mama? I have no mama, I am a root. And so one is returned. So a find of zero returns one after a walk up the tree. Any question about it? Assure yourself that if you do a find of zero and a find of one you get the same thing. If I do I find of zero I get a one, if i do a find of one, Yay! alright, so lets do another union, because this is interesting, this is new, lets do another union. Let's do union of.. wanna say something? OK, zero and two.This is actually a really good one to do. This is the point of which I'm going to make it important to do the find of zero and a find of two because the only arrows that were going to change are gong to be the root arrows. So I'm going to here, we're going to start with this representation and effectively we've got that picture up there, were gonna do a find of zero to get one and a find of two to get two and were gonna do this. So one is, zero is still going to point to to one, one is now going to two, two is a root and three is a root. Any question about it? Yeah? Yep! but they always are right? The roots are at the top. Yea. Yep. yep. but we have more then one, so that picture is now accurate as of that last example. Ok, is it OK? yeah? zero points to one still see zero point to one, one now points to two and two is a root. Yeah, yes. unions only happen at the roots. Unions only happen between things whose values are negative one. Any questions about that? yeah?
Yep....Yep... Alright. Any other questions about this? Do you wanna do another example? [Student asking a question] No, not necessarily, a great question. So the question is: do the values inside here, do these values represents the height? They happen to represent the height in this particular example. You can't count on that usually. Actually they don't quite represent the height. They are identifiers. So if these were students' names, these would be students' name except for this one, these would all be roots. So this says my parent is identifier one, 1's parent is a root. It has no parent. Does that help? So the N-trees are identifiers. [asking] No, there will be nothing to do. cause they are already in the same set. ...yes, that's right. Because you only can take a union of two different sets. You might end up creating a loop... I don't know. A union of a pair of things will still just be that. A union of two same things will still be that thing. Just like sets. OK. Any other examples you wanna to look at here before we go to a bigger one? OK, so let's clarify this and do it in a little bit larger context. We are going back to the games. But notice again there're no games. There's no indication of who likes which game. There's no angry birds appearing anywhere in the description. You have to keep that separate. If you're describing meaning to your sets, you have to keep that separate. In fact, when we use this structure which will happen in MP7 when we use this structure, there's actually no meaning to the sets. They're all sort of status. Alright, let's draw a diagram. I've created the structure in memory that denotes these sets. So this is what memory looks like. But I want to draw the up trees, the pictures of up trees that correspond to this memory. What does it look like in the array. So 0's parent is 4. 4's parent is nobody. So I've got 0, 4 done. 8's parent is 4. And 1's parent is 8. And I just started with that one because 0 came first. 2's parent is 5 and 5 is a root. So I'll go ahead and do that part next. And 9's parent is 5. 7 is a root. 3's parent is 6, which is a root. So now, what do I get back when I do a find of 4. If I do a find 4. You go to 4 and you walk up. But there's no place to walk, so what do you return? 4. Find of 8 returns... OK we go to 4, 4 is a root. So this returns 4. So this is true. Now this one gets interesting, how do we take the union. Well, first of all, how do we evaluate this, what's the find of 7? 7. What's the find of 2? 5. Are they the same? No. So we should take the union of those, which in this case is to take this 7 and point it to 5. Or this 7 is going to become 5. Yea? [asking] No, it doesn't point to 2.You always do the adjustment at the roots. So raise your hand if this surprises you a little bit. Cause this is an itinerary tree not a binary tree. Alright. Ahhhhhh
Yep, yep, Yes. Alright. Any other questions about this? Do you want to review another example? No, not necessarily. So the question is, do the values inside here. Do the values represent the height? They happen to represent the height in this particular example. Actually they don't quite represent the height. So if these were student names. Except for this one. These would be roots. This says my parent is identifer one. Identifier's one's parent is a root. It has no parent. So the entries are identifiers. Anything else about this? Yeah, let's do one. No, there would be nothing to do. Because they are already in the same set. Yep, Uhh, one two, yes. That's right. Because you only ever take the union of two different things. You might end up creating two different things. You might end up creating a loop, I don't know, ok? A union of a pair of things will still just be that thing. Just like sets. Just like the sets you've known since you were a third grader. Ok how are you doing? Any other examples here before we go to a bigger one? Ok, so let's clarify this and do it in a little bit larger of a context. We're going to the games. But notice, again. That there are no games. There is no indication of who likes which game. There is no angry birds appearing anywhere in the descriptions. If you re ascribing meaning to your sets, you have to keep that set separate. In fact when we use this structure which will happen in mp7. When we use this structure there is actually no meaning to the sets, there all just sort of a status. They keep track of a status. Ok, so let's draw a diagram. I have created the structure, in memory that denotes those sets. Ok, so this is what memory looks like. I want to draw the uptrees, the pictures of the uptrees that correspond to this memory, in what it looks like in the array. So zero's parent is? So zero's parent is? Four, ok. Four's parent is? Nobody, ok. So I've got zero done, I've got four done. Eight's parent is four. And one's parent is eight. And I just started with that one, because zero came first. That is the only reason. Two's parent is five and five is a root. Two's parent is five and five is a root. And nine's parent is five. Seven is a root by itself. Three's parent is six, which is a root. Ok? So now, what do I get back when I do a find of 4. If I do a find of 4, you go to 4 and you walk up, but there is no place to walk. So what do you return? 4, is correct. Find of 8, returns. Ok we go to 8, it goes to 4, 4 is a root, so this returns 4. So this is true. Now this one get's interesting. This one gets interesting. How do we take the union. First of all, how do we evaluate this? What's the find of 7? What's the find of 2? Five. Are they the same? So, we should take the union of those which in this case, which will take this seven and point it to five. So, this seven is going to become five. No, it doesn't point to two. You always do the adjustment at the root. Raise your hand if this surprised you a bit. Because this is a ternary three rather than a binary tree. Oh my gosh. Oh my gosh. Ugh. Ok.
my clock says it's time to start It's 12/9 Tuesday?
My clock says it's time to start. Is twelve nine, Tuesday? I think, I think this is what I meant there. I think I forgot to change them. Those are Tuesdays, right? OK. There we go. Alright. Yes? [student question] There is new on the exam, thank you for asking, [uhm]. Alright so [uhm]. You should be receiving your scores back in your svn our intet.. our plan was to create a folder in your repository mt2 and in it you will have the scanned copy of your exam, so you can see your work. [uhh] And a report that tells you how you did on each of the scantron and the hand graded [huh] portion of the test. Now [uhh..] Also simultaneously the rubric will be posted so you can go and look and see how the graders decided how many points you should achieve for each part. Now this is, none of this is what you want to hear, right? What is it that you want to hear? [student ask when?] Oh, when? It should be, it might be happening as we speak. He said, He said do you want me to push the button before lecture, I'm like [uhhh] I dont know how to make that decision. So he, I think he was going to send it out momentarily. [Uhm.] [student voice] Yeah. Ah regrades are going to be, very good question, so the regrades are going to be, we're leaving it up to the individual TAs to handle it but if it appears that they are going to tell you large windows of time that they're available and you can come talk to them with your exam in front of you, because they where all scanned so [uhm..] You can ask for regrades inside those windows. They're expecting to be able to take care of them that way rather than putting piles in my office. There's another key question you're not asking, Yeah? I know... I know.. [uhm] so the average on the exam for this exam typically goes up from the first exam. The average was 68.. The last average was 75 So uhm. So heres the heres the heres the parting line we do not curve, we do not curve individual assessments in this course OK. [huh.] But we are open to adjusting the grade cutoff at the end of the semester so in your, so in your [sidekey?] you should still imagine the ohhhh.. this exam, you know. If you aren't happy with your score, you should go ohhh I gotta keep working really hard [uhm] because there are sort of no automatic you know ohh don't worry about it's really 7 points higher im not doing that OK. But, but in the end you know I like to see lots of A's and so at that point we will change the, where we draw the line in the grading moment. OK. Any questions about that? I also toyed with the possibility of figuring out additional ways to do extra credit. But in my experience extra credit helps the students who most, who have extra time and the, the students who have extra time tend to be those who don't need the extra credit. So I'm torn on you know building in additional work to do. [uhm] I don't know I'm still thinking about that. So [uhh] I haven't looked at histograms on individual problems yet, so I don't know, you know, i don't know yet how they each look. I will do so just to make sure that's typically how I make sure that the scantrons are graded accurately. To look at histograms and see if they make sense. Alright any other questions about tests? [uhm] I think its not premature for me to talk about the final just a little bit. Here's how you should think about the final in this class [uhm]. It is a third midterm with a tree question, an interesting tree question and [uhmmm] probably a little bit of memory management on the multiple choice so its really like a third midterm the bulk of your studying should be on the material you that have not yet been tested over and [uhm] and then, you know, make sure, just kind of revisit some of the earlier material. Are there any questions? administrative questions? [uhm] yeah Arma? [student asks question and cinda listens]
Oh you want more final, you want more questions... more sample tests for the final. I'll see if I have any good ones laying around. You can keep pestering me about that.. if you want.. to like do it. Alright, here, questions, administrative issues. How do i determine the class curve at the end? I want lot's of A's. So yay we're all on the same page! So the class curve at the end, for the last few semesters I haven't had to do a curve, but um, it's okay it's a recalibrating semester. What i tend to do is look for gaps. What i do is look for the overall spread of scores and adjust but only in a direction benefits you, i would never make a line harder to, ill never make it harder to achieve a particular grade, so we only curve up instead of curving down, okay. Um, any other, does that answer your question. it's an art thats why i get paid the big bucks. alright, any other administrative questions? Labs do meet this week and the interesting thing is that the instructional labs close at 5 oclock on saturday for the holidays why yes they do! and every semester we remind ews the lab managers we remind them you know we have labs at 7 oclock on friday nights or certainly at 5 oclock and they go oh yea yeah we will take care of it and every semester the doors are locked. so you may have to bring a battering ram to get into your lab sections on friday night. alright, any other administrative questions before we move on. you are not getting exams back in your lab sections. did you say the words so we dont have to go to our own lab sections did you say those words? you never have to go to your own lab section. and there's no incentive to do so because we aren't handing them back in those sections. any other questions? alright lets roll here, lets play school. we were talking about oh look we are starting class at 11:08, we're on it today. so we were talking about a structure for maintaining a collection of disjoint sets. so in the illustration here, we have four disjoint sets, the cardinality of this set is 3, good, right i just wanted you to like to connect to the set, this one has one thing in it, this one has four, this one has two, now last time, we talked about implementing the functionality of the disjoint sets abstract data type that abstract data type has two functions anyone remember what they are. two key functions. there were three listed but one of them was just make a set so okay i'll give you that one, what were the other two key functions for disjoint sets abstract data type, union and find. wait i dont know where you were, okay, ADT disjoint sets has find and union. now, find you can think of as returning the set in which a particular key resides, but it does so by returning representative of that set and union is just like the union you learned about in third grade, it takes two sets and puts it altogether in one set. the representation that we ended up with, the implementation that we ended up with is something like this it's called uptrees, a picture of the uptrees that might represent these looks like this and the data the way it looks in memory corresponding to the uptrees looks like this. now, um, i didnt want to go over this because i didnt want you to fall asleep at 11:10 but i will tell you that i put an error in that construct so i want you take about 2 minutes and refresh your memory on how these things work and tell me where the error is there might be more than one error, find the error in the model versus the data.
Yes? Very good. So in the table, it's.. So remember that roots are indicated by negative numbers, okay? And in the table, 6 is supposed to be a root. Okay? And not 3. In the table it says 6 is 3's parent, okay, so that's the bug. That, that was my intentional bug. Anybody else find something, something different? Some other error? Okay, so notice that these are not ordered trees in any sense. So, it didn't matter where I drew the 2 and the 9 here relative to one another. There is no notion of a left child and a right child, or a middle child, or an early middle ch- there, you know. So this tree is not ordered, it's not necessarily binary, though this, uh, this examples happens to not have any non binary nodes. Uh, let's see. It is directed, though. That's the key part. Alright, any questions about it? Alright, let's take union just to remind ourselves how you take union, both in the context of the model and in the context of its representation in memory. So I want to take the union between these two sets and do something, and do something that makes all of these in the same tree. So how should I do that? I've got these two trees, what should I do? What should I do? Yeah? Yeah, make one of the roots point to the other. Now, should I do this or should I do this? Should I do this, this one? Okay, and now I have to like turn around. Oh, wait. Okay. So your opinion, I should do this? Okay. Um. Alright. You think 5 should point to 7. Okay, now, what I want you to get from that little exchange is that there was a choice to be made, and for now, we're going to make an arbitrary choice. Um, a principle, but arbitrary choice. And I'm just going to have the one on the left point to the one on the right. Okay. But you should recognize that it, sort of, you know, that was arbitrary. Okay. Finally, if I say something like the union of 2 with 7", what I really mean is the union of the set containing 2 with the set containing 7. So I need to call find() in order to get the appropriate representative of that set. Okay, any question about that? Alright. So, uh, and the reason I bring that up here is because when I talk about these functions and when we discuss running times of these functions, we want to find() to be decoupled from union(). When you implement these things in mp7, you're going to throw a find() inside, because you don't want to have to demand that the client do this every time. So, there'll be a slightly different specification for the union function in the mp than there is here. Okay, but I want to decouple them because I want to be able to talk about running times separately. Alright, any question about that? Okay. So let's write some code, yay. Alright, so.. The function find() is going to take a key or a element identifier, some kind of identifier, and it's going to return the root of the uptree. Returns the root of i's uptree as a representative. Okay. Now. Woah, look at this code. This is really cool. If, if the value in the array at i is less than zero, it means that i is a root, right? That's what we agreed on. In which case, we're going to return i. Otherwise, we're going to walk one step up the tree. Okay, so, we're going to find() on i's parent.
Very good! So, in the table, so remember that roots are indicated by negative numbers. And in the table 6 is supposed be a root, not 3. In the table it says 6 is 3's parent. So, that is my intentional bug. Anybody else find something different some other error? So notice that these are not ordered trees in any sense. So it didn't matter where I draw the 2 and 9 here relative to one and another. There is no notion of a left child and a right child or a middle child. So this tree is ordered, it is not necessarily binary though. This example happens to not to have any non binary nodes. It is direct, that is the key part. Let's take the union just to remind ourselves how to take union both in the context in the model and in the context of its representation in memory. So I want to take union between these two sets and do something that makes all of this in the same tree. So I got these 2 trees what should I do? Yeah, make one of the root point to the other. Now, should I do this or should I do this? OK you think 5 should point to 7. Now what I want you get from that little exchange is that there was a choice to be made. And for now I am gonna make a arbitrary choice. I am just gonna have the one on the left point to the one the right okay? but you should recognize that was arbitrary. OK finely, if I say something like the union of two with 7, what i really mean is the union of the set containing 2 with the set containing 7. So I need to call find in order to get the appropriate representative of that set. Ok any questions? All right so, and the reason that I bring it up here is because when I talk about these function and when we discuss running time of these fictions, we want to find to be decoupled from union. When you implement these things in mp7, you are gonna throw a find inside because you do not want to have to demand the client do this every time. So, there will be a slightly different specification for the union function in the mp than there is here. But I want to decouple them, because I want to be able to talk about running times separately. All right any question. So let's write some codes. Function find is going to take a key or a element identifier and it is going to return the root of the up tree, as a representative. Now, look at this code, it is really cool! If the value in the array at i is less than 0, it means i is a root, that is what we agreed on. In which case, we are gonna return i, otherwise, we are going to walk one step of the tree. Ok, so we are gonna find on i's parent.
any questions about that? okay, none? it's really quite in here. We should play music or something. Do you know who Laurence Angrave is? He's the instructor for 241. This morning he sat in my office and he wrote a parody of blank space for his students. I'm like you genius, that's the teacher of the year right there. Alright, uhhh, so whats the running time... how did that even come up? Blank space! Its a blank space! Thats where it came from. Yea, its blank space right there. What does the running time of this function depend on? Not the size of it. Kind of. Depends what you mean by size. It's the height, thats right. You're going to walk up the subtree, and so the number of steps, the number of effectively iterative calls to find depends on the height of the tree. In the worst case, I agree with you, you could just have the chain, kind of like the one on the right, there. I think you could come up with a way, a set of unions that come up with the worst case thing. This would be O(n). But thats not particularly interesting. What I want to know, is what is the very best tree look like. Whats an ideal tree? What do we wish these trees look like? A binary tree? No, we can do better. We can also do better than avl trees. These are not necessarily binary trees. We can have a root, lets say 4. It should be 13 if we're talking about Tayler Swift since thats her favorite number you know. I could do some real damage to my U of I freshman, right guys. Alright, so this is an ideal tree. I have her on my brain today, I should shake it off. Alright, lets take a union, okay. Lets take a union here. all we have to do, look it. We got the root of two trees. All we have to say is s[root], one of the roots has to have a parent who is equal to the other. Now, as I said, this is an arbitrary choice at this point. There is nothing wrong for me to write down there. I think what i did was always this. The first one points to the second. I think it is that I said, the parent of root 1 becomes root 2. Alright, whats the running time of this function? It's constant time. It's just an assignment. Its just a change of a value. So, what we want to do is aim towards this, because then our finds are fast. What we have now is a case where we can create, you know, given our current code, unfortunately, things can look like this. So lets get a little smarter. In that example, should i do? what would be smarter? should i do this or should i do this? Which one?
Any question about that? ok.. None? It's really quite here. We should play music or something. Do you know who Lawrence Angrave is? Do you know who he is? He is the instructor for 241. This morning, he sat in my office he wrote a herd of blank space for his students. I am like you're a genius." That's the teacher of the year right there. Alright! So what's the running time? Where did that come up? Blank space! It's a blank space. That was where it was That's where it came from. Yeah, that was a blank space right there. What's the running time of this function depend on? What's the running time depend on? Yeah? No! Not the size of it. Kind of. Depends what you mean by size. Depends what you mean by size. Yeah? The height! That's right. You are gonna walk up this tree right? So the number of steps. The number of effectively iterative calls to find depends on the heights of the tree. In the worst case, I agree with you that the worst case you could just have a chain right? Chain kinda like the one on the right there. And you can come up with the way set up union that creates that the worst case thing. So uh... This would be big-o of n. But that's not particularly interesting. What I wanna know is what is the very best tree look like? What the ideal tree? What do we wish these trees look like? Binary tree? No we can do better. We can do better than AVL trees. Yeah? Very good. These are not necessarily binary trees. We can have a root. Let's say, four. Okay? Should be thirteen for talking about Taylor Swift. Cause that's her favorite number you know. Why? You didn't know that? I can do some real demage to my U of I freshmen right guys? Issac knows that thirteen is Taylor Swift's favorite number. Yeah? Yeah I did. That's right. Alright this is an ideal tree. I have her on my brain today. I should shake her off. Alright let's take a union. Let's take a union here. All we have to do. Look it. We got the roots of two trees. All we have to say is s root of one one of the roots has to have a parent who is equal to the other. Now, as I said, this is arbitrary choice of this point. There's nothing wrong for me to write sown there. I think what I did was always this. The first one points to the second. So I think it is that I said the parent of root one becomes root two. Is that right? Alright, What's the running time of this function. It's constant time! That's right. It's just an assignment. It's a just changeable value here. So this is that. Alright, that's pretty good. So what we wanna do is aim toward this because then our finds are fast. What we have now is a case where we can create you know given our current code, unfortunately things can't look like this. So get a little smarter. Now, I have a question in that example. In this example, should I do what would be smarter? Should I do this? or should do this? Which one?
Should I point zero to one, or one to zero? Yeah, zero to one, that's right, because look at what happens, you kind of just tuck in the zero, right? You tuck the zero under the one and increase zero's distance from the root but there aren't many nodes there, so yes I've increased the find for zero, but I've got to increase the find for something, right? That's what union does, it builds up this tree. So I'm going to choose the one of these that reduces the height for the smallest tree I'm sorry, INCREASES the height of the smallest tree. So recognizing that we have that choice, I have a vote I need you to take. So here's a couple examples, don't look at this stuff on the bottom yet, we'll talk about it in a second. Here are a couple trees, and this time the choice is not quite so clear whether or not the left should be pointed to the right or the right to be pointed to the left, okay? So think about it for about fifteen seconds. So I'm going to ask you to vote and the vote is whether or not you prefer this (pointing the right subtree to the left) or this (pointing the left subtree to the right) so blue or green. Okay so raise your hand if you prefer the green arrow. Okay if you prefer to point to four to seven. And raise your hand if you prefer the blue arrow? Okay blue wins, kind of, okay. You want to try green do you want to try again voting again? Yeah you can vote for green again. It's about the same. So look these are both great choices. They just happen to reflect different algorithms. Let's talk about the blue one first, it's called union by height, and the idea here is that we take the shorter tree and point it to the taller tree. So this is shorter tree points to taller. Okay, and what that does is it leaves doing a union is not changing the height of the tree unless they were both originally the same height, does that make sense? So doing a union doesn't change the overall height of the tree unless they were the same height to begin with, and then it increases it by one. So, this keeps the overall height of the tree as small as possible, is the sort of tuck it in under the height of the other choice. Any questions about that? So we're going to implement that, and the idea here is that we need a mechanism for keeping track of the height of the tree. Okay, so let's see seven is going to point to four, four is going to be a negative something, in the past we said it's negative one, but here i'm going to use my memory pretty closely, or pretty carefully, since I know that four is associated with this new tree, build a root of this new tree I'm going to kind of pretend like I've got space in four to store the height, okay? And so, here I am going to let this still be negative, so instead of negative one it's going to store the negative one, what is that in this case? So the value there will be negative four. Okay, so the height of the tree is three. I just get three there. Okay. So the root, there's a bug with that by the way, you should figure out what it is while I write this down, okay, there's a bug with that idea, you should figure out what it is. The root stores negative of tree height. What's the bug? Ian?
Should I point zero to one? Or one to zero? Yeah! Zero to one, that's right, because look what happens. It's like you kind of just tuck in the zero, right? You tuck the zero in under the one. And yes, you increase... you increase zero's distance from the root, but you know, there aren't very many nodes there so, I... yes I've increased the find for zero, but I've gotta increase the find for something, right? That's what union does. It builds up this tree, so I'm gonna choose the one of these that reduces the height for the smallest tree... or, sorry, increases the height for the smallest tree. Ok, so recognizing that we have that choice, I have a, I have a vote I need you to take. So here's a couple of examples, k? Don't look at the stuff at the bottom yet. We'll talk about it in a second. Here are a couple of trees, and this time, the choice is not quite so clear, whether or not the left should be pointed to the right, or the right should be pointed to the left. K? So think about it for about 15 seconds........So I'm gonna ask you to vote, and the vote is whether or not you prefer, uh, this....or.....this. So blue or green? Uh oh... blue or green? So raise your hand if you prefer the green arrow. If you prefer to point 4 to 7, and raise your hand if you prefer the blue arrow. Ok, so blue wins, kind of, ok. You want to try-...greens, you want to try again? Voting again? Yeah, you can vote for green again, yeah that's about the same. Ok. So look, these are both great choices, k? They just happen to reflect different algorithms. Let's talk about the blue one first. It's called, Union by height. And, the idea here is that we take the shorter tree, and point it to the taller tree. So this is, shorter tree....points to taller... K? And what that does, is it means doing a, doing a, doing....doing a union, does not change the height of the tree unless they were originally both the same height. K, does that make sense? So... doing a union doesn't change the overall height of the tree unless they were the same height to being with, and then it increases it by one. So, this keeps the overall height of the tree as small as possible. It's the sort of, tuck it in" under the height of the other, uh, choice. Alright, any question about that? So we're going to implement that, and the idea here is that we need a mechanism for keeping track of the height of the tree... K? So let's see, so seven is going to point to four. Four is going to be a negative something....In the past we said it's negative one, but here, I'm going to use my memory... I'm going to use my memory pretty closely, or, pretty carefully. Since I know that four is associated with this new tree, it's still the root of this new tree, I'm gonna kind of pretend like I've got space in four to store the height. K? And so, here, I'm going to let this still be negative, but instead of negative-one, it's going to store the height of the tree. What is that in this case? So... the value there will be negative-four, k? Because the height of the tree is one, two, thr-...wait..one, two, I only get three. I'd skip three there. K. So the root... there's a bug with that by the way, you should figure out what it is while I write this down... there's a bug with that idea, and you should figure out what it is. So the root stores....negative....of tree height. What's the bug in...
Yea, good. Okay. Suppose that my tree, what is its height? it's height is 0, and so, in order to indicate that its a root, im gonna say negative 0. How does that work? Ehhhh. Do you have an idea for solving the problem Nathan? Just a minute. What? Very good. So, I'm just going to bump it up. I'm gonna not say 0, I'm going to say 1. So it's going to be I'm gonna store the negative of the tree height plus 1. So I am going to store negative 4. Whoever said that was correct. OKay. Any question about it. Just a little hack. It happens to be quite convenient. Alright. Uhhhhh, lets talk about the other alternative. the green preference. Now here's the thing. this time, we're going to take this giant tree and say whoa. Thats a big tree. I don't want to increase the height of that many nodes. So I shouldnt make it point to something new. Its a big tree. I don't want to change the height of lots of things I might be look for later. And so what we're going to do instead is take the smaller tree in terms of number of nodes. And go ahead and increase the distances to the roots for each of those. So, this increases the distance to the root for the fewest nodes and idea is that you point the smaller tree to the larger. Where smaller and larger are in terms of the number of nodes. Okay. so I can do part of this myself. Four could point to seven. What should seven's value be? I can even do this part. Seven is going to be a root, so it's value is going to be negative. But what else should we store there. Yea, the new size of the structure, the new number of nodes in the structure. Okay fine, so I think thats 12, unless it's somehow changed since the last time i taught this class. Okay, any question about it? Is it good? Alright, so what happened? Where did that 12 come from? we used to have two trees. This one would've been negative four. This one wouldve been negative 8. And so, to get this new value, all we did was add them. Any question about it? Alright, both of these schemes for union guarantee that the height of the tree, and thus the running time for find, is... What would be super good news? Constant time would be great news, but we can't get there. Both of these schemes for union guarantee that the height of the tree is O(logn). There is a third metric that you can use for deciding who should point to whom. A third mechanism for smart union called union by rank, and we don't talk about it here. The height of the largest embedded perfect tree, or something like that. So union by rank is also sometimes used.
Yeah, good. Ok. Suppose that's my tree. What is its height. Its height is zero and so in order to indicate that it's a root, I'm gonna say negative zero. How does that work. Do you have an idea for solving the problem, Nathan. Just a minute. What. Very good. Right, so, you know, I'm just gonna bump it up, right. I'm gonna, I'm gonna not say that zero. I'm gonna say it's one instead. So, it's gonna be, you are gonna store the negative of the tree height plus one. So I'm gonna store negative four here whoever said that was correct. Ok, any question about it. Just a little hack. That happens to be quite convenient. Alright, umm, let's talk about the other alternative, the green preference. Here's the thing. This time, this time we are gonna take this ginormous tree and say wow, that's a big tree. I don't want to increase height of that many nodes. So I shouldn't make it to point something new. Ok. It's a big tree. I don't wanna change the heights of lots of things I might be looking for later. And so, what are we going to do instead is take the smaller tree in terms of number of nodes it contains, and go ahead and increase the distances to the root for each of those. OK. So, this increases the distances to the root for the fewest nodes and the idea is that you point the smaller tree to the larger, where smaller and larger are in terms of number of nodes. OK, so I can do part of this myself. Four should point to seven. What should seven's value be. I can even do this part. Seven's gonna be our root and it's, so, its value's gonna be negative, but what else should we store there. Yeah, the new size of this structure, right, the new number of nodes in the structure. OK, fine. I think that twelve has been somehow changed from last time I talk in the class. OK. Any question about it. Is it good. Alright, so what happened. Where did that twelve come from. We used to have two trees. We used to have two trees. Umm, this one would have been negative four. This one would have been negative eight. And so to get this new value here, all we did was add them. That's right. Any questions about it. Alright, both of these schemes for union guarantee that the height of the tree and thus the running time for find is, what do you think. What do you think this does. What do you hope this does. What would be super good news. Constant time would be great news we can get there. Log n, right. These, both of these schemes for union guarantee that the height of the tree is big-oh of log n. There is a third matrix that you can use for, for deciding who should point to whom, a third mechanism for smart union called union by rank and we don't talk about it here. But it's, you know, it's similar sort of like the, the height of the largest embedded perfect tree, something like that. So union by rank is also sometimes used
Umm, but it also guarantees that same running time, okay? So now, let's write code that does this. Let's write code that does. Um, oh and we're not going to prove the log n here. We're going to move right past it, we're going to be satisfied with this moment of having log n, but we're not going to take the time to prove that because we're going to do better. Alright, find has not changed so the code for find didn't change at all but the running time of find is going to change, we didn't even touch it and its running time is going to change. Alright, so here is union by size, union by height could be done similarly, I don't even think we ever ask you to do it I think we always ask you to do union by size. Notice that the new size, the sum of the values at the root just like we suspected might be the case, if so we've got this helper function is bigger" that merely takes the negative of the value in the root right, and compares them. But I got a little bit lost in the inequalities there so I wanted to test that separately and make sure it did what I thought. So let's see this is this means... root 1's tree has more nodes... than root 2's. Okay. Alright, root 1 is bigger then, we're going to point root 2 to root 1, and then root 1 gets the new size. Okay, any questions about that? Otherwise we'll do the opposite. Any question about it? Okay what's the running time of that code? Yeah, it's constant time, good. Because there's no traversing going on, there's nothing about the size of any of these structures that affects running time here, right? We can look up the sizes are just array look-ups. The comparisons is a constant time thing, a conditional evaluation then we got a couple of assignments. So this is still a constant time operation but it has the effect of maintaining the trees as short trees so now we can say find is big O of log n. Do you remember what was the best we had before we started using these up trees? The naive implementations of I guess it was probably using an array. Do you remember what it was for using an array? It was constant time for size, but big O of n for taking the union. Okay. So this is using an array. And you can go back using an array naivelyish. You can go back and review that. Okay. Do you like this better? Kind of depends on which one you do most often, right? And in fact in this sequence of using these structures you can only take unions so many times, so this doesn't feel quite satisfying to me yet. Okay. We shouldn't stop here. We should do one more thing. Let's suppose we do a find of 4.
Um, but it also guarantees that same running time. Okay, so now, let's write the code that does this. Let's write the code that does this. Oh, we're not gonna prove the log n here. We just, we're gonna move right past it. We're gonna be satisfied at this moment of having log n. But we're not gonna take the time to prove it because we're gonna do better. Alright, find has not changed. So the code for find didn't change at all. But the running time of find is gonna change. We didn't even touch it. And its running time is going to change. Alright, so here is UnionBySize. UnionByHeight could be done similarly. I don't even think we ever ask you to do it. I think we always ask you to do UnionBySize. Notice that the new size is the sum of the values at the roots, just like we suspected might be the case. Umm, if, so we got this helper function isBigger that merely, you know, takes the negative of the value in the root, right? And compares them. But I gotta a little bit lost in the equalities there, so I want to test that separately and make sure it did what I thought. So let's see. This is, this means root1's tree has more nodes than root2's. Okay? Alright, so if root1 is bigger, then we're gonna point root2 to root1. And then root1 gets the new size. Okay? Any question about that? Otherwise, we'll do the opposite. Any question about it? Okay, what's the running time of that code? Yeah, it's constant time. Good. Because there's no traversing going on. There is no, there is nothing about the size that any of these structures that affect the running time here, right? We can look up the sizes, are just array look-ups. The comparison is a constant time thing, the condition evaluation. Then we just got a couple of assignments. So this is still a constant time operation. But it has the effect of maintaining the trees as short trees. So now we can say that find is O(log n). Do you remember what was the best we had before we started using these up trees? The naive implementations of, I guess it was probably, umm, using an array? Do you remember what it was for using an array? It was constant time for find, but it was O(n) for taking the union, okay? So this is using an array. And you can go back. Using an array naively I should say. You can go back and review that, okay? So do you like this better? Kinda depends which one you do most often, right? And in fact in a sequence of using this structure, you can only take unions so many times. So this doesn't feel quite satisfying to me yet. Okay? We shouldn't stop here. We should do one more thing. Let's suppose we do a find(4).
If we do find a 4, we recursively walk all the way up the tree. Right? But this is recursive process, which means after it's complete, we have to fall out of the recursion and after it's complete, we know about ten. So in a post-order way, we are gonna do the following: when we first look at 4, we are going to do a find on 4's parent, and after that is successful, we are going to connect 4 to that parent. Then going up the tree, there will be a find on 2 after which we are gonna connect 2 to that root. Then, there will be a find on 7 after which we are gonna connect 7 to the result, and then there will be a find on 9, after which we are gonna connect 9 to the root. Now, this is what that looks like after that process, you could probably draw it too, I'm gonna just redraw the whole thing with the blue arrow taking into account the correct arrows. So ten still has 9 as a child, and 11 as a child. But now it also has 7 and 2 and 4, and 1 points to 9, and 8 points to 7, and 3 points to 2, and 5 and 6 point to 4, and nothing points 11. So we took this tree whose height was one, two, three, four, five... whose height was five and by doing a find on it, change it to have height two. Any question about that? Alright what do you think the code looks like? So this is the old code- this is the old unionBySize. We are kind of ignoring it right now. This is the new find except that is the old find with just a few spaces thrown in. What goes in those spaces? Remember that what we are doing is changing the parent of the current node to be the result of the find. Let's take that sentence and put it in code. we are going to ...oh here is the result to the find. We are going to change the current parent, current node's parent to be that. That's it. So this implements path compression. You guys are quiet today. Any question about it?
Okay, if we do a find of 4 we recursively walk all the way up the tree, right? But this is recursive process, which means after its complete we have to fall out of the recursion and after its complete we know about 10. So in a post order way, in a post order way we are going to do the following: when we first look at 4, were going to do a find on 4's parent, and after that is successful we are going to connect 4 to that parent, okay? Then, going up the tree, there will be a find on 2, after which were going to connect 2 to that root. Then, there will be a find on 7 after which we are going to connect 7 to the result and then there will be a find on 9, after which we are going to connect 9 to the root. Now, this is what that looks like after that process; you could probably draw it too, but i'm just going to redraw the whole thing um with the blue err[?] taking into account the correct arrows. So, 10 still has 9 as a child, and 11 as a child, but now it also has 7 and 2 and 4, and 1 points to 9 and 8 points to 7 and 3 points to 2 and 5 and 6 point to 4, and nothing points to 11. So we took this tree whose height was 1 2 3 4 5 whose height was 5 and by doing a find on it changed it to have height 2, okay? Any question about that? Alright, what do you think the code looks like? So this is the old code, the old union by size; we're kind of ignoring it right now. This is the new find, except that its the old find with a few spaces thrown in; what goes in those spaces? What goes in those spaces? Remember that what were doing is changing the parent of the current node to be the result of the find. Okay, so lets take that sentence and put it in code; we're going to... oh here's the result of the find. We're going to change the current parent, current node's parent to be that. And that's it. So this implements path compression. Boy, you guys are quiet today. Any questions about it? Yeah?
Sixty-thousand five hundred thirty two to the 65536 how big is it? It's big beyond all comprehension. Ok. The number of atoms in the universe I think is around they expected 2 to the 300. Ok. Number of atoms in the universe. Teen-tiny things big big space.
This probably doesn't work. Okay, yup. It's if you set up the system and you just use it to build up the relationship between the elements in your set and query it through that result. You guys, I have another minute. Okay, so this is it for disjoint sets. The next data structure of interest is graphs. And the next thing we're going to do to talk about graphs is to look at some amazing examples. Yeah this is my facebook community in the bottom right. What do you think that is? This is my least favorite graph in the world. This is a collaboration graph. We'll talk about it next time, bye.
Uhh... this probably doesn't work cause it's probably a Java applet. But it was... yeah. I don't even remember what it was. Okay! [Someone's name] Yup... Yup. It's if you set up the system and you just use it to..uh..build up this, build up the relationships between the elements in your set and query it, that's the result. You guys! I have another minute! (Yeah.) Okay, so this is it for Disjoint Sets. The next data structure of interest is graphs. And the next thing we're gonna do to talk about graphs is to look at some amazing examples. Yeah this is my Facebook community in the bottom right. What do you think that is? This is my least favorite graph in the world.This is a collaboration graph. (Oooh. Oh.) Yeah. We'll talk about it next time! Bye! [post-lecture convo]
Ok let's roll. Um. So I gonna call an odd ball here and change the.... Um so for few minutes, your um.. our discussion will not match the handout. Cause I'm actually gonna go back to um last time's slides. Um... just because I have a mast all of these different applications of um graphs. And they are all cool. So my plan for today is to spend first few minutes going over these applications of graphs. Just sort of for fun. And then we will start lecture officially. At that point we'll talk little bit about the exam and about sort of finishing out the semester. But I wanna start with this kinda light stuff. So from your discrete math experience, you know that a graph is a pair. A graph is a pair. What? Do you mean the fruit pair? What's a graph? It's a pair of sets. Does that help you? See it? Do you remember graph is a pair of sets one of which consists of vertices one of which consists of edges. And we'll talk a little bit more about the notation that goes along with that later on. For now, every graph is just a vertices and edges. We constraint on the endpoints of the edges right? Every endpoint has to be in the set of vertices. Now, when you talk about application of graphs, you responsibility from the out set is to be able to discuss the parallel to edges and the parallel to vertices. Thank you. It's magic this whole class thing. Thanks Tim. So you have to be able to draw parallel between what constitutes an an edge in the application and what constitutes the vertex. And from there, you can use what you know about graphs to start asking interesting questions of your application. Um we in this class, we gonna talk about some very introductory algorithms on graphs and it is the substance of 374 in CS 374 or in some graph algorithm classes in math departments and combinatorial optimization classes especially where you end up talking a lot more in depth and a lot about a lot more sophisticated graph algorithms. Alright, so let's start with applications. These are all graphs. They all have vertices and edges but their context is completely different. Ok? This one in the upper left and any guesses about what it is? One upper left is the internet. It's an artistic interpretation of the internet in 2003. So I am not sure. So long time ago right? I am not sure that the internet would fit on this wide now. And I am not sure it really did then. Cause like I said, this is an artistic interpretation of data. And honestly I cannot remember whether this is the internet or world wide webs. So I don't remember actually the technical details of what the vertices are. Routers or main portal sites for example. I don't actually remember. But the cool thing about it is if you take connectivity data and you interpret it sort of with color and you get this beautiful thing. And in either application, you can ask interesting questions. Like for example, you know, what's the diameter of that graph or what is the longest path within the graph. And I am pretty sure the answer for this such question would be interesting even in the context of world wide web or in the context of the internet. Alright any comments about this piece of art up here? Any comments or questions about it?
Ok let's roll. Um. So I gonna call an odd ball here and change the.... Um so for few minutes, your um.. our discussion will not match the handout. Cause I'm actually gonna go back to um last time's slides. Um... just because I have a mast all of these different applications of um graphs. And they are all cool. So my plan for today is to spend first few minutes going over these applications of graphs. Just sort of for fun. And then we will start lecture officially. At that point we'll talk little bit about the exam and about sort of finishing out the semester. But I wanna start with this kinda light stuff. So from your discrete math experience, you know that a graph is a pair. A graph is a pair. What? Do you mean the fruit pair? What's a graph? It's a pair of sets. Does that help you? See it? Do you remember graph is a pair of sets one of which consists of vertices one of which consists of edges. And we'll talk a little bit more about the notation that goes along with that later on. For now, every graph is just a vertices and edges. We constraint on the endpoints of the edges right? Every endpoint has to be in the set of vertices. Now, when you talk about application of graphs, you responsibility from the out set is to be able to discuss the parallel to edges and the parallel to vertices. Thank you. It's magic this whole class thing. Thanks Tim. So you have to be able to draw parallel between what constitutes an an edge in the application and what constitutes the vertex. And from there, you can use what you know about graphs to start asking interesting questions of your application. Um we in this class, we gonna talk about some very introductory algorithms on graphs and it is the substance of 374 in CS 374 or in some graph algorithm classes in math departments and combinatorial optimization classes especially where you end up talking a lot more in depth and a lot about a lot more sophisticated graph algorithms. Alright, so let's start with applications. These are all graphs. They all have vertices and edges but their context is completely different. Ok? This one in the upper left and any guesses about what it is? One upper left is the internet. It's an artistic interpretation of the internet in 2003. So I am not sure. So long time ago right? I am not sure that the internet would fit on this wide now. And I am not sure it really did then. Cause like I said, this is an artistic interpretation of data. And honestly I cannot remember whether this is the internet or world wide webs. So I don't remember actually the technical details of what the vertices are. Routers or main portal sites for example. I don't actually remember. But the cool thing about it is if you take connectivity data and you interpret it sort of with color and you get this beautiful thing. And in either application, you can ask interesting questions. Like for example, you know, what's the diameter of that graph or what is the longest path within the graph. And I am pretty sure the answer for this such question would be interesting even in the context of world wide web or in the context of the internet. Alright any comments about this piece of art up here? Any comments or questions about it?
Okay let's move on to the next one
No, I don't think so, it's think it's laid out by some... ya know, physical, physical relationship of the edges not by geography. That would be interesting too... But kind of unnecessary, haha, it's like they put all the derby girls out in a barn, hahah. I don't know! Alright, so I, this was really fun to do and like I said it's from a years ago so... Sylvia, are we Facebook friends? Am I Facebook friends from anyone in here? Yes! Right, of course. So you guys aren't on here... yet. Next year. Ok. This graph... or any questions or comments about this one?...yes? So the weird thing is I don't have a lot of... I haven't stayed in touch with a lot of my college friends... isn't that sad? You guys have to do better than I did about that. I suspect that that's what some of this is. I... I don't know. There are only a very few people from college that I'm still in touch with, it's weird. Because I loved college! I should look them up. Alright. Um... This graph is fascinating, ok? It's complex. It is a... let me see how to describe it. Oh! Every vertex... every vertex is, a class, a course, offered at some university. It's a small university, ok? We could do the same thing for our, our, university but, this was done for some place else. Some place with not very many courses, k? This might just be a subgraph. So every vertex is a course. And, there is an edge between a pair of courses if some student is enrolled in both. Ok? Does that make sense? Sooo... if you are in these two courses then you represent the edge between. Now it may be, if there are five students or ten students, but, if these two courses have student overlap, there's an edge between them. Now. All these edg-, all these vertices have shapes associated with them. What do you notice about the configuration of the shapes? You can even just look at a little subgraph, and little subgraph and you can notice this... characteristic that I'm talking about. What is true... and, yeah? Very good! No two of the same shape are connected. We say that, the vertices on this graph are colored. In this case they are colored and shaped. And what that means is, every edge's endpoints are different. Now, what on Earth is this graph used for? It's very timely, because it's used for finals scheduling. So, all of the, for example, I'm going to take the green circles because they're easy to talk about and easy to see. All of the green circles, can be scheduled simultaneously. Right? Let's put those at 8AM, Friday morning. K? And all of the blue triangles can be scheduled simultaneously. There will be no conflicts. K? So, this is it. Now, here's the- so that is the formulation of the problem. That's the formulation of the problem, kind of cool right? You're sitting there wondering, oh, I wonder if our registrar has software that does this?"...It doesn't... Because there is no algorithm, there is no efficient algorithm for solving this problem. K? Woah? I didn't know, I didn't know there were-yes! In fact, this could be your path to fame and fortune! I didn't know there were easily stated problems for which there's no reasonable algorithm. Now, you know, can you get close? Can you do well on sub-problems? Does a greedy approach work? You know... there are all kinds of things that, that, can make at least pieces of this problem a little more tractable, but, isn't it interesting to think about the idea that there are questions that are easily posed, but for which there exists no known efficient, efficient is key here, solutions. K? Alright, so, there you go. A graph coloring. Any questions or comments about any of these? K let's look at a few more. Um, oh... oh c'mon, you can do it. I love this one. Raise your hand if this game is familiar to you. The game in the upper-left, er, upper-right corner is familiar to you. Ok, it's a little puzzle game, um... you get a board, or a card that tells you how to configure the game, and the object is, uh-oh, somebody help me out here, to get the red car out, right? Is that right? And, you're movements are constrained in that... oh, somebody help me... how do you do, what is the constraint on the movements? Yeah?
I think it is probably laid out by some physical relationship.
Okay so or forwards or backwards right? There is no turning it's plastic, if you tried to turn these cars they'll break. Right. So each car can only go, you're trying to get the red car out, and each car can only move forward and backward it's a little puzzle. Alright, so the question is what's the graph? Now remember, remember, that to describe a graph, means to tell what the vertices represent and what the edges represent. So what the heck is that graph? You're welcome to come up here closer if you can't see very well from back there. You're just welcome to stand right up and come and look if you like. Let me see how well you can see. Can you see very well? Kind of, okay. Where it looks like there might be an edge between them, pretend there is. What is the graph what are the vertices, and what are the edges? And then I'm gonna ask what are the green dots? Mmmmmm. Finishing positions is a good guess. It's a good guess. Yeah? Start with vertices. Yes, very good. So we say that the ver- each vertex is a state of the game, and that corresponds to a position, a set of positions, of all the cars. So presumably, that picture in the upper right hand corner, corresponds to one of the vertices in the graph. Okay? Any question about that? Yeah? Yes! Very good. So the edges between them are uh correspond to the ability to move from one position to another via a valid move. Okay? Alright, fine, What are the green dots? Yeah? Yeah! The path to completion, very good. So presumably this is the start configuration, and I'm guessing, I'm hoping, I guess, that in fact those green dots correspond to the shortest path to completion, okay? And that blue up there is done. Alright, so what's with all of fan out up there, with all the different the fan out in the path? Somebody who plays the game, tell me what happens at the very end. Somebody who's played the game, tell me what happens at the very end. Yeah? [student response] Uh huh? Ah! Okay, so I think, that that corresponds to ending of over here, but I don't think it describes this stuff. Yeah? Yeah okay, so sort of. That's a little closer. So those are all the shortest paths so presumably you wouldn't have any kind of extra" moves. Gratuitous extra moves. The answer is when you're close to the end, there are lots of different ways to finish it off. Right, like you can move backward and, you know, I don't know. You can- you get to decide which one to move first and you know, you can finish the game up either way. So at the very end, there are lot more degrees of freedom to finishing the game efficiently, k? So this is a great game to play, while you're riding a bus, say over thanksgiving. I'm pretty sure there are mobile versions of it. In fact, all these think-fun puzzle games, are super fun and probably have mobile apps that correspond to them. Okay, uh I have a question for you, don't look at the graph yet, I have a question for you. When you were in about 4th grade, probably, your math teacher gave rules for checking for divisibility, right? What was the rule for checking to see if something was divisible by 2? Even, right, The, the one's digit was even. How about the rule for checking if something was divisible by 3? Some of the digits uh is a what? Divisible by 3- Oh my gosh, it's recursive! [students expressing stress at hearing recursive] You didn't know it! You were doing a recursive algorithm when you were in 3rd grade, right? Because what if the sum of the digits is 18? You added again, right? Ohoho, goosebumps, right here. Okay. Uhh alright, how about 4?
Last two digits you has to know you fourth time table pretty well, right? Five, easiest one, and the one place good, six, two and three, seven. No body ever knew a rule for seven, right? about about eight? Was there a rule for eight? Last three Digits? Long division skill. Or it is your eighth time table pretty well. How about nine? Yes, some of the digits is again. Ok. It is that whole seven thing always buged me a lot. If it is like 8, you could do like divided by half and then do it with 4. There is no rule for seven, really a problem for me. It turns out that there is a little graph that could help you out with the divisibility by 7. It is a algorithms for checking. I am going to go through it very quickly. You will not be tested on this, it is nifty. You start at the circle node on the top, this is an example of a finite state machine. A particularly finite state machine, of which a graph is a key component, for each digit D in the given number, starting from the left as if the number is a string, I am not sure if it matters. For each digit follow D blue edges, after you do that, follow the red edge. So it is blue for the magnitude and then follow a red. For example, when I read the three, I am gonna go one, two, three, got it? And then, followed the red. So after the red, I am in that state. Any questions? Now let us do seven, cause it is fun. Do it in a different color even. Now seven. One, two, three, four, five, six, seven. and then one, the red one, to go here. Ok. Now zero, so I don't go anywhere but I do have to follow the red, and then, three, one, two, three, follow the red, oh, look. If you end up in the circle node, your number is divisible by seven. Alright, any questions? I will tell you how you come up with it. It is cool .In CS376 you used to study things and it would be a homework problem in that class long time ago. I am not sure if they have time for fun little puzzle like this now, but this is.. What do you think each vertex represent? Mode seven, very good. So my guess is that 3000 is what ever the first one is mode 7, and then, the seven get you back to that thing. It takes that all the way around. It has to do with with the values mode 7 to get the divisibility of powers of ten mode 7. A number theory class, not know it very clear. This is a graph applications, who know. You could wright code to do that very fast. When I firstly got there, one of a faculty person who ended up being my advisor who is now a friend, told me that finite date machine, were just programs. And then I asked what are you talking about, one of them is like this combinatory structure that you can build picture out of. One of them is a way of speaking, a way of control data. They cannot possibly the same thing. But he is right about it of course, a advisor always are. Not true, but in this case, he was. Basically, you are changing the state of your system conditionally. If you see something like three, you increase it by three. What ever you see there is the value you use implement the state of the diagram. There is code all over the place, I am pretty sure, that you could actually wright the code to do this by looking at the diagrams.
Last 2 digits. so you had to know your four's time tables pretty well right? Five? easiest one. yeah in the one's place. good. six? two and three. seven. nobody ever knew a rule for seven right? how about eight? was there a rule for eight or did teachers... Last three digits. oh boy. So you have to pull out your long division skills for that one almost no matter what okay. Or get to know your eight time tables pretty well. okay fine. How about nine? yeah sum of the digits again right. okay alright it's that whole seven thing that always bugged me a lot. because with eight you can like divide in half and then do the four trick right. Alright so the whole there is no rule for seven really was a problem for me in fourth grade. alright. Well it turns out that there is this nifty little graph that can help you with divisibility by seven. It is an algorithm for checking. I'm going to go through it really quickly. You will not be tested on this but it's kind of nifty. alright so you started the circle node at the top. So this is an example of a finite state machine. a particular kind of finite state machine of which a graph is a key component. For each digit d in the given number. Starting from the left as if the number is a string. Though i'm not sure it matters. It probably does matter actually. For each digit follow d blue edge and then after you do that follow a red edge. so its blue for the magnitude and then follow a red. so for example when i read the three I'm going to go one two three. got it? and then follow the red. So after the the three i'm in that state. Any question about it? Okay now let's do seven because this is fun. I'll do it in a different color even. Now we're going to do seven. Alright one two three four five six seven. oh look it brought me back to where i was. And then one. the red one to go here. Now zero. So i don't go anywhere but i do have to follow the red. and then three. one two three. Follow the red. oh look. if you end up back at the circle node, your number is divisible seven. yippeeeeee. yessss. not even kidding. alright any question about it? yeah? Did somebody get a PhD for this? probably not. [laugh] alright so you know. i'll tell you how you come up with it. It's cool. In CS what used to be three seventy three you studied these things. And this would have been a homework problem in that class. when it was offered a long time ago. i'm not sure they have time for fun little puzzles like this now. but yeah this is what do you think each vertex represents. mod seven very good. my guess is that three thousand is whatever the first one is mod seven. and then the seven gets you back to that same spot. is that right? it takes you once all the way around. oh and then one more. so i don't know exactly. but it has to do with the values mod seven together with the divisibility of powers of ten mod seven. a number theory class would also make this pretty clear probably. Alright any other questions about this? To graphs! Look it's a graph. these are graph applications. who knew? you could write code to do this super fast. oh when i first got here. The faculty person who ended up being my adviser and who is now a friend told me that finite state machines were just programs. And I went what on earth are you talking about? One of them is this commonatorial structure that you could build pictures out of. and one of them is a way of speaking. a way of controlling data. They can't possibly be the same thing. but he's right of course. Advisors always are. No not true but in this case he was. That basically you're changing the state of your system conditionally. If you see a three, you increase something by three. Or whatever you see here is the value you use to increment the state of the diagrams. So there's code all over the place there and i'm pretty sure you could actually write the code to do this by looking at the diagram. okay any questions about it?
All right. All of these have stories. I think this is why we are gonna do this. All right. So here is another graph. You've probably seen graphs like this before. Um..this is a surface mesh, uh... of a little thing. OK, a surface mesh. But dataset itself, which is really just the vertices here. The data set itself is a classic dataset used in, um, graphics algorithms, used as a benchmark for any kind of new graphics algorithm that anybody ever wants to do. So they refer to the dataset itself as the Stanford bunny, for obvious reasons. It came..I mean it happen to have originated at Stanford in their graphic research group. And examples of its use as a benchmark are, are there somebody with testing out too see how there, you know, how their, the lighting source worked with this shiny texture that map onto something in here. You know, hair is the hardest thing to model. And so it's very common to have a ten-set modeling hair graphically. And the graph part of this is really fascinating. So this data set is way way way way way too dense. It has way too many vertices. And so the goal is to come up with a reasonable way of shrinking that dataset into something tractable, something that can pop way quickly or something you can animate most specifically something that can be man animated for example. And then to use the triangulation the triangle mass mesh must be between the vertices and surfaces on which to build your graphic applications. So sitting underneath that shiny bunny is actually a whole bunch of triangles, each of which has coloring map onto it, in a particular way. OK, based on physics, the physics of light and color, OK, and movement and angle, and lots of different things. So, the goal, then, is, in computational geometry is to take a dataset and to shrink it down in a meaningful way. Now this bunny was created with pretty good, with a pretty good algorithm. It looks like because in areas of high curvature there are still lots of points. But in area of low curvature, like, you know, where the cross the back of bunny, there aren't many points that is the triangle themselves are fairly close to the actual surface the bunny. OK, Any questions about that? So this is cool. This was when I first came to grad school this was what I thought. I wanted to do 'cause it's just fond to think about. OK, so the graph itself is the vertices that actually do lie on the surface of some bunny, somewhere, historically. And the edges are created algorithmically to represent the surface of bunny, to be representatives of the surface of the bunny. Now all right so what's the rest of the story? The rest of the story was I was in my aunt's house in Saratoga, CA, which is kind of close to Stanford and we were in her family room. It's a family gathering I haven't seen her for a long time, it was great. Sitting in the family room, looking up at her book shelf and there is the Stanford bunny, like. So little tarakada bunny, right? I had only ever seen it in that form. And I guess... I'm like Ah..!!! GOD! Ah!!!! Ah!!!!!! So the most mysterious thing to fame I ever experienced. After I woke up... no I didn't really pass out get but you were to get that bunny! but it turns out the bunny is just some mass-produce little long ornament. There is probably thousands of them especially in Bay Area long ornament stores, or something like that. But!! But you know just a for moment before that I thought I was in the present of greatness. So this is rightly boy, who is now 8. OK any questions or comments about that? So if you are interested in computational geometry or graphics, of course there are experts in our department who will be very happy to talk to you. All right.
alright all of these have stories I think this is why I meant to do this Alright so here's another graph You've probably seen Uhm graph like this before This is a surface mesh Uhhh Of a little thing okay a surface mesh The data set itself Which is really just The vertices here The data set itself is a classic data set Used in uhm Graphics algorithms Used as a bench mark for any kind of new graphics algorithms That anybody ever wants to do So they refer to the data set itself as the Stanford bunny For obvious reason, it came I mean it happen to have originated at Stanford In their graphics research group And examples of it is used a bench are of there was somebody testing out to see how Lighting source works with this shiny texture that they are mapping on something You know hair is the hardest thing to model and so it's very common attempts at modeling hair Graphically, and the graph part of this Is really fascinating, so this data set is way way way way too dense IT has way too many vertices so the goal is to come up with a reasonable way of shrinking that data set into something practical so you can pop away quickly or something you can animate, most specifically something that can be animated, for example And then to use the triangulation, the triangle mesh between the vertices As surfaces on which to build your graphic application so sitting that shiny bunny is actually a whole bunch triangles, each of which has coloring mapped onto it in a particular way based on physics, the physics of light and color Okay and movement and angle and lots of different things Okay, so uhhh the goal then is in computational Geometry is to a data set and to shrink it down in a meaningful way Now this bunny is created with a pretty good algorithm because in areas of high curvature there are still lots of points but in areas of low curvature, you know, across the back of bunny There aren't many points, that is the triangles themselves are fairly close to the actual surface of the bunny Any question about that? so this is cool When I first came to grad school, this is what I thought I wanted to do because it's just fun to think about Okay, so the graph itself is the vertices that actually do lie on the surfaces of some bunny, somewhere history and the edges are created arithmetically to represent the surface of the bunny to be representatives of the surface bunny now so what's the rest of the story? The rest of the story is that I was at my aunt's house I was in Seratoga, California which is kinda close to Stanford. And we're in her family room ,it's a family gathering, I haven't seen her in a long time it was great, sitting in the family room looking at her bookshelf, and there is THE Stanford bunny. Like the little terracotta bunny. I had only ever seen it in that form. And I gasped. I'm like *gasped* It's the nearest thing to fame I've ever experienced And after I woke up, no I didn't really pass out Well it turns out the bunny is just some mass produced lawn ornament. There are probably thousands of them. Especially in bay area lawn ornaments stores or something like that, BUT just for a moment there, I thought I was in the presence of greatness. Alright any questions? So if you are interested in computational geometry or graphics, of course there are experts in our department who would be VERY happy to talk to you Alright.
Everybody has their favorite graphs. This is my least favorite graph. I hate this graph. I like part of it actually. I like this one. I like this one....(repeat) I do not like this one. I really don't like that one. I don't like this one, this one..... I don't like that one neither....I don't like this one. All right, should we talk about what this graph is? Pains from stomach hurt. All right, so the vertices are CS225 students, and the color of the vertex, color and size actually is the semester the student was enrolled. Ohhhh... Ok, the orange ones are the current semester and this is MP3 from few years ago. What? So green is I don't know, the year before. the semester before. So, do you see why I don't like this one. So this person says to this person Hey, let's go get ice-cream". And this person says:I can't go, I have to work on my MPs" And this person says "Oh I can get that over with you." Thereby denying this person the joy of conquering. Ok,ughhh... Why don't I like this one? Because our MPs allows a pair but not a triple. So I don't know... You know there are a lot of stuffs to talk about here. This person needs a lot of help. I am pretty sure this person was because they probably get caught in. This almost certain get caught in. Oh yeah okay there is an elephant in the room right? I could actually write down the netid right here, and you guys go like. Oh yeah, I know that one. Pretty sure, it's been there for years. We have tried to figure out, then when we've tried to get the person to get down. They won't, they don't. Like the one person, normally when we see person's github, we ask them to take it down, and they go Oh, yeah,sure sorry" just take it down, I don't care. Umm cuz they don't want me to think you know whatever. That person, that is just still there. But I am pretty sure if I did say like go oh yeah, rings the bell. Any question or comment about this? The key thing I am pointing out here is if you use somebody else's code, especially something you find online. This is the first one that appear on github I believe a long time ago. So here's what happens. I am pretty sure that this person and this person really had no reason to have written/ worked together. And certainly these people they didn't know that they're working with other people. They didn't know this is the rule of transitivity here. If they're both like this one, they're very likely to be like each other. Moreover, that codes always gonna be there. I can't get it taken down. If you use it you join the club. Like everytime I see this graph, I go I know who that one is. You can't get your code's DNA out of the graph at that point. Ok?
Everybody has their favorite graphs... this is my least favorite graph. I hate this graph. I like parts of it actually. I'll show you the parts I like. I like this one. I like this one. I like this one. I like this one. I do not like this one. I really don't like that one. And I don't like this one, this one, this one... I don't like that one either. Mm mm I don't like this one. Alright, should we talk about what this graph is. It makes my stomach hurt. Alright, so, the vertices are CS 225 students and the color of the vertex, color and size actually, is the semester in which the student was enrolled. Oooooohhhhhhhhllll. The orange ones are the current semester and this is MP3 from a few years ago. What? So green is well I don't know.....the year before, the semester before. Soooo do you see why I don't like this one? So this person says to this person, Hey, let's go get ice cream." And this person says, "I can't. I have to work on my MP. And this person, Awwww. I can get that over with for you. Thereby denying this person the joy of conquering, right? Okay, why don't I like this one? Well because our MPs allow for an sided pair but not a triple so I don't know. And so you know there's lots of stuff to talk about here like this person needed a lot of help. I'm pretty sure this person was Pete. Because they probably got called in. I don't know whether this person did or not. This one almost certainly got called in. Oh yeah okay there's an elephant in the room, right? I can actually write down a netid right here and you guys would go, Oh yeah I know that one." Pretty sure... it's been there for years and we've tried to figure out and we've tried to get the person to take it down and they won't and they don't and it's like the one person normally when we see the Github stuff we ask the people to take it down they go, Oh yeah sure sorry!" I'm like whatever just take it down I don't care. Cause they don't want me to think you know whatever. But that person that its just still there. I'm not gonna say the netid because that would I bet would have to violate all kinds of rules but I'm pretty sure if I did say it you would go, Oh yeah, that rings a bell." Any questions or comments about... Oh, so the key thing I wanna point out here is that if you use somebody else's code, specially something you find online, this was like the first one that ever appeared on Github I believe a long time ago. So here's what happens I'm pretty sure that this person and this person really had no reason to have written similar or have worked together and certainly it's the case you know these people they didn't know that they were working with other people. They didn't know that this is the rule of transitivity here. If they are both like this one they're very likely to be like each other. Moreover that code's always gonna be there I can't get it taken down. If you use it, you join the club, right? Everytime I see this graph in the future, I'm gonna go oh yeah I know who that one is. I know who that one is. Right like you can't get your codes DNA out of the graph at that point. Okay?
Any questions about it? Yes? Look at all the questions. The orang? Well it's this semester ten semesters ago. I have not run thisgraph for this semester yet. I haven't seen the graph yet. I'm going to. Yes? Yes I have to call in.. Oh yeah. oh yeah. And the class was a lot smaller then. There weren't any orange dots there. I think it didn't draw all the ones that were just singular orange dots. okay. yeah it's a huge problem. we should all be embarrasssed by it. okay. ah. so the thickness of the edge measures the amount of similarity. okay so this person thought it was really safe just to hold wholesale copy this code. And it's exactly the same; pretty much exactly the same. where yeah the width of this line tells you how similar they were. okay. and it's just a similarity scale between 0 and 1. presumably it's close to the fractions of similar lines of code. okay. yeah? oh this is actually, i think, the most fascinating question. umm... so he said, well what if it happens accidentally?" and the amazing thing is it doesn't happen accidentally. it just doesn't. it's the weirdest thing. umm.. people write, just like when people write english. it.. it's very, you know, people have their own style; people do things, measurably differently. so now, especially our mp's are just big enough, i think, that it's not a problem except for mp1, right? like, we're.. oh gosh! how else can you do this besides a nesteed for loop right? umm.. so mp1 tends to sort of give false positives. umm i have seen for mp4, it's clamped down enough that we saw what we call the Charlie Mooney effect. Charlie Mooney was one of the very best course staff people in history. and he, like, would teach the material and he taught it in such a particular way that it informed people's code and very substantially and so we saw a bunch of them look very much alike because of Charlie Mooney's instructions. So, you know, of course we're fair, right? like we're, i'm not, i certainly don't want to be at war with students. so, right, you know, we don't push on that very much. do comment's come into play? the question is do comments come into play?" so, umm.. i feel a little.. uh.. strange discussing like how we do this.. but still, because.. because, you know.. information is good, we should be on the same page, right? umm.. so the question is, do comments come into play?" comments do not come into play in this analysis. but i never ever ever ever call anybody in without looking carefully at the code. and so when i have, you know, comments are a tell. like if people have comments that match too, then i'm.. i'm like a hundred percent sure this is a probable. so they come into play that way. they don't come into play in the initial analysis. they are looked at. okay. third question! yeah? who's.. i can't tell you. it's on github it 's there now. you shouldn't go look because then i'll you know... it's there. yeah?
So there are actually a few different algorithms that do this This particular one was created using MOSS which is a measure of software similarity Probably the most widely used in courses like this I tell you this now, I used to not tell this because I wanted to keep it on the down low So it's unfair because students will exploit, by googling how does MOSS work? Those people will have the nefarious advantage over people who are kinda oblivious. So I'll tell you we used to use MOSS, it's done, you can look it up, you can read the white paper It's done by looking at Strings of code what are called N-grams, I believe it does not look at the compiler code. There are new tools out there that some of our students are developing. And we're migrating to those, because they actually do look at the syntax tree. Alright so my least favorite graph. The upshot is so here's what I really want to say about this Oh my gosh [mumble] Here's what I really want to say about this. You are all, there are two things, you are all extremely fortunate to be here. This is an amazing place but to also deserve to be here. They don't let anybody in here out of pity. So this is an opportunity to grow and to challenge yourselves and you know, to walk in this community of achievement and discovery is a better way of saying it. If you do this, if you do this, you hurt everybody right? You cheapen the value of your degree You create this kinda of I'm going to sneer at your when I walk by in the hall" not that you care about, but you know you risk your degree, right? You risk getting in trouble for this. But most importantly you don't grow in the way we think you can and we want you to grow right? So the incentives to NOT do this are actually really huge. Now if you ever have that feeling, oh it's 11:59 and 59 secs right? And this is your out, OMG come talk to us. We'll figure it out, we'll help you figure it out. We don't, you don't have to do that. There's other ways. Yeah? [mumble] Helping" So we hire the TA's because they are good teachers generally. Generally really good teachers and we've never seen a connection like this with a TA or CA NEVER, EVER EVER So what happens is that your random friend got an A in the class looks at your code. And they go I don't know what you're doing, here's what I did" and then you're lost. The CA's will never do that, that's not what they do. That's what the difference, right there. The minute you look at somebody else's code, your ideas are shaken. Yeah? [silence] I mean ideally it shouldn't matter. I'm actually doing it for Lawrence in 241. yeah so he doesn't have the issues, alright yeah so the comment was shouldn't we start the semester with this? Probably true, point taken. Alright Happy thanksgiving. I'm thankful for all of you! Now, it's right now
welcome back. how was your break? So we have this many more hours together. one hand. and we have a ton of content to do. So ideally this would be sort of the time between midterms. it isn't. It actually is the book of final exam. So we cannot turn off the deal yet. Because you know, you are not a computer scientist dough(?) of graphs. Our discussion of the details of graphs algorithms. In the discrete math class all of these definitions had been handed to you. If you're probably, 3 or 4 lectures scattered about the argumentation. If you glance over this list. It's kind of ugly. Each of these capitalized things is a phrase. If you glance of this list, and you don't yeah yeah yeah", then you might want to revisit these terms in a fairly focused study kind of way. I'm going to be using these terms without definition in these 2 lectures. I'm almost certainly completely not able to reinforce their definitions. I won't just cruise right past, but it's very likely there will be very little concrete and rigorous definition of these kind of stuff going forward. I'm gonna advance that slide and we'll be done. Ready for this? Okay, they're gone. But we know them. So we're going to spend just a few minutes talking about some theory that's going to help us analyzing running time of algorithms. These are so fundamental that I want to make sure you have them. We're starting off with a graph denoted by a pair of sets, one of which is vertices the other of which is edges. It's a combinatorial construct. By way of notation, we're typically going to refer to the size of the vertex set as n and size of the edge set as m. Most of the algorithms that we're going to talk about have running times that depend on the number of edges in the graph. But usually when we wanna report the running times, we wanna report them in terms the number of vertices, n. So what we need to do before we go on, is make sure we completely understand the relationship between the number of vertices, n, and the number of edges, m. That's what this slide is all about. The question is, if I tell you I have a graph that has n vertices, how many edges does it have? Alright first thing we're gonna talk about is the least possible number that such a graph would have. So it would have no fewer than what? The answer is, depending on whether the graph is connected or not connected. What does it mean for graph to be connected? See I couldn't going through the definitions without saying them.
From say the last part again from what? Very good. So the shorter version of that was exactly right. The shorter version of it is between any pair of vertices there is a path. There exists a path between any pair of vertices. Alright if that is the case, then your graph is connected. Now what does it mean for it not to be connected? Well, it's the not of that. That is there is a pair of vertices where there isn't a path between them which means you cannot get from one vertex to another walking on edges. Okay? Connected. Not connected. Alright so let's start with not connected first. What's the fewest number of edges a graph that is not connected can have? The fewest number not connected graph. Everybody raise their hand with the number. Zero is correct. This right? Alright about connected. Ooohhh gets a little harder. Uh oh. Yeah? N-1 very good. Did you sketch that down and figure it out or did you remember it? You just okay. That's called remembering it I think. Yeah good. Very good. I believe at last count the last time I did research there are 37 different proofs of that result that the least number of edges in a connected is n-1. Okay? We're gonna do one of those proofs on the next page. The one that I kinda like the best. Alright fine. Let's talk about then the upper bound on the number of edges and this time we're gonna characterize the graph as either simple or not simple. Uh oh. What's a simple graph? Mike. Alright no multi-edges we usually say so simple means a simple graph means that there are no self loops like this is disallowed. And I shouldn't have made that directed. And no muilt-edges. Good. So that means none of those. Okay? Alright here's a nice time for me to say that if I forget to say a graph is simple in this class you should assume that it simple. So the default graph here is a simple graph. Any question about that? Let's see if the graph is not simple, how many edges might it have? Is infinity a number? It's like a place. Infintely many right? Because we could just keep drawing them and no matter how big or how many we drew we could just add another so there is no limit the number of edges. Okay. How about for a simple graph? Yeah? Ohhhh. This is an upper bound so we wanna put in as many edges as we can. As many edges as we can. Yeah? Ohhhh nooo. You should sketch it down just a little bit. Just draw a few pictures and see if you can come up with a scheme for figuring this out.
From say the last part again. From what? Very good. So the shorter version of that was exactly right. The shorter version of it is between any pair of vertices there is a path. There exists a path between any pair of vertices. Alright. If that is the case then you're graph is connected. Not to be connected well it is the not of that. That is there is a pair of vertices where there isn't a path between them which means you cannot get from one vertex to another walking on edges. Ok connected not connected. Any question? Alright so lets start with not connected first. What's the fewest number of edges a graph that is not connected can have? The fewest number of not connected graph? Everybody raise hand with the number. Zero is correct. Alright. How about connected? Gets a little harder. Uh oh. Yeah? N-1. Very good. Did you sketch that down and figure it out or did you remember it. You just ok. That's called remembering it I think. Yeah good. Very good. I believe at last count the last time I did research there are thiry seven different proofs of that result. That the least number of edges in a connected graph is n-1. Ok. Uhh were gonna do one of those proofs on the net page. The proof that I kind of like the best. Alright fine.. uhh.. lets talk about then the upper bound on the number of edges and this time we are gonna characterize the graph as either simple uh oh. or not simple. h oh. Whats the simple graph? Mike? Alright no multi-edges we usually say. So simple means, a simple graph means that there are no self loops. Like this is disallowed. Ok I shouldn't have made that directed and no multi-edges. Good. That means none of those. OK? Alright uhh here is a nice time for me to say that if I forget to say a graph is simple in this class you should assume that is simple. The assumption, the default graph here is a simple graph any question about that? Ok. Alright Fine. Uhhh lets see. If the graph is not simple. How many edges might it have? Is infinity a number? Infinitely many. We could just keep drawing them no matter how many we drew we could always just add another so there is no limit to the number of edges. Ok. How about for a simple graph. Ohhh. Yeah? Ohhhh this is an upper bound so we want to put in as many edges as we can. as many edges as we can. Yeah? Ohhhhhhh noo you should sketch it down just a little bit. Just draw a few pictures and see if you can come up with a scheme for figuring this out.
Those of you with your hands raised, uhmmmmmm. I wan't you to very carefully instead of just saying the answer, the next thing I'm going to ask you is: How do you know that's the answer? So think a little bit about how you would argue that your answer is correct. For those of you who are waiting for me to respond. Okay ready? It is N*(N-1)/2. Where did that come from? N time N minus 1 over 2. Okay. Alright. So raise your hand if instead of saying that, you were actually going to say N choose 2. Were you going to say N choose 2? Okay good, we're going to talk about all of yours together so remember that its you and who said N time N minus 1 over 2? Okay good, help me remember that its the two of you guys. Okay? And lets see there's one more way of thinking about this. Yea? ESP here you don't even have to finish. Okay? Yes. The summation of- oh you wanna finish? Yea. Summation K equals 0 to N minus 1 of K. Very good. Alright. So you learned early on. So you learned early on that all three of these things were equivalent. But. In the context of this particular application of these results, there are different ways of looking at the problem that leads to each one of them. Okay? How- what justifies this? We're counting edges. We're counting edges and I want to know why this is a good answer? Who said this one to me? Why is this one a good answer? Very good! Excellent! So what he said was Look, every edge has 2 endpoints. Each of those endpoints has to be a vertex, so the total number of ways of choosing edges is the number of vertices choose 2. Any question about that? That's how many edges there are. Any question about it? No? Good? Okay, uhmmmmmm. Let's talk about this one next? How do you justify this one? Who said this one? Who said- Oh yea, how do you justify this one? Oh its the shorthand for this one? So should we talk about this one first? How do we justify this one? Mike? Very good. Very good. Okay. So. Here's how we're gonna argue this. Okay? I'm gonna start at a particular vertex and say alright how many new edges can I draw from that vertex. And if there are N vertices then I can draw and edge to all of the other ones, or N minus 1. Then, I can go to the next vertex and do the same thing. How many can I draw? N minus 2. Go to the next vertex, do the same thing. N minus 3. Okay? is that clear? In the end you end up with a summation that looks like this. Alright. One last cool thing to discuss. Okay? Pretend that I drew this whole graph. Pretend I drew all the edges here. I think I probably missed, well, some. Pretend I drew them all. And pretend this is a complete graph with N vertices. Now what I want to do is count edges by counting endpoints. Okay? How many endpoints are there here? N minus 1. How many endpoints are there here? N minus 1. How many endpoints are here? N minus 1 all the way around right? How many N minus 1's do I have? N of them! That's right. N times N minus 1. So whats with the division by two?
good very good, i just counted end points, right and so this is the degree of each vertex, thats one of those vocabulary words, times the number of vertices that gets you all of the end points, divide by 2 since we are counting edges and not endpoints. Okay, it is clear. Now I love this but there are these three completely different ways of looking at looking at the same problem, thats cool right? Any questions about it? Okay well one more little thing that we are going to need for many of the algorithms that we do. Many of the algorithms that we do will go across a vertex and do something for every edge on the vertex, so our algorithms will iterate over all vertices. When I looked at this I was like waaooo. I need to redo that expression. So many of our algorithms will do something over each vertex for each incident edge on the vertex. Now, I want to know an exact expression for what this must be. And i don't mean upper bound on it, i mean tell me as accurately as you can, what you get if you add up all of the degrees of all the vertices. Very similar to something you already thought about today. Yea, twice the number of edges, very good. No matter what, if you add up, if you add up all of the degrees of all of the vertices, you end up with all of the end points which has to be twice the number of edges. Now, why is this important, why don't we always just use this? And the answer is because not all graphs have all of the edges. Not all graphs have all possible edges, sometimes we can be a little more specific with our algorithms and base them on the running time, the actual number of edges. Alright, any questions on anything on this page? I think i promised you this proof. So lets go do that. Okay, I am going to do a lot of talking for the next few minutes. You will notice that, it has a little bit different of a statement, okay? What minimally connected graph means is if you took out an edge, the graph would fall apart, okay minimally connected means removing an edge, makes the graph disconnected. Another way of saying this is a connected acyclic graph, right minimal means that there are no extra edges, so this is another way of saying it is a tree.
Good,very good! I just counted n points right? and every edge has two end points. So this is the degree of each vertex that is one of those vocabularies words times the number of vertexes that get you all end points divided by 2. because we are counting edges not end points. Is it clear? Now I love this there are these 3 completely different ways of looking at the same problem. That's cool. Any question about it? OK one more little thing that we are gonna need for many algorithms that we do. They will go cross a vertex and do something on every edge on the vertex. So, our algorithms will iterate over all the vertexes. So many of our algorithms will do something over each vertex for each incident edge on the vertex. Now I wanna know an exact expression for what it must be. And I do not mean a upper bond on it, I mean tell me as accurately as you can, what you get if you add up all degrees of all the vertexes? Very similar to something you have already thought about today. Yeah, twice number of edges, very good! no matter what, if you add up all the degrees of all the vertexes, you end up with all the end points which has to be twice the number of edges. Now why it is so important? why don't we always just use this? The answer is because not all graphs have all their edges. somethings we can be a little bit more specific with our algorithms and base them on the running time, the number of edges. Any questions? I think that I promise you about this prove. So let's go do that. Here is the set up. You notice that the theorem itself has a little bit different of a statement. What minimally connected graph means is if you took out an edge, the graph would fall apart. so, minimally connected means removing an edge makes the graph disconnected. another way saying is it is connected basically graph. Minimal means there are no extra edges. So it is another way saying it is a tree.
and then how many edges does it have? well it's just another way of saying n-1, cuz the size of v is n. Alright so what we're gonna do is we're gonna consider a random, arbitrary minimally connected graph. I've drawn a picture of one here, we're going to let v and e denote the vertex and edge sets. Now there's a lemma that we're going to need, that is every connected subgraph it's like subsets of these with some constrains of them you should look up them to be concrete so if you take a connected subgraph and you remove an edge, they'll fall apart. there's an easy way to prove this: if the subgraph is not minimally connected, you can remove an edge and it wouldn't fall apart. but then it would be true of the super graph too the larger graph too. and we already know that the large graph is minimally connected, so the prove is sort of unsatisfying, it's an easy proof by contradiction. okay finally we have our inductive hypothesis, notice here all I've done is I restated the theorem for graphs with fewer vertices. So it just says for any j less than the size of vertex z, any minimally connected graph containing that lesser number of vertices has j-1 edges. That's the inductive hypothesis, I'm gonna ask you where we're gonna apply it. So base case, a minimally connected graph of 1 vertex have no edges. Is that true? Yes. we're going to take a large graph and break it apart. we're going to pull out any one of the vertices and its incident edges. remove its incident edges, partitioning the graph into how many components do we end up in the graph? d+1. where c0 is going to be the vertex we remove. choose any vertex w and the edge set is empty. all the other components are going to look like this. How many edges do we have in the whole thing? all of we gonna do is count up edges. How many edges (what's the size of the edge set) are there in component k (any one of the component)? you know how many there are.
Umm, So I think, so the question is, how well do we need to know this, yes? Is that right? Um, So absolutely you should know that a tree has (n-1) edges. okay? Connected acyclic graph has number of vertices minus one edges. Thats should be a back pocket result, okay? Now, should you be able to prove it? This is kind of an accessible proof, because, we can draw a picture that will guide you through it. So the process of doing this proof is, draw yourself a little picture, give yourself labels to argue about, and then, just put it all together. Okay? So, should you memorise it? Well no, you shouldn't. Should you know how to do it? I think so. I think you should. CS 374 demands much more robust proofs regularly, so, if this is an on-ramp to that kind of argument, then you know, so be it. I think its appropriate. YEAH? Where, right here? Right here? Right here? huh? This one right here? Look, this one? Inductive hypothesis. Oh my gosh, I'm sorry. I'm doing this at me, not at you. Who knew you could be unclear in that particular way. I'm sorry. Alright, anything else? Yeah? Right here? Its the number of components. So, choose any vertex and let D denote its degree, remove its incident edges, partitioning the graph into D+1 components. So, I'm adding up from component 0 to component D, the last one, all of the edges. Okay? Is that alright? Alright. You good? It is what it is. Okay, lets move toward implementations. Alright, I wanna say a little thing about implementing graphs. You have been implementing graphs ever since about MP4 I believe. Yeah! The MP4 where you did flood fill you know. You were just operating on a lattice shaped graph that we think of as an image. Right? Its a pixel together with its neighbours. Each pixel is like a vertex. Each neighbour represents an edge. So, you've already operated on graphs. Now, that is extremely common, where the graph implementation itself is implicit in the application, okay? So, there may be lots of instances where doing graph algorithms, but you don't necessarily have an explicit graph data structure that you;re gonna point to. Instead you'll be talking about shapes, or who knows what else. States, game search engine, or something like that. So graphs are often are often not explicit in your algorithms, All of that said, there are some classic results that arise from classic implementations of graphs and we have to talk about those because everybody in your future world will expect you to know about these particular graph implementations. So we're gonna talk about them. Alright, so we're going to have an abstract data type that is a graph. The data associated with it will be some structure that reflects the vertices. Oftentimes this will be just a map or a hash table of vertices. Maybe its just a vector, where each vertex identifier is an index. Who knows, open to application, Doesn't matter that much. Same thing with edges, you have to have some structure that stores all the edges in your graph. Now what is that, I don't know. Maybe its a hash table again. Alright. But then, you also need some structure that reflects the connectivity of the graph. This is where we're gonna spend a lot of our energy. So this is like a look up table for data about vertices. This is like a lookup table for data about edges. And this is some structure that keeps track of how all the graph is connected.
umm so I think so the question is how well do we need to know this so absolutely you should know that the tree has n-1 edges. connected acyclic graph has number vertices minus one edges that should be a back pocket result. Should you be able to prove it. This is kind of I think an accessible proof. Because you can draw a picture that will guide you through it. Draw yourself a little picture and give yourself labels to argue about and then just put it all together. Should you memorize it? No, you shouldn't. Should you know how to do it? I think so. I think you should. CS347 demands much more robust proofs regularly so if this is a on-ramp to that kind of argument then you know so be it. I think it's appropriate. Yeah? Where? Right here? Right here? huh? This one right here? Look this one? Inductive hypothesis. Oh my gosh. I'm sorry. I'm doing this at me not at you. who knew. you could be unclear in that particular way. anything else? yeah? Right here? It's the number of components. So choosing the vertex and let d denote the degree remove the edges, partitioning the graph into d+1 components so I'm adding up component zero to component d the last one all the edges. Alright, we are good? It is what it is. Ok let's move towards implementation. I want to say little thing about implementing graph. You have been implementing graph ever since about MP4 I believe. Yeah! mp4 where you did flood fill. You were just operating on a lattice-shape graph that we think of as an image, right? It's a pixel together with its neighbors. Each pixel is like a vertex. Each neighbor represents an edge. You already operated on graph. That is extremely common where the graph implementation itself is implicit in the application. so there maybe lots of instances where doing graph algorithms where you don't necessary have an explicit graph data structure that you are gonna point to instead you will talking about shape or who knows what else? state in a game search engine or something like that. graphs are often not explicit in your algorithms. All of that said, there are some classic results that arises from classic implementations of graphs and we have to talk about those because everybody in your future world will expect you to know about these particular graph implementations so we will talk about them so we are going to have an abstract data type that is a graph. The data associate with it will be some structure that reflects the vertices often time it will just be a map or hash table of vertices maybe it's just a vector where each vertex identifier is an index. Who knows. opened to application. doesn't matter that much. same thing with edges. You have to have some structure that stores all the edges in your graph. Now what is that? I don't know. Maybe it's a hash table again. alright but then you also need some structure that reflects the connectivity of the graph. this is where we are gonna spend a lot of our energy. This is like a look up table for data about the vertices. This is like a look up table for data about the edges and this is some structure that keeps track of how the graph is connected.
Okay, now... Functions on such an abstract data type are many, There are many many. Uh, at a minimum we have to be able to insert vertices and edges, remove vertices and edges. It's very common to need the set of incident edges given a vertex. So this function would return to you, would return a set of incident edges, or an iterator over them, for example. OK? But the way you should think about this function is as returning a set of incident edges. OK? Our adjacent is a boolean that tells whether not v1 v2 is an edge in the class, see just test, and then finally these two we'll talk about them more... They are only for directed graphs. For now we're going to assume our graphs are not directed, they are undirected. Alright, any questions so far? Here's how we're going to do this. We're going to look at three different implementations and we're going to compare a few functions across all of them. Now, we're not going to look at all of the functions on the previous page, because we would fall asleep. These functions are adequate for getting at all of the issues. OK? Alright, implementation one. It's called an edge list, and basically it works like this. It is a structure for this, a structure for this, a structure for this, and we're not going to specify any particular reflection of the connectivity. OK? So we're just going to have maybe it's a hash table, constant time access to the vertices. Constant time access to the edges, and that's our structure. That's it. OK? Now, what does it look like? What does it, what does the implementation look like? The data associated with each of these things. Well the vertices it's just a list of vertices. Maybe you associate a weight with them, or a time they were created, or any other data that you want. But for now they are just a set, it's just a set of vertices, or a map of vertices. The edges though are more interesting. Edge A, for example, will contain data that reflects it's endpoints. We've got u and v here. B has v and w. C has u and w. And D has w and z. We're going to engineer everything so that u v is the same as v u. So it doesn't matter which order I put those in. Alright, any question about that? Yes? [gibberish] So that's a more complex, that is, that actually does... So what you're suggesting, so the suggestion on the floor is how can this be a good idea? Wouldn't it be a better idea to list for each vertex it's set of incident edges, and yes, that would be a better implementation. But we're not going to do it yet, we're going to be stupid first, because that's what we do around here. OK? We do things naively first, and then we'll move into complexity. OK, so I want to know how long does it take to insert a new vertex into this structure? There, I did it. How long does it take to add a new vertex into this structure? Constant time, very good. OK, this is adding into either the array or map. You have to be able to assume it's constant time. Fine. How about removing a vertex? Oh, and I'll use this notation. The size of the vertex set is n, the size of the edge set is m. So there are n of these and m of those. Ok, what does it mean to remove a vertex? Here, there I removed v and I have to remove all of it's incident edges. So removing a vertex really means remove the vertex and incident edges. So how long does that take? Big O of m is correct. Because we have to search this structure, right? Oh, there's a v, there's a v, and no more v's. We have to search that structure.
Alright, how about checking to see whether two v
Checking to see if two vertices are adjacent, or whether an edge exists in the graph. Go looking, no choice but to traverse that edge list looking for two end points. Returning the set of incident edges for a given vertex. Again, this is boring. You have to go in search of them. Decidedly uninteresting. Another strategy; keep the vertex set at size n and edge set at size m, but add a table with a row for every vertex and a column for every vertex. This is a probably implemented as a 2 dimensional (2D) array. The data stored here would tell you the index of this row, for example. The implementation, you would connect this to this row in the table. Similarly for the column, you'd also have some index here that's specified by the column, it'll be the same column as row. There is going to be an entry in cell uv if uv exists in the graph. Now it turns out to be very convenient to instead of just a boolean indicator, to keep a pointer to the edge that actually exists. Then you can store data about that edge, so uw is it there? Other things are just NULL. It's called an adjacency matrix. Running times of each of these functions given all of this structure. How long does it take to insert a vertex? What if the matrix is full? This is a 2 dimensional array. We need to be able to add a row and column to this matrix, and you know we're not stoopid. We're going to do it in such a way that we actually double the size (and copy the data). And the advertised cost for this (the cost of copying) is n squared (n^2). But we get n future adds for free, so the overall cost is going to be big O of n (O(n)) for re sizing. So periodically you have to do an expensive re size. How about removing a vertex? It's the same story. Actually. Let's remove v. How do I remove v from here?
O(n). Any questions about it? We will leave it blank and resize it downwards em when it gets too sparse. So we don't need to shift the data but we do have to walk across looking for all of them. ok? alright, good question. How about checking to see if to vertices are adjacent? O(1). Yeah! This is why this one is so beautiful. This is a constant time array look up right? Is this null is this null is this null......That's it. yeah? Yeah you also have to go down to the bottom but that's n as well. thank you for saying that. So you have to go this way too. yeah so it is two n instead of 1 sorry. Alright and finally how long dose it take to return the set of incident edges given an vertex. Where do they come from? they come from the array on the table right? And so this is O(n) as well. Is that better than this? Is that better than the one on then previous slide? The answer is it depends. What dose it depends on? Yes how big the n is! That is right. Whether m is bigger or smaller than n. very good. In general it is better. ok? it is pretty rare you would not implement your graph using this structure if you don't have many edges. So in general this is a better approach. Next time we will get to [gibberish] of recommendation and we will do an implementation called an adjacency list.